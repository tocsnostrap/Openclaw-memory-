import { APIResource } from "../../core/resource.mjs";
import { APIPromise } from "../../core/api-promise.mjs";
import { RequestOptions } from "../../internal/request-options.mjs";
export declare class Session extends APIResource {
    /**
     * Creates a new session for the tool router feature. This endpoint initializes a
     * new session with specified toolkits and their authentication configurations. The
     * session provides an isolated environment for testing and managing tool routing
     * logic with scoped MCP server access.
     *
     * @example
     * ```ts
     * const session = await client.toolRouter.session.create({
     *   user_id: 'user_123456789',
     * });
     * ```
     */
    create(body: SessionCreateParams, options?: RequestOptions): APIPromise<SessionCreateResponse>;
    /**
     * Retrieves an existing tool router session by its ID. Returns the session
     * configuration, MCP server URL, and available tools.
     *
     * @example
     * ```ts
     * const session = await client.toolRouter.session.retrieve(
     *   'trs_123456789',
     * );
     * ```
     */
    retrieve(sessionID: string, options?: RequestOptions): APIPromise<SessionRetrieveResponse>;
    /**
     * Executes a specific tool within a tool router session. The toolkit is
     * automatically inferred from the tool slug. The tool must belong to an allowed
     * toolkit and must not be disabled in the session configuration. This endpoint
     * validates permissions, resolves connected accounts, and executes the tool with
     * the session context.
     *
     * @example
     * ```ts
     * const response = await client.toolRouter.session.execute(
     *   'trs_LX9uJKBinWWr',
     *   { tool_slug: 'GITHUB_CREATE_ISSUE' },
     * );
     * ```
     */
    execute(sessionID: string, body: SessionExecuteParams, options?: RequestOptions): APIPromise<SessionExecuteResponse>;
    /**
     * Executes a Composio meta tool (COMPOSIO\_\*) within a tool router session.
     *
     * @example
     * ```ts
     * const response =
     *   await client.toolRouter.session.executeMeta(
     *     'trs_LX9uJKBinWWr',
     *     { slug: 'COMPOSIO_MANAGE_CONNECTIONS' },
     *   );
     * ```
     */
    executeMeta(sessionID: string, body: SessionExecuteMetaParams, options?: RequestOptions): APIPromise<SessionExecuteMetaResponse>;
    /**
     * Initiates an authentication link session for a specific toolkit within a tool
     * router session. Returns a link token and redirect URL that users can use to
     * complete the OAuth flow.
     *
     * @example
     * ```ts
     * const response = await client.toolRouter.session.link(
     *   'trs_LX9uJKBinWWr',
     *   { toolkit: 'github' },
     * );
     * ```
     */
    link(sessionID: string, body: SessionLinkParams, options?: RequestOptions): APIPromise<SessionLinkResponse>;
    /**
     * Retrieves a cursor-paginated list of toolkits available in the tool router
     * session. Includes toolkit metadata, composio-managed auth schemes, and connected
     * accounts if available. Optionally filter by specific toolkit slugs.
     *
     * @example
     * ```ts
     * const response = await client.toolRouter.session.toolkits(
     *   'trs_123456789',
     * );
     * ```
     */
    toolkits(sessionID: string, query?: SessionToolkitsParams | null | undefined, options?: RequestOptions): APIPromise<SessionToolkitsResponse>;
    /**
     * Returns the meta tools available in a tool router session with their complete
     * schemas. This includes request and response schemas specific to the session
     * context.
     *
     * @example
     * ```ts
     * const response = await client.toolRouter.session.tools(
     *   'session_id',
     * );
     * ```
     */
    tools(sessionID: string, query?: SessionToolsParams | null | undefined, options?: RequestOptions): APIPromise<SessionToolsResponse>;
}
export interface SessionCreateResponse {
    /**
     * The session configuration including user, toolkits, and overrides
     */
    config: SessionCreateResponse.Config;
    mcp: SessionCreateResponse.Mcp;
    /**
     * The identifier of the session
     */
    session_id: string;
    /**
     * List of available tools in this session
     */
    tool_router_tools: Array<string>;
    /**
     * Experimental features including the generated system prompt. Only returned on
     * session creation, not on GET.
     */
    experimental?: SessionCreateResponse.Experimental;
}
export declare namespace SessionCreateResponse {
    /**
     * The session configuration including user, toolkits, and overrides
     */
    interface Config {
        /**
         * User identifier for this session
         */
        user_id: string;
        /**
         * Auth config overrides per toolkit
         */
        auth_configs?: {
            [key: string]: string;
        };
        /**
         * Connected account overrides per toolkit
         */
        connected_accounts?: {
            [key: string]: string;
        };
        /**
         * Manage connections configuration
         */
        manage_connections?: Config.ManageConnections;
        /**
         * MCP tool annotation hints for filtering tools with enabled/disabled support.
         * enabled: tags that the tool must have at least one of. disabled: tags that the
         * tool must NOT have any of. Both conditions must be satisfied.
         */
        tags?: Config.Tags;
        /**
         * Toolkit configuration - either enabled list or disabled list
         */
        toolkits?: Config.Enabled | Config.Disabled;
        /**
         * Tool-level configuration per toolkit
         */
        tools?: {
            [key: string]: Config.Enabled | Config.Disabled | Config.Tags;
        };
        /**
         * Workbench configuration
         */
        workbench?: Config.Workbench;
    }
    namespace Config {
        /**
         * Manage connections configuration
         */
        interface ManageConnections {
            /**
             * Custom callback URL for connected account auth flows
             */
            callback_url?: string;
            /**
             * Enable the COMPOSIO_WAIT_FOR_CONNECTIONS tool for polling connection status.
             * Default false. May not work reliably with GPT models.
             */
            enable_wait_for_connections?: boolean;
            /**
             * Whether to enable the connection manager for automatic connection handling
             */
            enabled?: boolean;
        }
        /**
         * MCP tool annotation hints for filtering tools with enabled/disabled support.
         * enabled: tags that the tool must have at least one of. disabled: tags that the
         * tool must NOT have any of. Both conditions must be satisfied.
         */
        interface Tags {
            /**
             * Tags that the tool must NOT have any of
             */
            disabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
            /**
             * Tags that the tool must have at least one of
             */
            enabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
        }
        interface Enabled {
            enabled: Array<string>;
        }
        interface Disabled {
            disabled: Array<string>;
        }
        interface Enabled {
            enabled: Array<string>;
        }
        interface Disabled {
            disabled: Array<string>;
        }
        interface Tags {
            tags: Tags.Tags;
        }
        namespace Tags {
            interface Tags {
                /**
                 * Tags that the tool must NOT have any of
                 */
                disabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
                /**
                 * Tags that the tool must have at least one of
                 */
                enabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
            }
        }
        /**
         * Workbench configuration
         */
        interface Workbench {
            /**
             * Character threshold after which tool execution response are saved to a file in
             * workbench. Default is 20k.
             */
            auto_offload_threshold?: number;
            /**
             * Whether proxy execution is enabled in the workbench
             */
            proxy_execution_enabled?: boolean;
        }
    }
    interface Mcp {
        /**
         * The type of the MCP server. Can be http
         */
        type: 'http';
        /**
         * The URL of the MCP server
         */
        url: string;
    }
    /**
     * Experimental features including the generated system prompt. Only returned on
     * session creation, not on GET.
     */
    interface Experimental {
        /**
         * The assistive system prompt to inject into your agent for optimal tool router
         * usage
         */
        assistive_prompt: string;
    }
}
export interface SessionRetrieveResponse {
    /**
     * The session configuration including user, toolkits, and overrides
     */
    config: SessionRetrieveResponse.Config;
    mcp: SessionRetrieveResponse.Mcp;
    /**
     * The identifier of the session
     */
    session_id: string;
    /**
     * List of available tools in this session
     */
    tool_router_tools: Array<string>;
}
export declare namespace SessionRetrieveResponse {
    /**
     * The session configuration including user, toolkits, and overrides
     */
    interface Config {
        /**
         * User identifier for this session
         */
        user_id: string;
        /**
         * Auth config overrides per toolkit
         */
        auth_configs?: {
            [key: string]: string;
        };
        /**
         * Connected account overrides per toolkit
         */
        connected_accounts?: {
            [key: string]: string;
        };
        /**
         * Manage connections configuration
         */
        manage_connections?: Config.ManageConnections;
        /**
         * MCP tool annotation hints for filtering tools with enabled/disabled support.
         * enabled: tags that the tool must have at least one of. disabled: tags that the
         * tool must NOT have any of. Both conditions must be satisfied.
         */
        tags?: Config.Tags;
        /**
         * Toolkit configuration - either enabled list or disabled list
         */
        toolkits?: Config.Enabled | Config.Disabled;
        /**
         * Tool-level configuration per toolkit
         */
        tools?: {
            [key: string]: Config.Enabled | Config.Disabled | Config.Tags;
        };
        /**
         * Workbench configuration
         */
        workbench?: Config.Workbench;
    }
    namespace Config {
        /**
         * Manage connections configuration
         */
        interface ManageConnections {
            /**
             * Custom callback URL for connected account auth flows
             */
            callback_url?: string;
            /**
             * Enable the COMPOSIO_WAIT_FOR_CONNECTIONS tool for polling connection status.
             * Default false. May not work reliably with GPT models.
             */
            enable_wait_for_connections?: boolean;
            /**
             * Whether to enable the connection manager for automatic connection handling
             */
            enabled?: boolean;
        }
        /**
         * MCP tool annotation hints for filtering tools with enabled/disabled support.
         * enabled: tags that the tool must have at least one of. disabled: tags that the
         * tool must NOT have any of. Both conditions must be satisfied.
         */
        interface Tags {
            /**
             * Tags that the tool must NOT have any of
             */
            disabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
            /**
             * Tags that the tool must have at least one of
             */
            enabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
        }
        interface Enabled {
            enabled: Array<string>;
        }
        interface Disabled {
            disabled: Array<string>;
        }
        interface Enabled {
            enabled: Array<string>;
        }
        interface Disabled {
            disabled: Array<string>;
        }
        interface Tags {
            tags: Tags.Tags;
        }
        namespace Tags {
            interface Tags {
                /**
                 * Tags that the tool must NOT have any of
                 */
                disabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
                /**
                 * Tags that the tool must have at least one of
                 */
                enabled?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
            }
        }
        /**
         * Workbench configuration
         */
        interface Workbench {
            /**
             * Character threshold after which tool execution response are saved to a file in
             * workbench. Default is 20k.
             */
            auto_offload_threshold?: number;
            /**
             * Whether proxy execution is enabled in the workbench
             */
            proxy_execution_enabled?: boolean;
        }
    }
    interface Mcp {
        /**
         * The type of the MCP server. Can be http
         */
        type: 'http';
        /**
         * The URL of the MCP server
         */
        url: string;
    }
}
export interface SessionExecuteResponse {
    /**
     * The data returned by the tool execution
     */
    data: {
        [key: string]: unknown;
    };
    /**
     * Error message if the execution failed, null otherwise
     */
    error: string | null;
    /**
     * Unique identifier for the execution log
     */
    log_id: string;
}
export interface SessionExecuteMetaResponse {
    /**
     * The data returned by the tool execution
     */
    data: {
        [key: string]: unknown;
    };
    /**
     * Error message if the execution failed, null otherwise
     */
    error: string | null;
    /**
     * Unique identifier for the execution log
     */
    log_id: string;
}
export interface SessionLinkResponse {
    /**
     * The unique identifier for the connected account
     */
    connected_account_id: string;
    /**
     * Token used to complete the authentication flow
     */
    link_token: string;
    /**
     * The URL where users should be redirected to complete OAuth
     */
    redirect_url: string;
}
export interface SessionToolkitsResponse {
    current_page: number;
    items: Array<SessionToolkitsResponse.Item>;
    total_items: number;
    total_pages: number;
    next_cursor?: string | null;
}
export declare namespace SessionToolkitsResponse {
    interface Item {
        /**
         * Available Composio-managed auth schemes
         */
        composio_managed_auth_schemes: Array<string>;
        /**
         * Connected account if available
         */
        connected_account: Item.ConnectedAccount | null;
        /**
         * Whether the toolkit is enabled
         */
        enabled: boolean;
        /**
         * Whether the toolkit is no-auth
         */
        is_no_auth: boolean;
        /**
         * Toolkit metadata
         */
        meta: Item.Meta;
        /**
         * Display name of the toolkit
         */
        name: string;
        /**
         * Unique slug identifier
         */
        slug: string;
    }
    namespace Item {
        /**
         * Connected account if available
         */
        interface ConnectedAccount {
            /**
             * Connected account identifier
             */
            id: string;
            /**
             * Auth config details
             */
            auth_config: ConnectedAccount.AuthConfig;
            /**
             * Creation timestamp
             */
            created_at: string;
            /**
             * Connection status
             */
            status: string;
            /**
             * User identifier
             */
            user_id: string;
        }
        namespace ConnectedAccount {
            /**
             * Auth config details
             */
            interface AuthConfig {
                /**
                 * Auth config identifier
                 */
                id: string;
                /**
                 * Authentication scheme type
                 */
                auth_scheme: string;
                /**
                 * Whether this is a Composio-managed auth config
                 */
                is_composio_managed: boolean;
            }
        }
        /**
         * Toolkit metadata
         */
        interface Meta {
            /**
             * Description of the toolkit
             */
            description: string;
            /**
             * URL to the toolkit logo
             */
            logo: string;
        }
    }
}
export interface SessionToolsResponse {
    /**
     * List of tools with their complete schemas
     */
    items: Array<SessionToolsResponse.Item>;
}
export declare namespace SessionToolsResponse {
    interface Item {
        /**
         * List of all available versions for this tool
         */
        available_versions: Array<string>;
        deprecated: Item.Deprecated;
        /**
         * Detailed explanation of the tool's functionality and purpose
         */
        description: string;
        /**
         * Schema definition of required input parameters for the tool
         */
        input_parameters: {
            [key: string]: unknown;
        };
        /**
         * Indicates if this tool is deprecated and may be removed in the future
         */
        is_deprecated: boolean;
        /**
         * Human-readable display name of the tool
         */
        name: string;
        /**
         * Indicates if the tool can be used without authentication
         */
        no_auth: boolean;
        /**
         * Schema definition of return values from the tool
         */
        output_parameters: {
            [key: string]: unknown;
        };
        /**
         * List of scopes associated with the tool
         */
        scopes: Array<string>;
        /**
         * Unique identifier for the tool
         */
        slug: string;
        /**
         * Lifecycle status of the tool
         */
        status: string;
        /**
         * List of tags associated with the tool for categorization and filtering
         */
        tags: Array<string>;
        toolkit: Item.Toolkit;
        /**
         * Current version of the tool
         */
        version: string;
    }
    namespace Item {
        interface Deprecated {
            /**
             * List of all available versions for this tool
             */
            available_versions: Array<string>;
            /**
             * The display name of the tool
             */
            displayName: string;
            /**
             * Indicates if this tool is deprecated and may be removed in the future
             */
            is_deprecated: boolean;
            toolkit: Deprecated.Toolkit;
            /**
             * Current version identifier of the tool
             */
            version: string;
        }
        namespace Deprecated {
            interface Toolkit {
                /**
                 * URL to the toolkit logo image
                 */
                logo: string;
            }
        }
        interface Toolkit {
            /**
             * URL to the toolkit logo image
             */
            logo: string;
            /**
             * Human-readable name of the parent toolkit
             */
            name: string;
            /**
             * Unique identifier of the parent toolkit
             */
            slug: string;
        }
    }
}
export interface SessionCreateParams {
    /**
     * The identifier of the user who is initiating the session, ideally a unique
     * identifier from your database like a user ID or email address
     */
    user_id: string;
    /**
     * The auth configs to use for the session. This will override the default behavior
     * and use the given auth config when specific toolkits are being executed
     */
    auth_configs?: {
        [key: string]: string;
    };
    /**
     * The connected accounts to use for the session. This will override the default
     * behaviour and use the given connected account when specific toolkits are being
     * executed
     */
    connected_accounts?: {
        [key: string]: string;
    };
    /**
     * Experimental features - not stable, may be modified or removed in future
     * versions.
     */
    experimental?: SessionCreateParams.Experimental;
    /**
     * Configuration for connection management settings
     */
    manage_connections?: SessionCreateParams.ManageConnections;
    /**
     * Global MCP tool annotation hints for filtering. Array format is treated as
     * enabled list. Object format supports both enabled (tool must have at least one)
     * and disabled (tool must NOT have any) lists. Toolkit-level tags override this.
     * Toolkit enabled/disabled lists take precedence over tag filtering.
     */
    tags?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'> | SessionCreateParams.UnionMember1;
    /**
     * Toolkit configuration - specify either enable toolkits (allowlist) or disable
     * toolkits (denylist). Mutually exclusive.
     */
    toolkits?: SessionCreateParams.Enable | SessionCreateParams.Disable;
    /**
     * Tool-level configuration per toolkit - either specify enable tools (whitelist),
     * disable tools (blacklist), or filter by MCP tags for each toolkit
     */
    tools?: {
        [key: string]: SessionCreateParams.Enable | SessionCreateParams.Disable | SessionCreateParams.Tags;
    };
    /**
     * Configuration for workbench behavior
     */
    workbench?: SessionCreateParams.Workbench;
}
export declare namespace SessionCreateParams {
    /**
     * Experimental features - not stable, may be modified or removed in future
     * versions.
     */
    interface Experimental {
        /**
         * Customize assistive prompt generation (e.g., timezone).
         */
        assistive_prompt_config?: Experimental.AssistivePromptConfig;
    }
    namespace Experimental {
        /**
         * Customize assistive prompt generation (e.g., timezone).
         */
        interface AssistivePromptConfig {
            /**
             * IANA timezone identifier (e.g., 'America/New_York', 'Europe/London'). Used to
             * customize the system prompt with timezone-aware instructions.
             */
            user_timezone?: string;
        }
    }
    /**
     * Configuration for connection management settings
     */
    interface ManageConnections {
        /**
         * The URL to redirect to after a user completes authentication for a connected
         * account. This allows you to handle the auth callback in your own application.
         */
        callback_url?: string;
        /**
         * Whether to enable the connection manager for automatic connection handling. If
         * true, we will provide a tool your agent can use to initiate connections to
         * toolkits if it doesnt exist. If set to false, then you have to manage
         * connections manually.
         */
        enable?: boolean | null;
        /**
         * When true, the COMPOSIO_WAIT_FOR_CONNECTIONS tool is available for agents to
         * poll connection status after sharing auth URLs. Default is false (disabled). May
         * not work reliably with GPT models.
         */
        enable_wait_for_connections?: boolean | null;
    }
    interface UnionMember1 {
        /**
         * Tags that the tool must NOT have any of
         */
        disable?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
        /**
         * Tags that the tool must have at least one of
         */
        enable?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
    }
    /**
     * Enable only specific toolkits (allowlist)
     */
    interface Enable {
        /**
         * Only these specific toolkits will be enabled
         */
        enable: Array<string>;
    }
    /**
     * Disable specific toolkits (denylist)
     */
    interface Disable {
        /**
         * These specific toolkits will be disabled
         */
        disable: Array<string>;
    }
    interface Enable {
        /**
         * Only these specific tools will be available for this toolkit
         */
        enable: Array<string>;
    }
    interface Disable {
        /**
         * These specific tools will be disabled for this toolkit
         */
        disable: Array<string>;
    }
    interface Tags {
        /**
         * MCP tags to filter tools. Array format is treated as enabled list. Object format
         * supports both enabled and disabled lists.
         */
        tags: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'> | Tags.UnionMember1;
    }
    namespace Tags {
        interface UnionMember1 {
            /**
             * Tags that the tool must NOT have any of
             */
            disable?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
            /**
             * Tags that the tool must have at least one of
             */
            enable?: Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>;
        }
    }
    /**
     * Configuration for workbench behavior
     */
    interface Workbench {
        /**
         * Character threshold for automatic offloading. When workbench response exceeds
         * this threshold, it will be automatically offloaded. Default is picked
         * automatically based on the response size.
         */
        auto_offload_threshold?: number;
        /**
         * Whether proxy execution is enabled. When enabled, workbench can call URLs and
         * APIs directly.
         */
        enable_proxy_execution?: boolean;
    }
}
export interface SessionExecuteParams {
    /**
     * The unique slug identifier of the tool to execute
     */
    tool_slug: string;
    /**
     * The arguments required by the tool
     */
    arguments?: {
        [key: string]: unknown;
    };
}
export interface SessionExecuteMetaParams {
    /**
     * The unique slug identifier of the meta tool to execute
     */
    slug: 'COMPOSIO_SEARCH_TOOLS' | 'COMPOSIO_MULTI_EXECUTE_TOOL' | 'COMPOSIO_MANAGE_CONNECTIONS' | 'COMPOSIO_WAIT_FOR_CONNECTIONS' | 'COMPOSIO_REMOTE_WORKBENCH' | 'COMPOSIO_REMOTE_BASH_TOOL' | 'COMPOSIO_GET_TOOL_SCHEMAS' | 'COMPOSIO_UPSERT_RECIPE' | 'COMPOSIO_GET_RECIPE';
    /**
     * The arguments required by the meta tool
     */
    arguments?: {
        [key: string]: unknown;
    };
}
export interface SessionLinkParams {
    /**
     * The unique slug identifier of the toolkit to connect
     */
    toolkit: string;
    /**
     * URL where users will be redirected after completing auth
     */
    callback_url?: string;
}
export interface SessionToolkitsParams {
    /**
     * Cursor for pagination. The cursor is a base64 encoded string of the page and
     * limit. The page is the page number and the limit is the number of items per
     * page. The cursor is used to paginate through the items. The cursor is not
     * required for the first page.
     */
    cursor?: string;
    /**
     * Whether to filter by connected toolkits. If provided, only connected toolkits
     * will be returned.
     */
    is_connected?: boolean | null;
    /**
     * Number of items per page, max allowed is 1000
     */
    limit?: number | null;
    /**
     * Search query to filter toolkits by name, slug, or description
     */
    search?: string;
    /**
     * Optional comma-separated list of toolkit slugs to filter by. If provided, only
     * these toolkits will be returned, overriding the session configuration.
     */
    toolkits?: Array<string> | null;
}
export interface SessionToolsParams {
}
export declare namespace Session {
    export { type SessionCreateResponse as SessionCreateResponse, type SessionRetrieveResponse as SessionRetrieveResponse, type SessionExecuteResponse as SessionExecuteResponse, type SessionExecuteMetaResponse as SessionExecuteMetaResponse, type SessionLinkResponse as SessionLinkResponse, type SessionToolkitsResponse as SessionToolkitsResponse, type SessionToolsResponse as SessionToolsResponse, type SessionCreateParams as SessionCreateParams, type SessionExecuteParams as SessionExecuteParams, type SessionExecuteMetaParams as SessionExecuteMetaParams, type SessionLinkParams as SessionLinkParams, type SessionToolkitsParams as SessionToolkitsParams, type SessionToolsParams as SessionToolsParams, };
}
//# sourceMappingURL=session.d.mts.map