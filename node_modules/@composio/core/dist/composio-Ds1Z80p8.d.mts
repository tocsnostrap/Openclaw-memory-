import { $t as SessionExecuteMetaModifiers, En as ToolRetrievalOptions, Nn as ToolkitVersionParam, Qt as ProviderOptions, X as McpServerGetResponse, Xt as ExecuteToolModifiers, _n as ToolExecuteResponse$1, at as ExecuteToolFnOptions, bn as ToolListParams, dn as SchemaModifierOptions, dt as ConnectionDataSchema, en as SessionMetaToolOptions, fn as Tool, hn as ToolExecuteParams, n as BaseComposioProvider, pn as ToolExecuteMetaParams, r as BaseNonAgenticProvider, tt as McpUrlResponse, ut as ConnectionData, wn as ToolProxyParams, yn as ToolList } from "./BaseProvider-C7yGAyLz.mjs";
import ComposioClient, { Composio } from "@composio/client";
import z, { z as z$1 } from "zod/v3";
import { OpenAI } from "openai";
import { Files } from "#files";
import { ToolExecuteResponse, ToolGetInputParams, ToolGetInputResponse, ToolProxyResponse, ToolRetrieveEnumResponse } from "@composio/client/resources/tools";
import { TriggersTypeRetrieveEnumResponse } from "@composio/client/resources/index";
import { AuthConfigDeleteResponse, AuthConfigUpdateResponse, AuthConfigUpdateStatusResponse } from "@composio/client/resources/auth-configs";
import { ConnectedAccountDeleteResponse, ConnectedAccountRefreshResponse, ConnectedAccountUpdateStatusParams, ConnectedAccountUpdateStatusResponse } from "@composio/client/resources/connected-accounts";
import { Stream } from "openai/streaming";

//#region src/types/customTool.types.d.ts
type BaseCustomToolOptions<T extends z$1.ZodType> = {
  name: string;
  description?: string;
  slug: string;
  inputParams: T;
};
type ToolkitBasedExecute<T extends z$1.ZodType> = {
  execute: (input: z$1.infer<T>, connectionConfig: ConnectionData | null, executeToolRequest: (data: ToolProxyParams) => Promise<ToolExecuteResponse>) => Promise<ToolExecuteResponse>;
  toolkitSlug: string;
};
type StandaloneExecute<T extends z$1.ZodType> = {
  execute: (input: z$1.infer<T>) => Promise<ToolExecuteResponse>;
  toolkitSlug?: never;
};
type CustomToolOptions<T extends z$1.ZodType> = BaseCustomToolOptions<T> & (ToolkitBasedExecute<T> | StandaloneExecute<T>);
type CustomToolRegistry = Map<string, {
  options: CustomToolOptions<CustomToolInputParameter>;
  schema: Tool;
}>;
type InputParamsSchema = {
  definitions: {
    input: {
      type: string;
      properties: Record<string, unknown>;
      required?: string[];
    };
  };
};
type CustomToolInputParameter = z$1.ZodType;
interface CustomToolRegistryItem {
  options: CustomToolOptions<CustomToolInputParameter>;
  schema: Tool;
}
interface ExecuteMetadata {
  userId: string;
  connectedAccountId?: string;
}
//#endregion
//#region src/models/Tools.d.ts
/**
 * This class is used to manage tools in the Composio SDK.
 * It provides methods to list, get, and execute tools.
 */
declare class Tools<TToolCollection, TTool, TProvider extends BaseComposioProvider<TToolCollection, TTool, unknown>> {
  private client;
  private readonly customTools;
  private provider;
  private autoUploadDownloadFiles;
  private toolkitVersions;
  constructor(client: ComposioClient, config?: ComposioConfig<TProvider>);
  /**
   * Transforms tool data from snake_case API format to camelCase for internal SDK use.
   *
   * This method standardizes the property naming convention for tools retrieved from the Composio API,
   * making them more consistent with JavaScript/TypeScript conventions.
   *
   * @param {ToolRetrieveResponse | ComposioToolListResponse['items'][0]} tool - The tool object to transform
   * @returns {Tool} The transformed tool with camelCase properties
   *
   * @private
   */
  private transformToolCases;
  /**
   * Transforms tool execution response from snake_case API format to camelCase.
   *
   * This method converts the response received from the Composio API to a standardized format
   * with consistent property naming that follows JavaScript/TypeScript conventions.
   *
   * @param {ComposioToolExecuteResponse} response - The raw API response to transform
   * @returns {ToolExecuteResponse} The transformed response with camelCase properties
   *
   * @private
   */
  private transformToolExecuteResponse;
  /**
   * Applies the default schema modifiers to the tools
   * @param tools - The tools to apply the default schema modifiers to
   * @returns The tools with the default schema modifiers applied
   */
  private applyDefaultSchemaModifiers;
  /**
   * Applies the before execute modifiers to the tool execution params
   * @param options.toolSlug - The slug of the tool
   * @param options.toolkitSlug - The slug of the toolkit
   * @param options.params - The params of the tool execution
   * @param modifier - The modifier to apply
   * @returns The modified params
   */
  private applyBeforeExecuteModifiers;
  /**
   * Applies the after execute modifiers to the tool execution result
   * @param options.toolSlug - The slug of the tool
   * @param options.toolkitSlug - The slug of the toolkit
   * @param options.result - The result of the tool execution
   * @param modifier - The modifier to apply
   * @returns The modified result
   */
  private applyAfterExecuteModifiers;
  /**
   * Lists all tools available in the Composio SDK including custom tools.
   *
   * This method fetches tools from the Composio API in raw format and combines them with
   * any registered custom tools. The response can be filtered and modified as needed.
   * It provides access to the underlying tool data without provider-specific wrapping.
   *
   * @param {ToolListParams} query - Query parameters to filter the tools (required)
   * @param {GetRawComposioToolsOptions} [options] - Optional configuration for tool retrieval
   * @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform tool schemas
   * @returns {Promise<ToolList>} List of tools matching the query criteria
   *
   * @example
   * ```typescript
   * // Get tools from specific toolkits
   * const githubTools = await composio.tools.getRawComposioTools({
   *   toolkits: ['github'],
   *   limit: 10
   * });
   *
   * // Get specific tools by slug
   * const specificTools = await composio.tools.getRawComposioTools({
   *   tools: ['GITHUB_GET_REPOS', 'HACKERNEWS_GET_USER']
   * });
   *
   * // Get tools from specific toolkits
   * const githubTools = await composio.tools.getRawComposioTools({
   *   toolkits: ['github'],
   *   limit: 10
   * });
   *
   * // Get tools with schema transformation
   * const customizedTools = await composio.tools.getRawComposioTools({
   *   toolkits: ['github'],
   *   limit: 5
   * }, {
   *   modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
   *     // Add custom properties to tool schema
   *     return {
   *       ...schema,
   *       customProperty: `Modified ${toolSlug} from ${toolkitSlug}`,
   *       tags: [...(schema.tags || []), 'customized']
   *     };
   *   }
   * });
   *
   * // Search for tools
   * const searchResults = await composio.tools.getRawComposioTools({
   *   search: 'user management'
   * });
   *
   * // Get tools by authentication config
   * const authSpecificTools = await composio.tools.getRawComposioTools({
   *   authConfigIds: ['auth_config_123']
   * });
   * ```
   */
  getRawComposioTools(query: ToolListParams, options?: SchemaModifierOptions): Promise<ToolList>;
  /**
   * Fetches the meta tools for a tool router session.
   * This method fetches the meta tools from the Composio API and transforms them to the expected format.
   * It provides access to the underlying meta tool data without provider-specific wrapping.
   *
   * @param sessionId {string} The session id to get the meta tools for
   * @param options {SchemaModifierOptions} Optional configuration for tool retrieval
   * @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform the tool schema
   * @returns {Promise<ToolList>} The list of meta tools
   *
   * @example
   * ```typescript
   * const metaTools = await composio.tools.getRawToolRouterMetaTools('session_123');
   * console.log(metaTools);
   * ```
   */
  getRawToolRouterMetaTools(sessionId: string, options?: SchemaModifierOptions): Promise<ToolList>;
  /**
   * Retrieves a specific tool by its slug from the Composio API.
   *
   * This method fetches a single tool in raw format without provider-specific wrapping,
   * providing direct access to the tool's schema and metadata. Tool versions are controlled
   * at the Composio SDK initialization level through the `toolkitVersions` configuration.
   *
   * @param {string} slug - The unique identifier of the tool (e.g., 'GITHUB_GET_REPOS')
   * @param {GetRawComposioToolBySlugOptions} [options] - Optional configuration for tool retrieval
   * @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform the tool schema
   * @returns {Promise<Tool>} The requested tool with its complete schema and metadata
   *
   * @example
   * ```typescript
   * // Get a tool by slug
   * const tool = await composio.tools.getRawComposioToolBySlug('GITHUB_GET_REPOS');
   * console.log(tool.name, tool.description);
   *
   * // Get a tool with schema transformation
   * const customizedTool = await composio.tools.getRawComposioToolBySlug(
   *   'SLACK_SEND_MESSAGE',
   *   {
   *     modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
   *       return {
   *         ...schema,
   *         description: `Enhanced ${schema.description} with custom modifications`,
   *         customMetadata: {
   *           lastModified: new Date().toISOString(),
   *           toolkit: toolkitSlug
   *         }
   *       };
   *     }
   *   }
   * );
   *
   * // Get a custom tool (will check custom tools first)
   * const customTool = await composio.tools.getRawComposioToolBySlug('MY_CUSTOM_TOOL');
   *
   * // Access tool properties
   * const githubTool = await composio.tools.getRawComposioToolBySlug('GITHUB_CREATE_ISSUE');
   * console.log({
   *   slug: githubTool.slug,
   *   name: githubTool.name,
   *   toolkit: githubTool.toolkit?.name,
   *   version: githubTool.version,
   *   availableVersions: githubTool.availableVersions,
   *   inputParameters: githubTool.inputParameters
   * });
   * ```
   */
  getRawComposioToolBySlug(slug: string, options?: ToolRetrievalOptions): Promise<Tool>;
  /**
   * Get a list of tools from Composio based on filters.
   * This method fetches the tools from the Composio API and wraps them using the provider.
   *
   * @param {string} userId - The user id to get the tools for
   * @param {ToolListParams} filters - The filters to apply when fetching tools
   * @param {ProviderOptions<TProvider>} [options] - Optional provider options including modifiers
   * @returns {Promise<ReturnType<T['wrapTools']>>} The wrapped tools collection
   *
   * @example
   * ```typescript
   * // Get tools from the GitHub toolkit
   * const tools = await composio.tools.get('default', {
   *   toolkits: ['github'],
   *   limit: 10
   * });
   *
   * // Get tools with search
   * const searchTools = await composio.tools.get('default', {
   *   search: 'user',
   *   limit: 10
   * });
   *
   * // Get a specific tool by slug
   * const hackerNewsUserTool = await composio.tools.get('default', 'HACKERNEWS_GET_USER');
   *
   * // Get a tool with schema modifications
   * const tool = await composio.tools.get('default', 'GITHUB_GET_REPOS', {
   *   modifySchema: (toolSlug, toolkitSlug, schema) => {
   *     // Customize the tool schema
   *     return {...schema, description: 'Custom description'};
   *   }
   * });
   * ```
   */
  get<T extends TProvider>(userId: string, filters: ToolListParams, options?: ProviderOptions<TProvider>): Promise<ReturnType<T['wrapTools']>>;
  /**
   * Get a specific tool by its slug.
   * This method fetches the tool from the Composio API and wraps it using the provider.
   *
   * @param {string} userId - The user id to get the tool for
   * @param {string} slug - The slug of the tool to fetch
   * @param {ProviderOptions<TProvider>} [options] - Optional provider options including modifiers
   * @returns {Promise<ReturnType<T['wrapTools']>>} The wrapped tool
   *
   * @example
   * ```typescript
   * // Get a specific tool by slug
   * const hackerNewsUserTool = await composio.tools.get('default', 'HACKERNEWS_GET_USER');
   *
   * // Get a tool with schema modifications
   * const tool = await composio.tools.get('default', 'GITHUB_GET_REPOS', {
   *   modifySchema: (toolSlug, toolkitSlug, schema) => {
   *     // Customize the tool schema
   *     return {...schema, description: 'Custom description'};
   *   }
   * });
   * ```
   */
  get<T extends TProvider>(userId: string, slug: string, options?: ProviderOptions<TProvider>): Promise<ReturnType<T['wrapTools']>>;
  /**
   * @internal
   * Creates a global execute tool function.
   * This function is used by providers to execute tools.
   * It skips the version check for provider controlled execution.
   * @returns {GlobalExecuteToolFn} The global execute tool function
   */
  private createExecuteFnForProviders;
  /**
   * @internal
   * Utility to wrap a given set of tools in the format expected by the provider
   *
   * @param userId - The user id to get the tools for
   * @param tools - The tools to wrap
   * @param modifiers - The modifiers to be applied to the tools
   * @returns The wrapped tools
   */
  wrapToolsForProvider<T extends TProvider>(userId: string, tools: Tool[], modifiers?: ExecuteToolModifiers): ReturnType<T['wrapTools']>;
  /**
   * @internal
   * Utility to wrap a given set of tools in the format expected by the tool router
   *
   * @param {string} sessionId - The session id to execute the tool for
   * @param {Tool[]} tools - The tools to wrap
   * @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
   * @returns {Tool[]} The wrapped tools
   */
  wrapToolsForToolRouter(sessionId: string, tools: Tool[], modifiers?: SessionExecuteMetaModifiers): Tool[];
  /**
   * @internal
   * @description
   * Creates a function that executes a tool.
   * This function is used by agentic providers to execute the tool
   *
   * @param {string} userId - The user id
   * @param {ExecuteToolModifiers} modifiers - The modifiers to be applied to the tool
   * @returns {ExecuteToolFn} The execute tool function
   */
  private createExecuteToolFn;
  /**
   * @internal
   * Creates a function that executes a tool for a tool router session
   *
   * @param {string} sessionId - The session id to execute the tool for
   * @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
   * @returns {ExecuteToolFn} The execute tool function
   */
  private createExecuteToolFnForToolRouter;
  /**
   * @internal
   * Executes a composio tool via API without modifiers
   * @param tool - The tool to execute
   * @param body - The body of the tool execution
   * @returns The response from the tool execution
   */
  private executeComposioTool;
  /**
   * Executes a given tool with the provided parameters.
   *
   * This method calls the Composio API or a custom tool handler to execute the tool and returns the response.
   * It automatically determines whether to use a custom tool or a Composio API tool based on the slug.
   *
   * **Version Control:**
   * By default, manual tool execution requires a specific toolkit version. If the version resolves to "latest",
   * the execution will throw a `ComposioToolVersionRequiredError` unless `dangerouslySkipVersionCheck` is set to `true`.
   * This helps prevent unexpected behavior when new toolkit versions are released.
   *
   * @param {string} slug - The slug/ID of the tool to be executed
   * @param {ToolExecuteParams} body - The parameters to be passed to the tool
   * @param {string} [body.version] - The specific version of the tool to execute (e.g., "20250909_00")
   * @param {boolean} [body.dangerouslySkipVersionCheck] - Skip version validation for "latest" version (use with caution)
   * @param {string} [body.userId] - The user ID to execute the tool for
   * @param {string} [body.connectedAccountId] - The connected account ID to use for authenticated tools
   * @param {Record<string, unknown>} [body.arguments] - The arguments to pass to the tool
   * @param {ExecuteToolModifiers} [modifiers] - Optional modifiers to transform the request or response
   * @returns {Promise<ToolExecuteResponse>} - The response from the tool execution
   *
   * @throws {ComposioCustomToolsNotInitializedError} If the CustomTools instance is not initialized
   * @throws {ComposioConnectedAccountNotFoundError} If the connected account is not found
   * @throws {ComposioToolNotFoundError} If the tool with the given slug is not found
   * @throws {ComposioToolVersionRequiredError} If version resolves to "latest" and dangerouslySkipVersionCheck is not true
   * @throws {ComposioToolExecutionError} If there is an error during tool execution
   *
   * @example Execute with a specific version (recommended for production)
   * ```typescript
   * const result = await composio.tools.execute('GITHUB_GET_REPOS', {
   *   userId: 'default',
   *   version: '20250909_00',
   *   arguments: { owner: 'composio' }
   * });
   * ```
   *
   * @example Execute with dangerouslySkipVersionCheck (not recommended for production)
   * ```typescript
   * const result = await composio.tools.execute('HACKERNEWS_GET_USER', {
   *   userId: 'default',
   *   arguments: { userId: 'pg' },
   *   dangerouslySkipVersionCheck: true // Allows execution with "latest" version
   * });
   * ```
   *
   * @example Execute with SDK-level toolkit versions configuration
   * ```typescript
   * // If toolkitVersions are set during Composio initialization, no need to pass version
   * const composio = new Composio({ toolkitVersions: { github: '20250909_00' } });
   * const result = await composio.tools.execute('GITHUB_GET_REPOS', {
   *   userId: 'default',
   *   arguments: { owner: 'composio' }
   * });
   * ```
   *
   * @example Execute with modifiers
   * ```typescript
   * const result = await composio.tools.execute('GITHUB_GET_ISSUES', {
   *   userId: 'default',
   *   version: '20250909_00',
   *   arguments: { owner: 'composio', repo: 'sdk' }
   * }, {
   *   beforeExecute: ({ toolSlug, toolkitSlug, params }) => {
   *     console.log(`Executing ${toolSlug} from ${toolkitSlug}`);
   *     return params;
   *   },
   *   afterExecute: ({ toolSlug, toolkitSlug, result }) => {
   *     console.log(`Completed ${toolSlug}`);
   *     return result;
   *   }
   * });
   * ```
   */
  execute(slug: string, body: ToolExecuteParams, modifiers?: ExecuteToolModifiers): Promise<ToolExecuteResponse$1>;
  /**
   * Executes a composio meta tool based on tool router session
   *
   * @param {string} toolSlug - The slug of the tool to execute
   * @param {ToolExecuteMetaParams} body - The execution parameters
   * @param {string} body.sessionId - The session id to execute the tool for
   * @param {Record<string, unknown>} body.arguments - The input to pass to the tool
   * @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
   * @returns {Promise<ToolExecuteResponse>} The response from the tool execution
   */
  executeMetaTool(toolSlug: string, body: ToolExecuteMetaParams, modifiers?: SessionExecuteMetaModifiers): Promise<ToolExecuteResponse$1>;
  /**
   * Fetches the list of all available tools in the Composio SDK.
   *
   * This method is mostly used by the CLI to get the list of tools.
   * No filtering is done on the tools, the list is cached in the backend, no further optimization is required.
   * @returns {Promise<ToolRetrieveEnumResponse>} The complete list of all available tools with their metadata
   *
   * @example
   * ```typescript
   * // Get all available tools as an enum
   * const toolsEnum = await composio.tools.getToolsEnum();
   * console.log(toolsEnum.items);
   * ```
   */
  getToolsEnum(): Promise<ToolRetrieveEnumResponse>;
  /**
   * Fetches the input parameters for a given tool.
   *
   * This method is used to get the input parameters for a tool before executing it.
   *
   * @param {string} slug - The ID of the tool to find input for
   * @param {ToolGetInputParams} body - The parameters to be passed to the tool
   * @returns {Promise<ToolGetInputResponse>} The input parameters schema for the specified tool
   *
   * @example
   * ```typescript
   * // Get input parameters for a specific tool
   * const inputParams = await composio.tools.getInput('GITHUB_CREATE_ISSUE', {
   *   userId: 'default'
   * });
   * console.log(inputParams.schema);
   * ```
   */
  getInput(slug: string, body: ToolGetInputParams): Promise<ToolGetInputResponse>;
  /**
   * Proxies a custom request to a toolkit/integration.
   *
   * This method allows sending custom requests to a specific toolkit or integration
   * when you need more flexibility than the standard tool execution methods provide.
   *
   * @param {ToolProxyParams} body - The parameters for the proxy request including toolkit slug and custom data
   * @returns {Promise<ToolProxyResponse>} The response from the proxied request
   *
   * @example
   * ```typescript
   * // Send a custom request to a toolkit
   * const response = await composio.tools.proxyExecute({
   *   toolkitSlug: 'github',
   *   userId: 'default',
   *   data: {
   *     endpoint: '/repos/owner/repo/issues',
   *     method: 'GET'
   *   }
   * });
   * console.log(response.data);
   * ```
   */
  proxyExecute(body: ToolProxyParams): Promise<ToolProxyResponse>;
  /**
   * Creates a custom tool that can be used within the Composio SDK.
   *
   * Custom tools allow you to extend the functionality of Composio with your own implementations
   * while keeping a consistent interface for both built-in and custom tools.
   *
   * @param {CustomToolOptions} body - The configuration for the custom tool
   * @returns {Promise<Tool>} The created custom tool
   *
   * @example
   * ```typescript
   * // creating a custom tool with a toolkit
   * await composio.tools.createCustomTool({
   *   name: 'My Custom Tool',
   *   description: 'A custom tool that does something specific',
   *   slug: 'MY_CUSTOM_TOOL',
   *   userId: 'default',
   *   connectedAccountId: '123',
   *   toolkitSlug: 'github',
   *   inputParameters: z.object({
   *     param1: z.string().describe('First parameter'),
   *   }),
   *   execute: async (input, connectionConfig, executeToolRequest) => {
   *     // Custom logic here
   *     return { data: { result: 'Success!' } };
   *   }
   * });
   * ```
   *
   * @example
   * ```typescript
   * // creating a custom tool without a toolkit
   * await composio.tools.createCustomTool({
   *   name: 'My Custom Tool',
   *   description: 'A custom tool that does something specific',
   *   slug: 'MY_CUSTOM_TOOL',
   *   inputParameters: z.object({
   *     param1: z.string().describe('First parameter'),
   *   }),
   *   execute: async (input) => {
   *     // Custom logic here
   *     return { data: { result: 'Success!' } };
   *   }
   * });
   */
  createCustomTool<T extends CustomToolInputParameter>(body: CustomToolOptions<T>): Promise<Tool>;
}
//#endregion
//#region src/types/toolkit.types.d.ts
/**
 * Toolkit list params
 */
declare const ToolkitMangedByEnumSchema: z$1.ZodEnum<["all", "composio", "project"]>;
declare const ToolkitSortByEnumSchema: z$1.ZodEnum<["usage", "alphabetically"]>;
declare const ToolkitsListParamsSchema: z$1.ZodObject<{
  category: z$1.ZodOptional<z$1.ZodString>;
  managedBy: z$1.ZodOptional<z$1.ZodEnum<["all", "composio", "project"]>>;
  sortBy: z$1.ZodOptional<z$1.ZodEnum<["usage", "alphabetically"]>>;
  cursor: z$1.ZodOptional<z$1.ZodString>;
  limit: z$1.ZodOptional<z$1.ZodNumber>;
}, "strip", z$1.ZodTypeAny, {
  limit?: number | undefined;
  cursor?: string | undefined;
  category?: string | undefined;
  managedBy?: "all" | "composio" | "project" | undefined;
  sortBy?: "usage" | "alphabetically" | undefined;
}, {
  limit?: number | undefined;
  cursor?: string | undefined;
  category?: string | undefined;
  managedBy?: "all" | "composio" | "project" | undefined;
  sortBy?: "usage" | "alphabetically" | undefined;
}>;
type ToolkitMangedByEnum = z$1.infer<typeof ToolkitMangedByEnumSchema>;
type ToolkitSortByEnum = z$1.infer<typeof ToolkitSortByEnumSchema>;
type ToolkitListParams = z$1.infer<typeof ToolkitsListParamsSchema>;
/**
 * Toolkits response
 */
declare const ToolKitMetaSchema: z$1.ZodObject<{
  categories: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
    slug: z$1.ZodString;
    name: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    slug: string;
    name: string;
  }, {
    slug: string;
    name: string;
  }>, "many">>;
  appUrl: z$1.ZodOptional<z$1.ZodString>;
  createdAt: z$1.ZodOptional<z$1.ZodString>;
  description: z$1.ZodOptional<z$1.ZodString>;
  logo: z$1.ZodOptional<z$1.ZodString>;
  toolsCount: z$1.ZodOptional<z$1.ZodNumber>;
  triggersCount: z$1.ZodOptional<z$1.ZodNumber>;
  updatedAt: z$1.ZodOptional<z$1.ZodString>;
  availableVersions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
}, "strip", z$1.ZodTypeAny, {
  logo?: string | undefined;
  description?: string | undefined;
  availableVersions?: string[] | undefined;
  createdAt?: string | undefined;
  categories?: {
    slug: string;
    name: string;
  }[] | undefined;
  appUrl?: string | undefined;
  toolsCount?: number | undefined;
  triggersCount?: number | undefined;
  updatedAt?: string | undefined;
}, {
  logo?: string | undefined;
  description?: string | undefined;
  availableVersions?: string[] | undefined;
  createdAt?: string | undefined;
  categories?: {
    slug: string;
    name: string;
  }[] | undefined;
  appUrl?: string | undefined;
  toolsCount?: number | undefined;
  triggersCount?: number | undefined;
  updatedAt?: string | undefined;
}>;
declare const ToolKitItemSchema: z$1.ZodObject<{
  name: z$1.ZodString;
  slug: z$1.ZodString;
  meta: z$1.ZodObject<{
    categories: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
      slug: z$1.ZodString;
      name: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
      slug: string;
      name: string;
    }, {
      slug: string;
      name: string;
    }>, "many">>;
    appUrl: z$1.ZodOptional<z$1.ZodString>;
    createdAt: z$1.ZodOptional<z$1.ZodString>;
    description: z$1.ZodOptional<z$1.ZodString>;
    logo: z$1.ZodOptional<z$1.ZodString>;
    toolsCount: z$1.ZodOptional<z$1.ZodNumber>;
    triggersCount: z$1.ZodOptional<z$1.ZodNumber>;
    updatedAt: z$1.ZodOptional<z$1.ZodString>;
    availableVersions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }>;
  isLocalToolkit: z$1.ZodBoolean;
  authSchemes: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  composioManagedAuthSchemes: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  noAuth: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  authSchemes?: string[] | undefined;
  composioManagedAuthSchemes?: string[] | undefined;
  noAuth?: boolean | undefined;
}, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  authSchemes?: string[] | undefined;
  composioManagedAuthSchemes?: string[] | undefined;
  noAuth?: boolean | undefined;
}>;
declare const ToolKitListResponseSchema: z$1.ZodArray<z$1.ZodObject<{
  name: z$1.ZodString;
  slug: z$1.ZodString;
  meta: z$1.ZodObject<{
    categories: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
      slug: z$1.ZodString;
      name: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
      slug: string;
      name: string;
    }, {
      slug: string;
      name: string;
    }>, "many">>;
    appUrl: z$1.ZodOptional<z$1.ZodString>;
    createdAt: z$1.ZodOptional<z$1.ZodString>;
    description: z$1.ZodOptional<z$1.ZodString>;
    logo: z$1.ZodOptional<z$1.ZodString>;
    toolsCount: z$1.ZodOptional<z$1.ZodNumber>;
    triggersCount: z$1.ZodOptional<z$1.ZodNumber>;
    updatedAt: z$1.ZodOptional<z$1.ZodString>;
    availableVersions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }>;
  isLocalToolkit: z$1.ZodBoolean;
  authSchemes: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  composioManagedAuthSchemes: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  noAuth: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  authSchemes?: string[] | undefined;
  composioManagedAuthSchemes?: string[] | undefined;
  noAuth?: boolean | undefined;
}, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  authSchemes?: string[] | undefined;
  composioManagedAuthSchemes?: string[] | undefined;
  noAuth?: boolean | undefined;
}>, "many">;
type ToolKitMeta = z$1.infer<typeof ToolKitMetaSchema>;
type ToolKitItem = z$1.infer<typeof ToolKitItemSchema>;
type ToolKitListResponse = z$1.infer<typeof ToolKitListResponseSchema>;
/**
 * Toolkit retrieve response
 */
declare const ToolkitAuthFieldSchema: z$1.ZodObject<{
  description: z$1.ZodString;
  displayName: z$1.ZodString;
  required: z$1.ZodBoolean;
  name: z$1.ZodString;
  type: z$1.ZodString;
  default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
}, "strip", z$1.ZodTypeAny, {
  name: string;
  type: string;
  description: string;
  required: boolean;
  displayName: string;
  default?: string | null | undefined;
}, {
  name: string;
  type: string;
  description: string;
  required: boolean;
  displayName: string;
  default?: string | null | undefined;
}>;
declare const ToolkitAuthConfigDetailsSchema: z$1.ZodObject<{
  name: z$1.ZodString;
  mode: z$1.ZodString;
  fields: z$1.ZodObject<{
    authConfigCreation: z$1.ZodObject<{
      optional: z$1.ZodArray<z$1.ZodObject<{
        description: z$1.ZodString;
        displayName: z$1.ZodString;
        required: z$1.ZodBoolean;
        name: z$1.ZodString;
        type: z$1.ZodString;
        default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
      }, "strip", z$1.ZodTypeAny, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }>, "many">;
      required: z$1.ZodArray<z$1.ZodObject<{
        description: z$1.ZodString;
        displayName: z$1.ZodString;
        required: z$1.ZodBoolean;
        name: z$1.ZodString;
        type: z$1.ZodString;
        default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
      }, "strip", z$1.ZodTypeAny, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }>, "many">;
    }, "strip", z$1.ZodTypeAny, {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    }, {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    }>;
    connectedAccountInitiation: z$1.ZodObject<{
      optional: z$1.ZodArray<z$1.ZodObject<{
        description: z$1.ZodString;
        displayName: z$1.ZodString;
        required: z$1.ZodBoolean;
        name: z$1.ZodString;
        type: z$1.ZodString;
        default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
      }, "strip", z$1.ZodTypeAny, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }>, "many">;
      required: z$1.ZodArray<z$1.ZodObject<{
        description: z$1.ZodString;
        displayName: z$1.ZodString;
        required: z$1.ZodBoolean;
        name: z$1.ZodString;
        type: z$1.ZodString;
        default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
      }, "strip", z$1.ZodTypeAny, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }, {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }>, "many">;
    }, "strip", z$1.ZodTypeAny, {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    }, {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    }>;
  }, "strip", z$1.ZodTypeAny, {
    authConfigCreation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
    connectedAccountInitiation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
  }, {
    authConfigCreation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
    connectedAccountInitiation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
  }>;
  proxy: z$1.ZodOptional<z$1.ZodObject<{
    baseUrl: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    baseUrl?: string | undefined;
  }, {
    baseUrl?: string | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  name: string;
  mode: string;
  fields: {
    authConfigCreation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
    connectedAccountInitiation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
  };
  proxy?: {
    baseUrl?: string | undefined;
  } | undefined;
}, {
  name: string;
  mode: string;
  fields: {
    authConfigCreation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
    connectedAccountInitiation: {
      required: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
      optional: {
        name: string;
        type: string;
        description: string;
        required: boolean;
        displayName: string;
        default?: string | null | undefined;
      }[];
    };
  };
  proxy?: {
    baseUrl?: string | undefined;
  } | undefined;
}>;
declare const ToolkitRetrieveResponseSchema: z$1.ZodObject<{
  name: z$1.ZodString;
  slug: z$1.ZodString;
  meta: z$1.ZodObject<{
    categories: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
      slug: z$1.ZodString;
      name: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
      slug: string;
      name: string;
    }, {
      slug: string;
      name: string;
    }>, "many">>;
    appUrl: z$1.ZodOptional<z$1.ZodString>;
    createdAt: z$1.ZodOptional<z$1.ZodString>;
    description: z$1.ZodOptional<z$1.ZodString>;
    logo: z$1.ZodOptional<z$1.ZodString>;
    toolsCount: z$1.ZodOptional<z$1.ZodNumber>;
    triggersCount: z$1.ZodOptional<z$1.ZodNumber>;
    updatedAt: z$1.ZodOptional<z$1.ZodString>;
    availableVersions: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }, {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  }>;
  isLocalToolkit: z$1.ZodBoolean;
  composioManagedAuthSchemes: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  authConfigDetails: z$1.ZodOptional<z$1.ZodArray<z$1.ZodObject<{
    name: z$1.ZodString;
    mode: z$1.ZodString;
    fields: z$1.ZodObject<{
      authConfigCreation: z$1.ZodObject<{
        optional: z$1.ZodArray<z$1.ZodObject<{
          description: z$1.ZodString;
          displayName: z$1.ZodString;
          required: z$1.ZodBoolean;
          name: z$1.ZodString;
          type: z$1.ZodString;
          default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
        }, "strip", z$1.ZodTypeAny, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }>, "many">;
        required: z$1.ZodArray<z$1.ZodObject<{
          description: z$1.ZodString;
          displayName: z$1.ZodString;
          required: z$1.ZodBoolean;
          name: z$1.ZodString;
          type: z$1.ZodString;
          default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
        }, "strip", z$1.ZodTypeAny, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }>, "many">;
      }, "strip", z$1.ZodTypeAny, {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      }, {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      }>;
      connectedAccountInitiation: z$1.ZodObject<{
        optional: z$1.ZodArray<z$1.ZodObject<{
          description: z$1.ZodString;
          displayName: z$1.ZodString;
          required: z$1.ZodBoolean;
          name: z$1.ZodString;
          type: z$1.ZodString;
          default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
        }, "strip", z$1.ZodTypeAny, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }>, "many">;
        required: z$1.ZodArray<z$1.ZodObject<{
          description: z$1.ZodString;
          displayName: z$1.ZodString;
          required: z$1.ZodBoolean;
          name: z$1.ZodString;
          type: z$1.ZodString;
          default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
        }, "strip", z$1.ZodTypeAny, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }, {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }>, "many">;
      }, "strip", z$1.ZodTypeAny, {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      }, {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      }>;
    }, "strip", z$1.ZodTypeAny, {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    }, {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    }>;
    proxy: z$1.ZodOptional<z$1.ZodObject<{
      baseUrl: z$1.ZodOptional<z$1.ZodString>;
    }, "strip", z$1.ZodTypeAny, {
      baseUrl?: string | undefined;
    }, {
      baseUrl?: string | undefined;
    }>>;
  }, "strip", z$1.ZodTypeAny, {
    name: string;
    mode: string;
    fields: {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    };
    proxy?: {
      baseUrl?: string | undefined;
    } | undefined;
  }, {
    name: string;
    mode: string;
    fields: {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    };
    proxy?: {
      baseUrl?: string | undefined;
    } | undefined;
  }>, "many">>;
  baseUrl: z$1.ZodOptional<z$1.ZodString>;
  getCurrentUserEndpoint: z$1.ZodOptional<z$1.ZodString>;
  getCurrentUserEndpointMethod: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  composioManagedAuthSchemes?: string[] | undefined;
  baseUrl?: string | undefined;
  authConfigDetails?: {
    name: string;
    mode: string;
    fields: {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    };
    proxy?: {
      baseUrl?: string | undefined;
    } | undefined;
  }[] | undefined;
  getCurrentUserEndpoint?: string | undefined;
  getCurrentUserEndpointMethod?: string | undefined;
}, {
  slug: string;
  name: string;
  meta: {
    logo?: string | undefined;
    description?: string | undefined;
    availableVersions?: string[] | undefined;
    createdAt?: string | undefined;
    categories?: {
      slug: string;
      name: string;
    }[] | undefined;
    appUrl?: string | undefined;
    toolsCount?: number | undefined;
    triggersCount?: number | undefined;
    updatedAt?: string | undefined;
  };
  isLocalToolkit: boolean;
  composioManagedAuthSchemes?: string[] | undefined;
  baseUrl?: string | undefined;
  authConfigDetails?: {
    name: string;
    mode: string;
    fields: {
      authConfigCreation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
      connectedAccountInitiation: {
        required: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
        optional: {
          name: string;
          type: string;
          description: string;
          required: boolean;
          displayName: string;
          default?: string | null | undefined;
        }[];
      };
    };
    proxy?: {
      baseUrl?: string | undefined;
    } | undefined;
  }[] | undefined;
  getCurrentUserEndpoint?: string | undefined;
  getCurrentUserEndpointMethod?: string | undefined;
}>;
type ToolkitAuthField = z$1.infer<typeof ToolkitAuthFieldSchema>;
type ToolkitAuthConfigDetails = z$1.infer<typeof ToolkitAuthConfigDetailsSchema>;
type ToolkitRetrieveResponse = z$1.infer<typeof ToolkitRetrieveResponseSchema>;
/**
 * Toolkit categories response
 */
declare const ToolkitCategorySchema: z$1.ZodObject<{
  id: z$1.ZodString;
  name: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  name: string;
  id: string;
}, {
  name: string;
  id: string;
}>;
declare const ToolkitRetrieveCategoriesResponseSchema: z$1.ZodObject<{
  items: z$1.ZodArray<z$1.ZodObject<{
    id: z$1.ZodString;
    name: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    name: string;
    id: string;
  }, {
    name: string;
    id: string;
  }>, "many">;
  nextCursor: z$1.ZodNullable<z$1.ZodString>;
  totalPages: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
  items: {
    name: string;
    id: string;
  }[];
  nextCursor: string | null;
  totalPages: number;
}, {
  items: {
    name: string;
    id: string;
  }[];
  nextCursor: string | null;
  totalPages: number;
}>;
type ToolkitCategory = z$1.infer<typeof ToolkitCategorySchema>;
type ToolkitRetrieveCategoriesResponse = z$1.infer<typeof ToolkitRetrieveCategoriesResponseSchema>;
declare const ToolkitAuthFieldsResponseSchema: z$1.ZodArray<z$1.ZodObject<{
  description: z$1.ZodString;
  displayName: z$1.ZodString;
  name: z$1.ZodString;
  type: z$1.ZodString;
  default: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
} & {
  required: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  name: string;
  type: string;
  description: string;
  displayName: string;
  required?: boolean | undefined;
  default?: string | null | undefined;
}, {
  name: string;
  type: string;
  description: string;
  displayName: string;
  required?: boolean | undefined;
  default?: string | null | undefined;
}>, "many">;
type ToolkitAuthFieldsResponse = z$1.infer<typeof ToolkitAuthFieldsResponseSchema>;
//#endregion
//#region src/types/connectedAccounts.types.d.ts
/**
 * Connected Account create parameters
 */
declare const ConnectedAccountStatuses: {
  readonly INITIALIZING: "INITIALIZING";
  readonly INITIATED: "INITIATED";
  readonly ACTIVE: "ACTIVE";
  readonly FAILED: "FAILED";
  readonly EXPIRED: "EXPIRED";
  readonly INACTIVE: "INACTIVE";
};
declare const ConnectedAccountStatusSchema: z$1.ZodEnum<["INITIALIZING", "INITIATED", "ACTIVE", "FAILED", "EXPIRED", "INACTIVE"]>;
type ConnectedAccountStatus = (typeof ConnectedAccountStatuses)[keyof typeof ConnectedAccountStatuses];
type ConnectedAccountStatusEnum = z$1.infer<typeof ConnectedAccountStatusSchema>;
declare const CreateConnectedAccountParamsSchema: z$1.ZodObject<{
  authConfig: z$1.ZodObject<{
    id: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    id: string;
  }, {
    id: string;
  }>;
  connection: z$1.ZodObject<{
    data: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
    callbackUrl: z$1.ZodOptional<z$1.ZodString>;
    userId: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    userId?: string | undefined;
    data?: Record<string, unknown> | undefined;
    callbackUrl?: string | undefined;
  }, {
    userId?: string | undefined;
    data?: Record<string, unknown> | undefined;
    callbackUrl?: string | undefined;
  }>;
}, "strip", z$1.ZodTypeAny, {
  authConfig: {
    id: string;
  };
  connection: {
    userId?: string | undefined;
    data?: Record<string, unknown> | undefined;
    callbackUrl?: string | undefined;
  };
}, {
  authConfig: {
    id: string;
  };
  connection: {
    userId?: string | undefined;
    data?: Record<string, unknown> | undefined;
    callbackUrl?: string | undefined;
  };
}>;
declare const DefaultCreateConnectedAccountParamsSchema: z$1.ZodType<{
  auth_config: {
    id: string;
  };
  connection: {
    state?: z$1.infer<typeof ConnectionDataSchema>;
    data?: Record<string, unknown>;
    callback_url?: string;
    user_id?: string;
  };
}>;
declare const CreateConnectedAccountOptionsSchema: z$1.ZodType<{
  allowMultiple?: boolean;
  callbackUrl?: string;
  config?: z$1.infer<typeof ConnectionDataSchema>;
}>;
type CreateConnectedAccountOptions = z$1.infer<typeof CreateConnectedAccountOptionsSchema>;
type CreateConnectedAccountParams = z$1.infer<typeof CreateConnectedAccountParamsSchema>;
/**
 * Connected Account create response
 */
declare const CreateConnectedAccountResponseSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  status: z$1.ZodEnum<["INITIALIZING", "INITIATED", "ACTIVE", "FAILED", "EXPIRED", "INACTIVE"]>;
  redirectUrl: z$1.ZodNullable<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  status: "INITIALIZING" | "INITIATED" | "ACTIVE" | "FAILED" | "EXPIRED" | "INACTIVE";
  redirectUrl: string | null;
  id: string;
}, {
  status: "INITIALIZING" | "INITIATED" | "ACTIVE" | "FAILED" | "EXPIRED" | "INACTIVE";
  redirectUrl: string | null;
  id: string;
}>;
type CreateConnectedAccountResponse = z$1.infer<typeof CreateConnectedAccountResponseSchema>;
declare const ConnectedAccountAuthConfigSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  isComposioManaged: z$1.ZodBoolean;
  isDisabled: z$1.ZodBoolean;
}, "strip", z$1.ZodTypeAny, {
  id: string;
  isComposioManaged: boolean;
  isDisabled: boolean;
}, {
  id: string;
  isComposioManaged: boolean;
  isDisabled: boolean;
}>;
type ConnectedAccountAuthConfig = z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
declare const ConnectedAccountRetrieveResponseSchema: z$1.ZodType<{
  id: string;
  authConfig: z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
  /** @deprecated use connectedAccount.state instead */
  data?: Record<string, unknown>;
  /** @deprecated use connectedAccount.state instead */
  params?: Record<string, unknown>;
  status: ConnectedAccountStatusEnum;
  statusReason: string | null;
  toolkit: {
    slug: string;
  };
  state?: z$1.infer<typeof ConnectionDataSchema>;
  testRequestEndpoint?: string;
  isDisabled: boolean;
  createdAt: string;
  updatedAt: string;
}>;
type ConnectedAccountRetrieveResponse = z$1.infer<typeof ConnectedAccountRetrieveResponseSchema>;
/**
 * Type for list response item that doesn't include params
 */
type ConnectedAccountListResponseItem = Omit<ConnectedAccountRetrieveResponse, 'params'>;
declare const ConnectedAccountListParamsSchema: z$1.ZodObject<{
  authConfigIds: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
  cursor: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
  limit: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodNumber>>;
  orderBy: z$1.ZodOptional<z$1.ZodEnum<["created_at", "updated_at"]>>;
  statuses: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodEnum<["INITIALIZING", "INITIATED", "ACTIVE", "FAILED", "EXPIRED", "INACTIVE"]>, "many">>>;
  toolkitSlugs: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
  userIds: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
}, "strip", z$1.ZodTypeAny, {
  limit?: number | null | undefined;
  authConfigIds?: string[] | null | undefined;
  cursor?: string | null | undefined;
  orderBy?: "created_at" | "updated_at" | undefined;
  statuses?: ("INITIALIZING" | "INITIATED" | "ACTIVE" | "FAILED" | "EXPIRED" | "INACTIVE")[] | null | undefined;
  toolkitSlugs?: string[] | null | undefined;
  userIds?: string[] | null | undefined;
}, {
  limit?: number | null | undefined;
  authConfigIds?: string[] | null | undefined;
  cursor?: string | null | undefined;
  orderBy?: "created_at" | "updated_at" | undefined;
  statuses?: ("INITIALIZING" | "INITIATED" | "ACTIVE" | "FAILED" | "EXPIRED" | "INACTIVE")[] | null | undefined;
  toolkitSlugs?: string[] | null | undefined;
  userIds?: string[] | null | undefined;
}>;
type ConnectedAccountListParams = z$1.infer<typeof ConnectedAccountListParamsSchema>;
declare const ConnectedAccountListResponseSchema: z$1.ZodObject<{
  items: z$1.ZodArray<z$1.ZodType<{
    id: string;
    authConfig: z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
    /** @deprecated use connectedAccount.state instead */
    data?: Record<string, unknown>;
    /** @deprecated use connectedAccount.state instead */
    params?: Record<string, unknown>;
    status: ConnectedAccountStatusEnum;
    statusReason: string | null;
    toolkit: {
      slug: string;
    };
    state?: z$1.infer<typeof ConnectionDataSchema>;
    testRequestEndpoint?: string;
    isDisabled: boolean;
    createdAt: string;
    updatedAt: string;
  }, z$1.ZodTypeDef, {
    id: string;
    authConfig: z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
    /** @deprecated use connectedAccount.state instead */
    data?: Record<string, unknown>;
    /** @deprecated use connectedAccount.state instead */
    params?: Record<string, unknown>;
    status: ConnectedAccountStatusEnum;
    statusReason: string | null;
    toolkit: {
      slug: string;
    };
    state?: z$1.infer<typeof ConnectionDataSchema>;
    testRequestEndpoint?: string;
    isDisabled: boolean;
    createdAt: string;
    updatedAt: string;
  }>, "many">;
  nextCursor: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
  totalPages: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
  items: {
    id: string;
    authConfig: z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
    /** @deprecated use connectedAccount.state instead */
    data?: Record<string, unknown>;
    /** @deprecated use connectedAccount.state instead */
    params?: Record<string, unknown>;
    status: ConnectedAccountStatusEnum;
    statusReason: string | null;
    toolkit: {
      slug: string;
    };
    state?: z$1.infer<typeof ConnectionDataSchema>;
    testRequestEndpoint?: string;
    isDisabled: boolean;
    createdAt: string;
    updatedAt: string;
  }[];
  totalPages: number;
  nextCursor?: string | null | undefined;
}, {
  items: {
    id: string;
    authConfig: z$1.infer<typeof ConnectedAccountAuthConfigSchema>;
    /** @deprecated use connectedAccount.state instead */
    data?: Record<string, unknown>;
    /** @deprecated use connectedAccount.state instead */
    params?: Record<string, unknown>;
    status: ConnectedAccountStatusEnum;
    statusReason: string | null;
    toolkit: {
      slug: string;
    };
    state?: z$1.infer<typeof ConnectionDataSchema>;
    testRequestEndpoint?: string;
    isDisabled: boolean;
    createdAt: string;
    updatedAt: string;
  }[];
  totalPages: number;
  nextCursor?: string | null | undefined;
}>;
type ConnectedAccountListResponse = z$1.infer<typeof ConnectedAccountListResponseSchema>;
declare const CreateConnectedAccountLinkOptionsSchema: z$1.ZodObject<{
  /**
   * The url to redirect the user to post connecting their account.
   *
   * For sucessfull connections, you will get a query param called status=success
   * And for failed connections you will get a query param called satus=failed
   *
   * @example https://your-app.com/callback
   *
   */
  callbackUrl: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  callbackUrl?: string | undefined;
}, {
  callbackUrl?: string | undefined;
}>;
type CreateConnectedAccountLinkOptions = z$1.infer<typeof CreateConnectedAccountLinkOptionsSchema>;
declare const CreateConnectedAccountLinkResponseSchema: z$1.ZodObject<{
  redirectUrl: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  redirectUrl: string;
}, {
  redirectUrl: string;
}>;
type CreateConnectedAccountLinkResponse = z$1.infer<typeof CreateConnectedAccountLinkResponseSchema>;
declare const ConnectedAccountRefreshOptionsSchema: z$1.ZodObject<{
  redirectUrl: z$1.ZodOptional<z$1.ZodString>;
  validateCredentials: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  redirectUrl?: string | undefined;
  validateCredentials?: boolean | undefined;
}, {
  redirectUrl?: string | undefined;
  validateCredentials?: boolean | undefined;
}>;
type ConnectedAccountRefreshOptions = z$1.infer<typeof ConnectedAccountRefreshOptionsSchema>;
//#endregion
//#region src/types/connectionRequest.types.d.ts
interface ConnectionRequestState {
  id: string;
  status?: ConnectedAccountStatus;
  redirectUrl?: string | null;
}
interface ConnectionRequest extends ConnectionRequestState {
  waitForConnection: (timeout?: number) => Promise<ConnectedAccountRetrieveResponse>;
  toJSON: () => ConnectionRequestState;
  toString: () => string;
}
//#endregion
//#region src/types/authConfigs.types.d.ts
declare const AuthConfigTypes: {
  readonly CUSTOM: "use_custom_auth";
  readonly COMPOSIO_MANAGED: "use_composio_managed_auth";
};
type AuthConfigType = (typeof AuthConfigTypes)[keyof typeof AuthConfigTypes];
declare const AuthSchemeTypes: {
  readonly OAUTH1: "OAUTH1";
  readonly OAUTH2: "OAUTH2";
  readonly API_KEY: "API_KEY";
  readonly BASIC: "BASIC";
  readonly BEARER_TOKEN: "BEARER_TOKEN";
  readonly BILLCOM_AUTH: "BILLCOM_AUTH";
  readonly GOOGLE_SERVICE_ACCOUNT: "GOOGLE_SERVICE_ACCOUNT";
  readonly NO_AUTH: "NO_AUTH";
  readonly BASIC_WITH_JWT: "BASIC_WITH_JWT";
  readonly CALCOM_AUTH: "CALCOM_AUTH";
  readonly SERVICE_ACCOUNT: "SERVICE_ACCOUNT";
  readonly SAML: "SAML";
  readonly DCR_OAUTH: "DCR_OAUTH";
};
type AuthSchemeType = (typeof AuthSchemeTypes)[keyof typeof AuthSchemeTypes];
declare const AuthConfigCreationToolAccessConfigSchema: z$1.ZodObject<{
  toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
}, "strip", z$1.ZodTypeAny, {
  toolsForConnectedAccountCreation?: string[] | undefined;
}, {
  toolsForConnectedAccountCreation?: string[] | undefined;
}>;
declare const AuthConfigToolAccessConfigSchema: z$1.ZodObject<{
  toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
}, "strip", z$1.ZodTypeAny, {
  toolsForConnectedAccountCreation?: string[] | undefined;
  toolsAvailableForExecution?: string[] | undefined;
}, {
  toolsForConnectedAccountCreation?: string[] | undefined;
  toolsAvailableForExecution?: string[] | undefined;
}>;
declare const AuthSchemeEnum: z$1.ZodEnum<["OAUTH2", "OAUTH1", "API_KEY", "BASIC", "BILLCOM_AUTH", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "CALCOM_AUTH", "SERVICE_ACCOUNT", "SAML", "DCR_OAUTH"]>;
declare const CreateCustomAuthConfigParamsSchema: z$1.ZodObject<{
  type: z$1.ZodLiteral<"use_custom_auth">;
  name: z$1.ZodOptional<z$1.ZodString>;
  credentials: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnion<[z$1.ZodString, z$1.ZodNumber, z$1.ZodBoolean]>>;
  authScheme: z$1.ZodEnum<["OAUTH2", "OAUTH1", "API_KEY", "BASIC", "BILLCOM_AUTH", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "CALCOM_AUTH", "SERVICE_ACCOUNT", "SAML", "DCR_OAUTH"]>;
  proxyConfig: z$1.ZodOptional<z$1.ZodObject<{
    proxyUrl: z$1.ZodString;
    proxyAuthKey: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  }, {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  }>>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  type: "use_custom_auth";
  authScheme: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH";
  credentials: Record<string, string | number | boolean>;
  name?: string | undefined;
  proxyConfig?: {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  } | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}, {
  type: "use_custom_auth";
  authScheme: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH";
  credentials: Record<string, string | number | boolean>;
  name?: string | undefined;
  proxyConfig?: {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  } | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}>;
declare const CreateComposioManagedAuthConfigParamsSchema: z$1.ZodObject<{
  type: z$1.ZodLiteral<"use_composio_managed_auth">;
  name: z$1.ZodOptional<z$1.ZodString>;
  credentials: z$1.ZodOptional<z$1.ZodObject<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">>>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  type: "use_composio_managed_auth";
  name?: string | undefined;
  credentials?: z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}, {
  type: "use_composio_managed_auth";
  name?: string | undefined;
  credentials?: z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}>;
/**
 * Discriminated union of all possible auth config types.
 */
declare const CreateAuthConfigParamsSchema: z$1.ZodDiscriminatedUnion<"type", [z$1.ZodObject<{
  type: z$1.ZodLiteral<"use_custom_auth">;
  name: z$1.ZodOptional<z$1.ZodString>;
  credentials: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnion<[z$1.ZodString, z$1.ZodNumber, z$1.ZodBoolean]>>;
  authScheme: z$1.ZodEnum<["OAUTH2", "OAUTH1", "API_KEY", "BASIC", "BILLCOM_AUTH", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "CALCOM_AUTH", "SERVICE_ACCOUNT", "SAML", "DCR_OAUTH"]>;
  proxyConfig: z$1.ZodOptional<z$1.ZodObject<{
    proxyUrl: z$1.ZodString;
    proxyAuthKey: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  }, {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  }>>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  type: "use_custom_auth";
  authScheme: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH";
  credentials: Record<string, string | number | boolean>;
  name?: string | undefined;
  proxyConfig?: {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  } | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}, {
  type: "use_custom_auth";
  authScheme: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH";
  credentials: Record<string, string | number | boolean>;
  name?: string | undefined;
  proxyConfig?: {
    proxyUrl: string;
    proxyAuthKey?: string | undefined;
  } | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}>, z$1.ZodObject<{
  type: z$1.ZodLiteral<"use_composio_managed_auth">;
  name: z$1.ZodOptional<z$1.ZodString>;
  credentials: z$1.ZodOptional<z$1.ZodObject<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">>>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
  }>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
  type: "use_composio_managed_auth";
  name?: string | undefined;
  credentials?: z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}, {
  type: "use_composio_managed_auth";
  name?: string | undefined;
  credentials?: z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
}>]>;
type CreateAuthConfigParams = z$1.infer<typeof CreateAuthConfigParamsSchema>;
declare const CreateAuthConfigResponseSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  authScheme: z$1.ZodString;
  isComposioManaged: z$1.ZodBoolean;
  toolkit: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  toolkit: string;
  authScheme: string;
  id: string;
  isComposioManaged: boolean;
}, {
  toolkit: string;
  authScheme: string;
  id: string;
  isComposioManaged: boolean;
}>;
type CreateAuthConfigResponse = z$1.infer<typeof CreateAuthConfigResponseSchema>;
declare const AuthConfigRetrieveResponseSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  name: z$1.ZodString;
  toolkit: z$1.ZodObject<{
    logo: z$1.ZodString;
    slug: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    slug: string;
    logo: string;
  }, {
    slug: string;
    logo: string;
  }>;
  noOfConnections: z$1.ZodNumber;
  status: z$1.ZodEnum<["ENABLED", "DISABLED"]>;
  uuid: z$1.ZodString;
  authScheme: z$1.ZodOptional<z$1.ZodEnum<["OAUTH2", "OAUTH1", "API_KEY", "BASIC", "BILLCOM_AUTH", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "CALCOM_AUTH", "SERVICE_ACCOUNT", "SAML", "DCR_OAUTH"]>>;
  credentials: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
  expectedInputFields: z$1.ZodOptional<z$1.ZodArray<z$1.ZodUnknown, "many">>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  isComposioManaged: z$1.ZodOptional<z$1.ZodBoolean>;
  createdBy: z$1.ZodOptional<z$1.ZodString>;
  createdAt: z$1.ZodOptional<z$1.ZodString>;
  lastUpdatedAt: z$1.ZodOptional<z$1.ZodString>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  name: string;
  status: "ENABLED" | "DISABLED";
  toolkit: {
    slug: string;
    logo: string;
  };
  id: string;
  noOfConnections: number;
  uuid: string;
  authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
  credentials?: Record<string, unknown> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  isComposioManaged?: boolean | undefined;
  expectedInputFields?: unknown[] | undefined;
  restrictToFollowingTools?: string[] | undefined;
  createdBy?: string | undefined;
  createdAt?: string | undefined;
  lastUpdatedAt?: string | undefined;
}, {
  name: string;
  status: "ENABLED" | "DISABLED";
  toolkit: {
    slug: string;
    logo: string;
  };
  id: string;
  noOfConnections: number;
  uuid: string;
  authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
  credentials?: Record<string, unknown> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  isComposioManaged?: boolean | undefined;
  expectedInputFields?: unknown[] | undefined;
  restrictToFollowingTools?: string[] | undefined;
  createdBy?: string | undefined;
  createdAt?: string | undefined;
  lastUpdatedAt?: string | undefined;
}>;
type AuthConfigRetrieveResponse = z$1.infer<typeof AuthConfigRetrieveResponseSchema>;
declare const AuthConfigListParamsSchema: z$1.ZodObject<{
  cursor: z$1.ZodOptional<z$1.ZodString>;
  isComposioManaged: z$1.ZodOptional<z$1.ZodBoolean>;
  limit: z$1.ZodOptional<z$1.ZodNumber>;
  toolkit: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  toolkit?: string | undefined;
  limit?: number | undefined;
  isComposioManaged?: boolean | undefined;
  cursor?: string | undefined;
}, {
  toolkit?: string | undefined;
  limit?: number | undefined;
  isComposioManaged?: boolean | undefined;
  cursor?: string | undefined;
}>;
type AuthConfigListParams = z$1.infer<typeof AuthConfigListParamsSchema>;
declare const AuthConfigListResponseSchema: z$1.ZodObject<{
  items: z$1.ZodArray<z$1.ZodObject<{
    id: z$1.ZodString;
    name: z$1.ZodString;
    toolkit: z$1.ZodObject<{
      logo: z$1.ZodString;
      slug: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
      slug: string;
      logo: string;
    }, {
      slug: string;
      logo: string;
    }>;
    noOfConnections: z$1.ZodNumber;
    status: z$1.ZodEnum<["ENABLED", "DISABLED"]>;
    uuid: z$1.ZodString;
    authScheme: z$1.ZodOptional<z$1.ZodEnum<["OAUTH2", "OAUTH1", "API_KEY", "BASIC", "BILLCOM_AUTH", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "CALCOM_AUTH", "SERVICE_ACCOUNT", "SAML", "DCR_OAUTH"]>>;
    credentials: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
    expectedInputFields: z$1.ZodOptional<z$1.ZodArray<z$1.ZodUnknown, "many">>;
    isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
    /**
     * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
     */
    restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    isComposioManaged: z$1.ZodOptional<z$1.ZodBoolean>;
    createdBy: z$1.ZodOptional<z$1.ZodString>;
    createdAt: z$1.ZodOptional<z$1.ZodString>;
    lastUpdatedAt: z$1.ZodOptional<z$1.ZodString>;
    toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
      toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
      toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    }, "strip", z$1.ZodTypeAny, {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    }, {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    }>>;
  }, "strip", z$1.ZodTypeAny, {
    name: string;
    status: "ENABLED" | "DISABLED";
    toolkit: {
      slug: string;
      logo: string;
    };
    id: string;
    noOfConnections: number;
    uuid: string;
    authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
    credentials?: Record<string, unknown> | undefined;
    toolAccessConfig?: {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    } | undefined;
    isEnabledForToolRouter?: boolean | undefined;
    isComposioManaged?: boolean | undefined;
    expectedInputFields?: unknown[] | undefined;
    restrictToFollowingTools?: string[] | undefined;
    createdBy?: string | undefined;
    createdAt?: string | undefined;
    lastUpdatedAt?: string | undefined;
  }, {
    name: string;
    status: "ENABLED" | "DISABLED";
    toolkit: {
      slug: string;
      logo: string;
    };
    id: string;
    noOfConnections: number;
    uuid: string;
    authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
    credentials?: Record<string, unknown> | undefined;
    toolAccessConfig?: {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    } | undefined;
    isEnabledForToolRouter?: boolean | undefined;
    isComposioManaged?: boolean | undefined;
    expectedInputFields?: unknown[] | undefined;
    restrictToFollowingTools?: string[] | undefined;
    createdBy?: string | undefined;
    createdAt?: string | undefined;
    lastUpdatedAt?: string | undefined;
  }>, "many">;
  nextCursor: z$1.ZodNullable<z$1.ZodString>;
  totalPages: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
  items: {
    name: string;
    status: "ENABLED" | "DISABLED";
    toolkit: {
      slug: string;
      logo: string;
    };
    id: string;
    noOfConnections: number;
    uuid: string;
    authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
    credentials?: Record<string, unknown> | undefined;
    toolAccessConfig?: {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    } | undefined;
    isEnabledForToolRouter?: boolean | undefined;
    isComposioManaged?: boolean | undefined;
    expectedInputFields?: unknown[] | undefined;
    restrictToFollowingTools?: string[] | undefined;
    createdBy?: string | undefined;
    createdAt?: string | undefined;
    lastUpdatedAt?: string | undefined;
  }[];
  nextCursor: string | null;
  totalPages: number;
}, {
  items: {
    name: string;
    status: "ENABLED" | "DISABLED";
    toolkit: {
      slug: string;
      logo: string;
    };
    id: string;
    noOfConnections: number;
    uuid: string;
    authScheme?: "OAUTH1" | "OAUTH2" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "BILLCOM_AUTH" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "CALCOM_AUTH" | "SERVICE_ACCOUNT" | "SAML" | "DCR_OAUTH" | undefined;
    credentials?: Record<string, unknown> | undefined;
    toolAccessConfig?: {
      toolsForConnectedAccountCreation?: string[] | undefined;
      toolsAvailableForExecution?: string[] | undefined;
    } | undefined;
    isEnabledForToolRouter?: boolean | undefined;
    isComposioManaged?: boolean | undefined;
    expectedInputFields?: unknown[] | undefined;
    restrictToFollowingTools?: string[] | undefined;
    createdBy?: string | undefined;
    createdAt?: string | undefined;
    lastUpdatedAt?: string | undefined;
  }[];
  nextCursor: string | null;
  totalPages: number;
}>;
type AuthConfigListResponse = z$1.infer<typeof AuthConfigListResponseSchema>;
declare const AuthCustomConfigUpdateParamsSchema: z$1.ZodObject<{
  type: z$1.ZodLiteral<"custom">;
  credentials: z$1.ZodOptional<z$1.ZodObject<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  type: "custom";
  credentials?: z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}, {
  type: "custom";
  credentials?: z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}>;
declare const AuthDefaultConfigUpdateParamsSchema: z$1.ZodObject<{
  type: z$1.ZodLiteral<"default">;
  scopes: z$1.ZodOptional<z$1.ZodString>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  type: "default";
  scopes?: string | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}, {
  type: "default";
  scopes?: string | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}>;
declare const AuthConfigUpdateParamsSchema: z$1.ZodDiscriminatedUnion<"type", [z$1.ZodObject<{
  type: z$1.ZodLiteral<"custom">;
  credentials: z$1.ZodOptional<z$1.ZodObject<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough">>>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  type: "custom";
  credentials?: z$1.objectOutputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}, {
  type: "custom";
  credentials?: z$1.objectInputType<{
    scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
    user_scopes: z$1.ZodOptional<z$1.ZodUnion<[z$1.ZodString, z$1.ZodArray<z$1.ZodString, "many">]>>;
  }, z$1.ZodTypeAny, "passthrough"> | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}>, z$1.ZodObject<{
  type: z$1.ZodLiteral<"default">;
  scopes: z$1.ZodOptional<z$1.ZodString>;
  isEnabledForToolRouter: z$1.ZodOptional<z$1.ZodBoolean>;
  /**
   * @deprecated - use tool access config to determine the tools that the user can perform on the auth config.
   */
  restrictToFollowingTools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  toolAccessConfig: z$1.ZodOptional<z$1.ZodObject<{
    toolsAvailableForExecution: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
    toolsForConnectedAccountCreation: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  }, "strip", z$1.ZodTypeAny, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }, {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  }>>;
}, "strip", z$1.ZodTypeAny, {
  type: "default";
  scopes?: string | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}, {
  type: "default";
  scopes?: string | undefined;
  toolAccessConfig?: {
    toolsForConnectedAccountCreation?: string[] | undefined;
    toolsAvailableForExecution?: string[] | undefined;
  } | undefined;
  isEnabledForToolRouter?: boolean | undefined;
  restrictToFollowingTools?: string[] | undefined;
}>]>;
type AuthConfigUpdateParams = z$1.infer<typeof AuthConfigUpdateParamsSchema>;
//#endregion
//#region src/models/Toolkits.d.ts
/**
 * Toolkits class
 *
 * Toolkits are a collection of tools that can be used to perform various tasks.
 * This is similar/replacement of `apps` in the Composio API.
 */
declare class Toolkits {
  private client;
  constructor(client: ComposioClient);
  /**
   * Retrieves a list of toolkits based on the provided query parameters.
   *
   * This method fetches toolkits from the Composio API and transforms the response
   * from snake_case to camelCase format for consistency with JavaScript/TypeScript conventions.
   *
   * @param {ToolkitListParams} query - The query parameters to filter toolkits
   * @returns {Promise<ToolKitListResponse>} The transformed list of toolkits
   *
   * @private
   */
  private getToolkits;
  /**
   * Retrieves a specific toolkit by its slug identifier.
   *
   * This method fetches a single toolkit from the Composio API and transforms
   * the response to use camelCase property naming consistent with JavaScript/TypeScript conventions.
   *
   * @param {string} slug - The unique slug identifier of the toolkit to retrieve
   * @returns {Promise<ToolkitRetrieveResponse>} The transformed toolkit object
   * @throws {ValidationError} If the response cannot be properly parsed
   * @throws {ComposioToolNotFoundError} If no toolkit with the given slug exists
   *
   * @private
   */
  protected getToolkitBySlug(slug: string): Promise<ToolkitRetrieveResponse>;
  /**
   * Retrieves a specific toolkit by its slug identifier.
   *
   * @param {string} slug - The unique slug identifier of the toolkit to retrieve
   * @returns {Promise<ToolkitRetrieveResponse>} The toolkit object with detailed information
   * @throws {ComposioToolNotFoundError} If no toolkit with the given slug exists
   *
   * @example
   * ```typescript
   * // Get a specific toolkit
   * const githubToolkit = await composio.toolkits.get('github');
   * console.log(githubToolkit.name); // GitHub
   * console.log(githubToolkit.authConfigDetails); // Authentication configuration details
   * ```
   */
  get(slug: string): Promise<ToolkitRetrieveResponse>;
  /**
   * Retrieves a list of toolkits based on the provided query parameters.
   *
   * @param {ToolkitListParams} query - The query parameters to filter toolkits
   * @returns {Promise<ToolKitListResponse>} A paginated list of toolkits matching the query criteria
   *
   * @example
   * ```typescript
   * // Get all toolkits
   * const allToolkits = await composio.toolkits.get({});
   *
   * // Get toolkits by category
   * const devToolkits = await composio.toolkits.get({
   *   category: 'developer-tools'
   * });
   *
   * // Get local toolkits
   * const localToolkits = await composio.toolkits.get({
   *   isLocal: true
   * });
   * ```
   */
  get(query?: ToolkitListParams): Promise<ToolKitListResponse>;
  private getAuthConfigFields;
  /**
   * Retrieves the fields required for creating an auth config for a toolkit.
   * @param toolkitSlug - The slug of the toolkit to retrieve the fields for
   * @param authScheme - The auth scheme to retrieve the fields for
   * @param options.requiredOnly - Whether to only return the required fields
   * @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for creating an auth config
   */
  getAuthConfigCreationFields(toolkitSlug: string, authScheme: AuthSchemeType, {
    requiredOnly
  }?: {
    requiredOnly?: boolean;
  }): Promise<ToolkitAuthFieldsResponse>;
  /**
   * Retrieves the fields required for initiating a connected account for a toolkit.
   * @param toolkitSlug - The slug of the toolkit to retrieve the fields for
   * @param authScheme - The auth scheme to retrieve the fields for
   * @param options.requiredOnly - Whether to only return the required fields
   * @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for initiating a connected account
   */
  getConnectedAccountInitiationFields(toolkitSlug: string, authScheme: AuthSchemeType, {
    requiredOnly
  }?: {
    requiredOnly?: boolean;
  }): Promise<ToolkitAuthFieldsResponse>;
  /**
   * Retrieves all toolkit categories available in the Composio SDK.
   *
   * This method fetches the complete list of categories from the Composio API
   * and transforms the response to use camelCase property naming.
   *
   * @returns {Promise<ToolkitRetrieveCategoriesResponse>} The list of toolkit categories
   *
   * @example
   * ```typescript
   * // Get all toolkit categories
   * const categories = await composio.toolkits.listCategories();
   * console.log(categories.items); // Array of category objects
   * ```
   */
  listCategories(): Promise<ToolkitRetrieveCategoriesResponse>;
  /**
   * Authorizes a user to use a toolkit.
   * This method will create an auth config if one doesn't exist and initiate a connection request.
   * @param {string} userId - The user id of the user to authorize
   * @param {string} toolkitSlug - The slug of the toolkit to authorize
   * @returns {Promise<ConnectionRequest>} The connection request object
   *
   * @example
   * ```typescript
   * const connectionRequest = await composio.toolkits.authorize(userId, 'github');
   * ```
   *
   */
  authorize(userId: string, toolkitSlug: string, authConfigId?: string): Promise<ConnectionRequest>;
}
//#endregion
//#region src/types/triggers.types.d.ts
declare const TriggerStatuses: {
  readonly ENABLE: "enable";
  readonly DISABLE: "disable";
};
type TriggerStatusType = (typeof TriggerStatuses)[keyof typeof TriggerStatuses];
declare const TriggerStatusEnum: z$1.ZodEnum<["enable", "disable"]>;
declare const TriggerSubscribeParamSchema: z$1.ZodObject<{
  toolkits: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  triggerId: z$1.ZodOptional<z$1.ZodString>;
  connectedAccountId: z$1.ZodOptional<z$1.ZodString>;
  authConfigId: z$1.ZodOptional<z$1.ZodString>;
  triggerSlug: z$1.ZodOptional<z$1.ZodArray<z$1.ZodString, "many">>;
  triggerData: z$1.ZodOptional<z$1.ZodString>;
  userId: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  toolkits?: string[] | undefined;
  connectedAccountId?: string | undefined;
  userId?: string | undefined;
  triggerId?: string | undefined;
  authConfigId?: string | undefined;
  triggerSlug?: string[] | undefined;
  triggerData?: string | undefined;
}, {
  toolkits?: string[] | undefined;
  connectedAccountId?: string | undefined;
  userId?: string | undefined;
  triggerId?: string | undefined;
  authConfigId?: string | undefined;
  triggerSlug?: string[] | undefined;
  triggerData?: string | undefined;
}>;
type TriggerSubscribeParams = z$1.infer<typeof TriggerSubscribeParamSchema>;
declare const TriggerInstanceListActiveParamsSchema: z$1.ZodObject<{
  authConfigIds: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
  connectedAccountIds: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
  limit: z$1.ZodOptional<z$1.ZodNumber>;
  cursor: z$1.ZodOptional<z$1.ZodString>;
  showDisabled: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodBoolean>>;
  triggerIds: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
  triggerNames: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
}, "strip", z$1.ZodTypeAny, {
  limit?: number | undefined;
  authConfigIds?: string[] | null | undefined;
  cursor?: string | undefined;
  connectedAccountIds?: string[] | null | undefined;
  showDisabled?: boolean | null | undefined;
  triggerIds?: string[] | null | undefined;
  triggerNames?: string[] | null | undefined;
}, {
  limit?: number | undefined;
  authConfigIds?: string[] | null | undefined;
  cursor?: string | undefined;
  connectedAccountIds?: string[] | null | undefined;
  showDisabled?: boolean | null | undefined;
  triggerIds?: string[] | null | undefined;
  triggerNames?: string[] | null | undefined;
}>;
type TriggerInstanceListActiveParams = z$1.infer<typeof TriggerInstanceListActiveParamsSchema>;
declare const TriggerInstanceListActiveResponseItemSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  connectedAccountId: z$1.ZodString;
  disabledAt: z$1.ZodNullable<z$1.ZodString>;
  state: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  triggerConfig: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  triggerName: z$1.ZodString;
  updatedAt: z$1.ZodString;
  triggerData: z$1.ZodOptional<z$1.ZodString>;
  uuid: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  connectedAccountId: string;
  id: string;
  updatedAt: string;
  disabledAt: string | null;
  state: Record<string, unknown>;
  triggerConfig: Record<string, unknown>;
  triggerName: string;
  uuid?: string | undefined;
  triggerData?: string | undefined;
}, {
  connectedAccountId: string;
  id: string;
  updatedAt: string;
  disabledAt: string | null;
  state: Record<string, unknown>;
  triggerConfig: Record<string, unknown>;
  triggerName: string;
  uuid?: string | undefined;
  triggerData?: string | undefined;
}>;
declare const TriggerInstanceListActiveResponseSchema: z$1.ZodObject<{
  items: z$1.ZodArray<z$1.ZodObject<{
    id: z$1.ZodString;
    connectedAccountId: z$1.ZodString;
    disabledAt: z$1.ZodNullable<z$1.ZodString>;
    state: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
    triggerConfig: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
    triggerName: z$1.ZodString;
    updatedAt: z$1.ZodString;
    triggerData: z$1.ZodOptional<z$1.ZodString>;
    uuid: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    connectedAccountId: string;
    id: string;
    updatedAt: string;
    disabledAt: string | null;
    state: Record<string, unknown>;
    triggerConfig: Record<string, unknown>;
    triggerName: string;
    uuid?: string | undefined;
    triggerData?: string | undefined;
  }, {
    connectedAccountId: string;
    id: string;
    updatedAt: string;
    disabledAt: string | null;
    state: Record<string, unknown>;
    triggerConfig: Record<string, unknown>;
    triggerName: string;
    uuid?: string | undefined;
    triggerData?: string | undefined;
  }>, "many">;
  nextCursor: z$1.ZodNullable<z$1.ZodString>;
  totalPages: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
  items: {
    connectedAccountId: string;
    id: string;
    updatedAt: string;
    disabledAt: string | null;
    state: Record<string, unknown>;
    triggerConfig: Record<string, unknown>;
    triggerName: string;
    uuid?: string | undefined;
    triggerData?: string | undefined;
  }[];
  nextCursor: string | null;
  totalPages: number;
}, {
  items: {
    connectedAccountId: string;
    id: string;
    updatedAt: string;
    disabledAt: string | null;
    state: Record<string, unknown>;
    triggerConfig: Record<string, unknown>;
    triggerName: string;
    uuid?: string | undefined;
    triggerData?: string | undefined;
  }[];
  nextCursor: string | null;
  totalPages: number;
}>;
type TriggerInstanceListActiveResponse = z$1.infer<typeof TriggerInstanceListActiveResponseSchema>;
type TriggerInstanceListActiveResponseItem = z$1.infer<typeof TriggerInstanceListActiveResponseItemSchema>;
declare const TriggerInstanceUpsertParamsSchema: z$1.ZodObject<{
  connectedAccountId: z$1.ZodOptional<z$1.ZodString>;
  triggerConfig: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
}, "strip", z$1.ZodTypeAny, {
  connectedAccountId?: string | undefined;
  triggerConfig?: Record<string, unknown> | undefined;
}, {
  connectedAccountId?: string | undefined;
  triggerConfig?: Record<string, unknown> | undefined;
}>;
type TriggerInstanceUpsertParams = z$1.infer<typeof TriggerInstanceUpsertParamsSchema>;
declare const TriggerInstanceUpsertResponseSchema: z$1.ZodObject<{
  triggerId: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  triggerId: string;
}, {
  triggerId: string;
}>;
type TriggerInstanceUpsertResponse = z$1.infer<typeof TriggerInstanceUpsertResponseSchema>;
declare const TriggerInstanceManageUpdateParamsSchema: z$1.ZodObject<{
  status: z$1.ZodEnum<["enable", "disable"]>;
}, "strip", z$1.ZodTypeAny, {
  status: "enable" | "disable";
}, {
  status: "enable" | "disable";
}>;
type TriggerInstanceManageUpdateParams = z$1.infer<typeof TriggerInstanceManageUpdateParamsSchema>;
declare const TriggerInstanceManageUpdateResponseSchema: z$1.ZodObject<{
  status: z$1.ZodEnum<["success"]>;
}, "strip", z$1.ZodTypeAny, {
  status: "success";
}, {
  status: "success";
}>;
type TriggerInstanceManageUpdateResponse = z$1.infer<typeof TriggerInstanceManageUpdateResponseSchema>;
declare const TriggerInstanceManageDeleteResponseSchema: z$1.ZodObject<{
  triggerId: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  triggerId: string;
}, {
  triggerId: string;
}>;
type TriggerInstanceManageDeleteResponse = z$1.infer<typeof TriggerInstanceManageDeleteResponseSchema>;
declare const IncomingTriggerPayloadSchema: z$1.ZodObject<{
  id: z$1.ZodString;
  uuid: z$1.ZodString;
  triggerSlug: z$1.ZodString;
  toolkitSlug: z$1.ZodString;
  userId: z$1.ZodString;
  payload: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
  originalPayload: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>>;
  metadata: z$1.ZodObject<{
    id: z$1.ZodString;
    uuid: z$1.ZodString;
    toolkitSlug: z$1.ZodString;
    triggerSlug: z$1.ZodString;
    triggerData: z$1.ZodOptional<z$1.ZodString>;
    triggerConfig: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
    connectedAccount: z$1.ZodObject<{
      id: z$1.ZodString;
      uuid: z$1.ZodString;
      authConfigId: z$1.ZodString;
      authConfigUUID: z$1.ZodString;
      userId: z$1.ZodString;
      status: z$1.ZodEnum<["ACTIVE", "INACTIVE"]>;
    }, "strip", z$1.ZodTypeAny, {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    }, {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    }>;
  }, "strip", z$1.ZodTypeAny, {
    toolkitSlug: string;
    id: string;
    uuid: string;
    triggerSlug: string;
    triggerConfig: Record<string, unknown>;
    connectedAccount: {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    };
    triggerData?: string | undefined;
  }, {
    toolkitSlug: string;
    id: string;
    uuid: string;
    triggerSlug: string;
    triggerConfig: Record<string, unknown>;
    connectedAccount: {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    };
    triggerData?: string | undefined;
  }>;
}, "strip", z$1.ZodTypeAny, {
  toolkitSlug: string;
  userId: string;
  id: string;
  uuid: string;
  triggerSlug: string;
  metadata: {
    toolkitSlug: string;
    id: string;
    uuid: string;
    triggerSlug: string;
    triggerConfig: Record<string, unknown>;
    connectedAccount: {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    };
    triggerData?: string | undefined;
  };
  payload?: Record<string, unknown> | undefined;
  originalPayload?: Record<string, unknown> | undefined;
}, {
  toolkitSlug: string;
  userId: string;
  id: string;
  uuid: string;
  triggerSlug: string;
  metadata: {
    toolkitSlug: string;
    id: string;
    uuid: string;
    triggerSlug: string;
    triggerConfig: Record<string, unknown>;
    connectedAccount: {
      status: "ACTIVE" | "INACTIVE";
      userId: string;
      id: string;
      uuid: string;
      authConfigId: string;
      authConfigUUID: string;
    };
    triggerData?: string | undefined;
  };
  payload?: Record<string, unknown> | undefined;
  originalPayload?: Record<string, unknown> | undefined;
}>;
type IncomingTriggerPayload = z$1.infer<typeof IncomingTriggerPayloadSchema>;
type TriggerData = {
  appName: string;
  clientId: number;
  payload: Record<string, unknown>;
  originalPayload: Record<string, unknown>;
  metadata: {
    id: string;
    nanoId: string;
    triggerName: string;
    triggerData: string;
    triggerConfig: Record<string, unknown>;
    connection: {
      id: string;
      connectedAccountNanoId: string;
      integrationId: string;
      authConfigNanoId: string;
      clientUniqueUserId: string;
      status: string;
    };
  };
};
declare const TriggersTypeListParamsSchema: z$1.ZodObject<{
  cursor: z$1.ZodOptional<z$1.ZodString>;
  limit: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodNumber>>;
  toolkits: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodArray<z$1.ZodString, "many">>>;
}, "strip", z$1.ZodTypeAny, {
  toolkits?: string[] | null | undefined;
  limit?: number | null | undefined;
  cursor?: string | undefined;
}, {
  toolkits?: string[] | null | undefined;
  limit?: number | null | undefined;
  cursor?: string | undefined;
}>;
type TriggersTypeListParams = z$1.infer<typeof TriggersTypeListParamsSchema>;
declare const TriggerTypeSchema: z$1.ZodObject<{
  slug: z$1.ZodString;
  name: z$1.ZodString;
  description: z$1.ZodString;
  instructions: z$1.ZodOptional<z$1.ZodString>;
  toolkit: z$1.ZodObject<{
    logo: z$1.ZodString;
    slug: z$1.ZodString;
    name: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    slug: string;
    name: string;
    logo: string;
  }, {
    slug: string;
    name: string;
    logo: string;
  }>;
  payload: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  config: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  version: z$1.ZodOptional<z$1.ZodString>;
}, "strip", z$1.ZodTypeAny, {
  slug: string;
  name: string;
  description: string;
  toolkit: {
    slug: string;
    name: string;
    logo: string;
  };
  payload: Record<string, unknown>;
  config: Record<string, unknown>;
  version?: string | undefined;
  instructions?: string | undefined;
}, {
  slug: string;
  name: string;
  description: string;
  toolkit: {
    slug: string;
    name: string;
    logo: string;
  };
  payload: Record<string, unknown>;
  config: Record<string, unknown>;
  version?: string | undefined;
  instructions?: string | undefined;
}>;
type TriggerType = z$1.infer<typeof TriggerTypeSchema>;
declare const TriggersTypeListResponseSchema: z$1.ZodObject<{
  items: z$1.ZodArray<z$1.ZodObject<{
    slug: z$1.ZodString;
    name: z$1.ZodString;
    description: z$1.ZodString;
    instructions: z$1.ZodOptional<z$1.ZodString>;
    toolkit: z$1.ZodObject<{
      logo: z$1.ZodString;
      slug: z$1.ZodString;
      name: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
      slug: string;
      name: string;
      logo: string;
    }, {
      slug: string;
      name: string;
      logo: string;
    }>;
    payload: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
    config: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
    version: z$1.ZodOptional<z$1.ZodString>;
  }, "strip", z$1.ZodTypeAny, {
    slug: string;
    name: string;
    description: string;
    toolkit: {
      slug: string;
      name: string;
      logo: string;
    };
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    version?: string | undefined;
    instructions?: string | undefined;
  }, {
    slug: string;
    name: string;
    description: string;
    toolkit: {
      slug: string;
      name: string;
      logo: string;
    };
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    version?: string | undefined;
    instructions?: string | undefined;
  }>, "many">;
  nextCursor: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
  totalPages: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
  items: {
    slug: string;
    name: string;
    description: string;
    toolkit: {
      slug: string;
      name: string;
      logo: string;
    };
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    version?: string | undefined;
    instructions?: string | undefined;
  }[];
  totalPages: number;
  nextCursor?: string | null | undefined;
}, {
  items: {
    slug: string;
    name: string;
    description: string;
    toolkit: {
      slug: string;
      name: string;
      logo: string;
    };
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    version?: string | undefined;
    instructions?: string | undefined;
  }[];
  totalPages: number;
  nextCursor?: string | null | undefined;
}>;
type TriggersTypeListResponse = z$1.infer<typeof TriggersTypeListResponseSchema>;
type TriggersTypeRetrieveResponse = z$1.infer<typeof TriggerTypeSchema>;
/**
 * Generic trigger event type that can be used with generated trigger payload types
 * @template TPayload - The specific trigger payload type (e.g., GITHUB_COMMIT_EVENT_PAYLOAD)
 */
interface TriggerEvent<TPayload = unknown> {
  type: string;
  timestamp: string;
  data: TriggerEventData<TPayload>;
}
/**
 * Generic trigger event data type that contains the payload and metadata
 * @template TPayload - The specific trigger payload type
 */
type TriggerEventData<TPayload = unknown> = TPayload & {
  connection_nano_id: string;
  trigger_nano_id: string;
  user_id: string;
};
/**
 * Webhook payload schemas for V1, V2, V3 versions
 * These schemas represent the raw payload structure sent by Composio's webhook system
 */
/** V1 webhook payload - legacy format */
declare const WebhookPayloadV1Schema: z$1.ZodObject<{
  trigger_name: z$1.ZodString;
  connection_id: z$1.ZodString;
  trigger_id: z$1.ZodString;
  payload: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  log_id: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  payload: Record<string, unknown>;
  trigger_name: string;
  connection_id: string;
  trigger_id: string;
  log_id: string;
}, {
  payload: Record<string, unknown>;
  trigger_name: string;
  connection_id: string;
  trigger_id: string;
  log_id: string;
}>;
type WebhookPayloadV1 = z$1.infer<typeof WebhookPayloadV1Schema>;
/** V2 webhook payload - includes timestamp and nested data */
declare const WebhookPayloadV2Schema: z$1.ZodObject<{
  type: z$1.ZodString;
  timestamp: z$1.ZodString;
  log_id: z$1.ZodString;
  data: z$1.ZodObject<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, z$1.ZodTypeAny, "passthrough">>;
}, "strip", z$1.ZodTypeAny, {
  type: string;
  data: {
    connection_id: string;
    trigger_id: string;
    connection_nano_id: string;
    trigger_nano_id: string;
    user_id: string;
  } & {
    [k: string]: unknown;
  };
  log_id: string;
  timestamp: string;
}, {
  type: string;
  data: {
    connection_id: string;
    trigger_id: string;
    connection_nano_id: string;
    trigger_nano_id: string;
    user_id: string;
  } & {
    [k: string]: unknown;
  };
  log_id: string;
  timestamp: string;
}>;
type WebhookPayloadV2 = z$1.infer<typeof WebhookPayloadV2Schema>;
/** V3 webhook payload - current format with metadata */
declare const WebhookPayloadV3Schema: z$1.ZodObject<{
  id: z$1.ZodString;
  timestamp: z$1.ZodString;
  type: z$1.ZodLiteral<"composio.trigger.message">;
  metadata: z$1.ZodObject<{
    log_id: z$1.ZodString;
    trigger_slug: z$1.ZodString;
    trigger_id: z$1.ZodString;
    connected_account_id: z$1.ZodString;
    auth_config_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  }, {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  }>;
  data: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
}, "strip", z$1.ZodTypeAny, {
  type: "composio.trigger.message";
  data: Record<string, unknown>;
  id: string;
  metadata: {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  };
  timestamp: string;
}, {
  type: "composio.trigger.message";
  data: Record<string, unknown>;
  id: string;
  metadata: {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  };
  timestamp: string;
}>;
type WebhookPayloadV3 = z$1.infer<typeof WebhookPayloadV3Schema>;
/** Union of all webhook payload versions */
declare const WebhookPayloadSchema: z$1.ZodUnion<[z$1.ZodObject<{
  id: z$1.ZodString;
  timestamp: z$1.ZodString;
  type: z$1.ZodLiteral<"composio.trigger.message">;
  metadata: z$1.ZodObject<{
    log_id: z$1.ZodString;
    trigger_slug: z$1.ZodString;
    trigger_id: z$1.ZodString;
    connected_account_id: z$1.ZodString;
    auth_config_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, "strip", z$1.ZodTypeAny, {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  }, {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  }>;
  data: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
}, "strip", z$1.ZodTypeAny, {
  type: "composio.trigger.message";
  data: Record<string, unknown>;
  id: string;
  metadata: {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  };
  timestamp: string;
}, {
  type: "composio.trigger.message";
  data: Record<string, unknown>;
  id: string;
  metadata: {
    trigger_id: string;
    log_id: string;
    user_id: string;
    trigger_slug: string;
    connected_account_id: string;
    auth_config_id: string;
  };
  timestamp: string;
}>, z$1.ZodObject<{
  type: z$1.ZodString;
  timestamp: z$1.ZodString;
  log_id: z$1.ZodString;
  data: z$1.ZodObject<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, "passthrough", z$1.ZodTypeAny, z$1.objectOutputType<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, z$1.ZodTypeAny, "passthrough">, z$1.objectInputType<{
    connection_id: z$1.ZodString;
    connection_nano_id: z$1.ZodString;
    trigger_nano_id: z$1.ZodString;
    trigger_id: z$1.ZodString;
    user_id: z$1.ZodString;
  }, z$1.ZodTypeAny, "passthrough">>;
}, "strip", z$1.ZodTypeAny, {
  type: string;
  data: {
    connection_id: string;
    trigger_id: string;
    connection_nano_id: string;
    trigger_nano_id: string;
    user_id: string;
  } & {
    [k: string]: unknown;
  };
  log_id: string;
  timestamp: string;
}, {
  type: string;
  data: {
    connection_id: string;
    trigger_id: string;
    connection_nano_id: string;
    trigger_nano_id: string;
    user_id: string;
  } & {
    [k: string]: unknown;
  };
  log_id: string;
  timestamp: string;
}>, z$1.ZodObject<{
  trigger_name: z$1.ZodString;
  connection_id: z$1.ZodString;
  trigger_id: z$1.ZodString;
  payload: z$1.ZodRecord<z$1.ZodString, z$1.ZodUnknown>;
  log_id: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
  payload: Record<string, unknown>;
  trigger_name: string;
  connection_id: string;
  trigger_id: string;
  log_id: string;
}, {
  payload: Record<string, unknown>;
  trigger_name: string;
  connection_id: string;
  trigger_id: string;
  log_id: string;
}>]>;
type WebhookPayload = z$1.infer<typeof WebhookPayloadSchema>;
/** Webhook version enum */
declare const WebhookVersions: {
  readonly V1: "V1";
  readonly V2: "V2";
  readonly V3: "V3";
};
type WebhookVersion = (typeof WebhookVersions)[keyof typeof WebhookVersions];
/**
 * Parameters for verifying a webhook signature
 */
declare const VerifyWebhookParamsSchema: z$1.ZodObject<{
  /**
   * The webhook message ID from the 'webhook-id' header.
   * Format: 'msg_xxx'
   */
  id: z$1.ZodString;
  /** The raw webhook payload as a string (request body) */
  payload: z$1.ZodString;
  /** The webhook secret used to sign the payload (from Composio dashboard) */
  secret: z$1.ZodString;
  /**
   * The signature from the 'webhook-signature' header.
   * Format: 'v1,base64EncodedSignature'
   */
  signature: z$1.ZodString;
  /**
   * The webhook timestamp from the 'webhook-timestamp' header.
   * This is the Unix timestamp in seconds when the webhook was sent.
   */
  timestamp: z$1.ZodString;
  /**
   * Maximum allowed age of the webhook in seconds.
   * If the webhook timestamp is older than this, verification will fail.
   * Set to 0 to disable timestamp validation.
   * @default 300 (5 minutes)
   */
  tolerance: z$1.ZodDefault<z$1.ZodOptional<z$1.ZodNumber>>;
}, "strip", z$1.ZodTypeAny, {
  id: string;
  payload: string;
  timestamp: string;
  secret: string;
  signature: string;
  tolerance: number;
}, {
  id: string;
  payload: string;
  timestamp: string;
  secret: string;
  signature: string;
  tolerance?: number | undefined;
}>;
type VerifyWebhookParams = z$1.input<typeof VerifyWebhookParamsSchema>;
/**
 * Result of a successful webhook verification.
 * Contains the parsed payload along with version information.
 */
type VerifyWebhookResult = {
  /** The webhook version (V1, V2, or V3), from 'x-composio-webhook-version' */
  version: WebhookVersion;
  /** The parsed and normalized webhook payload */
  payload: IncomingTriggerPayload;
  /** The raw parsed payload before normalization */
  rawPayload: WebhookPayload;
};
//#endregion
//#region src/models/Triggers.d.ts
/**
 * Trigger (Instance) class
 * /api/v3/trigger_instances
 *
 */
declare class Triggers<TProvider extends BaseComposioProvider<unknown, unknown, unknown>> {
  private client;
  private pusherService;
  private toolkitVersions;
  constructor(client: ComposioClient, config?: ComposioConfig<TProvider>);
  /**
   * Fetch list of all the active triggers
   *
   * @param {TriggerInstanceListActiveParams} query - The query parameters to filter the trigger instances
   * @returns {Promise<TriggerInstanceListActiveResponse>} List of trigger instances
   *
   * @throws {ValidationError} If the parameters are invalid
   * @throws {Error} If the client is not authenticated
   *
   * @example
   * ```ts
   * const triggers = await triggers.listActive({
   *   authConfigIds: ['123'],
   *   connectedAccountIds: ['456'],
   * });
   * ```
   */
  listActive(query?: TriggerInstanceListActiveParams): Promise<TriggerInstanceListActiveResponse>;
  /**
   * Create a new trigger instance for a user
   * If the connected account id is not provided, the first connected account for the user and toolkit will be used
   *
   * @param {string} userId - The user id of the trigger instance
   * @param {string} slug - The slug of the trigger instance
   * @param {TriggerInstanceUpsertParams} body - The parameters to create the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The created trigger instance
   */
  create(userId: string, slug: string, body?: TriggerInstanceUpsertParams): Promise<TriggerInstanceUpsertResponse>;
  /**
   * Update an existing trigger instance
   *
   * @param {string} triggerId - The Id of the trigger instance
   * @param {TriggerInstanceManageUpdateParams} body - The parameters to update the trigger instance
   * @returns {Promise<TriggerInstanceManageUpdateResponse>} The updated trigger instance response
   */
  update(triggerId: string, body: TriggerInstanceManageUpdateParams): Promise<TriggerInstanceManageUpdateResponse>;
  /**
   * Delete a trigger instance
   *
   * @param {string} triggerId - The slug of the trigger instance
   * @returns
   */
  delete(triggerId: string): Promise<TriggerInstanceManageDeleteResponse>;
  /**
   * Disable a trigger instance
   *
   * @param {string} triggerId - The id of the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
   */
  disable(triggerId: string): Promise<ComposioClient.TriggerInstances.Manage.ManageUpdateResponse>;
  /**
   * Enable a trigger instance
   *
   * @param {string} triggerId - The id of the trigger instance
   * @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
   */
  enable(triggerId: string): Promise<ComposioClient.TriggerInstances.Manage.ManageUpdateResponse>;
  /**
   * @TODO Learn about trigger types
   */
  /**
   * List all the trigger types
   *
   * @param {TriggersTypeListParams} query - The query parameters to filter the trigger types
   * @param {RequestOptions} options - Request options
   * @returns {Promise<TriggersTypeListResponse>} The list of trigger types
   */
  listTypes(query?: TriggersTypeListParams): Promise<TriggersTypeListResponse>;
  /**
   * Retrieve a trigger type by its slug for the provided version of the app
   * Use the global toolkit versions param when initializing composio to pass a toolkitversion
   *
   * @param {string} slug - The slug of the trigger type
   * @returns {Promise<TriggersTypeRetrieveResponse>} The trigger type object
   */
  getType(slug: string): Promise<TriggersTypeRetrieveResponse>;
  /**
   * Fetches the list of all the available trigger enums
   *
   * This method is used by the CLI where filters are not required.
   * @returns
   */
  listEnum(): Promise<TriggersTypeRetrieveEnumResponse>;
  /**
   * Applies compound filters to the trigger data
   * @param data data to apply filters to
   * @returns True if the trigger data matches the filters, false otherwise
   */
  private shouldSendTriggerAfterFilters;
  /**
   * Subscribe to all the triggers
   *
   * @param fn - The function to call when a trigger is received
   * @param filters - The filters to apply to the triggers
   *
   * @example
   * ```ts
   *
   * triggers.subscribe((data) => {
   *   console.log(data);
   * }, );
   * ```
   */
  subscribe(fn: (_data: IncomingTriggerPayload) => void, filters?: TriggerSubscribeParams): Promise<void>;
  /**
   * Tries to parse data as V1, V2, or V3 webhook payload format.
   * Returns the parsed result with version info, or null if no format matches.
   * Also returns any schema validation errors for debugging purposes.
   * @private
   */
  private tryParseVersionedPayload;
  /**
   * Parses incoming Pusher payload, supporting V1, V2, V3, and legacy TriggerData formats.
   * @private
   */
  private parsePusherPayload;
  /**
   * Unsubscribe from all the triggers
   *
   * @returns {Promise<void>}
   *
   * @example
   * ```ts
   * composio.trigger.subscribe((data) => {
   *   console.log(data);
   * });
   *
   * await triggers.unsubscribe();
   * ```
   */
  unsubscribe(): Promise<void>;
  /**
   * Verify an incoming webhook payload and signature.
   *
   * This method validates that the webhook request is authentic by:
   * 1. Verifying the HMAC-SHA256 signature matches the payload using the correct signing format
   * 2. Optionally checking that the webhook timestamp is within the tolerance window
   *
   * The signature is computed as: `HMAC-SHA256(${webhookId}.${webhookTimestamp}.${payload}, secret)`
   * and is expected in the format: `v1,base64EncodedSignature`
   *
   * @param {VerifyWebhookParams} params - The verification parameters
   * @param {string} params.payload - The raw webhook payload as a string (request body)
   * @param {string} params.signature - The signature from the 'webhook-signature' header
   * @param {string} params.secret - The webhook secret used to sign the payload
   * @param {string} params.webhookId - The webhook ID from the 'webhook-id' header
   * @param {string} params.webhookTimestamp - The timestamp from the 'webhook-timestamp' header (Unix seconds)
   * @param {number} [params.tolerance=300] - Maximum allowed age of the webhook in seconds (default: 5 minutes). Set to 0 to disable timestamp validation.
   * @returns {VerifyWebhookResult} The verified and parsed webhook payload with version information
   *
   * @throws {ValidationError} If the parameters are invalid
   * @throws {ComposioWebhookSignatureVerificationError} If the signature verification fails
   * @throws {ComposioWebhookPayloadError} If the payload cannot be parsed or is invalid
   *
   * @example
   * ```ts
   * // In an Express.js webhook handler
   * app.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
   *   try {
   *     const result = await composio.triggers.verifyWebhook({
   *       payload: req.body.toString(),
   *       signature: req.headers['webhook-signature'] as string,
   *       webhookId: req.headers['webhook-id'] as string,
   *       webhookTimestamp: req.headers['webhook-timestamp'] as string,
   *       secret: process.env.COMPOSIO_WEBHOOK_SECRET!,
   *     });
   *
   *     // Process the verified payload
   *     console.log('Webhook version:', result.version);
   *     console.log('Received trigger:', result.payload.triggerSlug);
   *     res.status(200).send('OK');
   *   } catch (error) {
   *     console.error('Webhook verification failed:', error);
   *     res.status(401).send('Unauthorized');
   *   }
   * });
   * ```
   */
  verifyWebhook(params: VerifyWebhookParams): Promise<VerifyWebhookResult>;
  /**
   * Parses the webhook payload and detects its version (V1, V2, or V3)
   * @private
   */
  private parseWebhookPayload;
  /**
   * Normalizes a V1 webhook payload to IncomingTriggerPayload format
   * @private
   */
  private normalizeV1Payload;
  /**
   * Normalizes a V2 webhook payload to IncomingTriggerPayload format
   * @private
   */
  private normalizeV2Payload;
  /**
   * Normalizes a V3 webhook payload to IncomingTriggerPayload format
   * @private
   */
  private normalizeV3Payload;
  /**
   * Verifies the HMAC-SHA256 signature of a webhook payload.
   * The signature format used by Composio is: `v1,base64EncodedSignature`
   * The signing input is: `${msgId}.${timestamp}.${payload}`
   * @private
   */
  private verifyWebhookSignature;
  /**
   * Validates that the webhook timestamp is within the allowed tolerance
   * @private
   */
  private validateWebhookTimestamp;
}
//#endregion
//#region src/models/AuthConfigs.d.ts
/**
 * AuthConfigs class
 *
 * This class is used to manage authentication configurations in the Composio SDK.
 * Auth configs are used to configure authentication providers and settings.
 */
declare class AuthConfigs {
  private client;
  constructor(client: ComposioClient);
  /**
   * Protected getter for the client instance.
   * This is primarily used for testing purposes.
   * @protected
   */
  protected getClient(): ComposioClient;
  /**
   * Lists authentication configurations based on provided filter criteria.
   *
   * This method retrieves auth configs from the Composio API, transforms them to the SDK format,
   * and supports filtering by various parameters.
   *
   * @param {AuthConfigListParams} [query] - Optional query parameters for filtering auth configs
   * @returns {Promise<AuthConfigListResponse>} A paginated list of auth configurations
   * @throws {ValidationError} If the query parameters or response fail validation
   *
   * @example
   * ```typescript
   * // List all auth configs
   * const allConfigs = await composio.authConfigs.list();
   *
   * // List auth configs for a specific toolkit
   * const githubConfigs = await composio.authConfigs.list({
   *   toolkit: 'github'
   * });
   *
   * // List Composio-managed auth configs
   * const managedConfigs = await composio.authConfigs.list({
   *   isComposioManaged: true
   * });
   * ```
   */
  list(query?: AuthConfigListParams): Promise<AuthConfigListResponse>;
  /**
   * Create a new auth config
   * @param {string} toolkit - Unique identifier of the toolkit
   * @param {CreateAuthConfigParams} options - Options for creating a new auth config
   * @returns {Promise<CreateAuthConfigResponse>} Created auth config
   *
   * @example
   * const authConfig = await authConfigs.create('my-toolkit', {
   *   type: AuthConfigTypes.CUSTOM,
   *   name: 'My Custom Auth Config',
   *   authScheme: AuthSchemeTypes.API_KEY,
   *   credentials: {
   *     apiKey: '1234567890',
   *   },
   * });
   *
   * @link https://docs.composio.dev/reference/auth-configs/create-auth-config
   */
  create(toolkit: string, options?: CreateAuthConfigParams): Promise<CreateAuthConfigResponse>;
  /**
   * Retrieves a specific authentication configuration by its ID.
   *
   * This method fetches detailed information about a single auth config
   * and transforms the response to the SDK's standardized format.
   *
   * @param {string} nanoid - The unique identifier of the auth config to retrieve
   * @returns {Promise<AuthConfigRetrieveResponse>} The auth config details
   * @throws {Error} If the auth config cannot be found or an API error occurs
   * @throws {ValidationError} If the response fails validation
   *
   * @example
   * ```typescript
   * // Get an auth config by ID
   * const authConfig = await composio.authConfigs.get('auth_abc123');
   * console.log(authConfig.name); // e.g., 'GitHub Auth'
   * console.log(authConfig.toolkit.slug); // e.g., 'github'
   * ```
   */
  get(nanoid: string): Promise<AuthConfigRetrieveResponse>;
  /**
   * Updates an existing authentication configuration.
   *
   * This method allows you to modify properties of an auth config such as credentials,
   * scopes, or tool restrictions. The update type (custom or default) determines which
   * fields can be updated.
   *
   * @param {string} nanoid - The unique identifier of the auth config to update
   * @param {AuthConfigUpdateParams} data - The data to update, which can be either custom or default type
   * @returns {Promise<AuthConfigUpdateResponse>} The updated auth config
   * @throws {ValidationError} If the update parameters are invalid
   * @throws {Error} If the auth config cannot be found or updated
   *
   * @example
   * ```typescript
   * // Update a custom auth config with new credentials
   * const updatedConfig = await composio.authConfigs.update('auth_abc123', {
   *   type: 'custom',
   *   credentials: {
   *     apiKey: 'new-api-key-value'
   *   }
   * });
   *
   * // Update a default auth config with new scopes
   * const updatedConfig = await composio.authConfigs.update('auth_abc123', {
   *   type: 'default',
   *   scopes: ['read:user', 'repo']
   * });
   * ```
   */
  update(nanoid: string, data: AuthConfigUpdateParams): Promise<AuthConfigUpdateResponse>;
  /**
   * Deletes an authentication configuration.
   *
   * This method permanently removes an auth config from the Composio platform.
   * This action cannot be undone and will prevent any connected accounts that use
   * this auth config from functioning.
   *
   * @param {string} nanoid - The unique identifier of the auth config to delete
   * @returns {Promise<AuthConfigDeleteResponse>} The deletion response
   * @throws {Error} If the auth config doesn't exist or cannot be deleted
   *
   * @example
   * ```typescript
   * // Delete an auth config
   * await composio.authConfigs.delete('auth_abc123');
   * ```
   */
  delete(nanoid: string): Promise<AuthConfigDeleteResponse>;
  /**
   * Updates the status of an authentication configuration.
   *
   * This method allows you to enable or disable an auth config. When disabled,
   * the auth config cannot be used to create new connected accounts or authenticate
   * with third-party services.
   *
   * @param {string} status - The status to set ('ENABLED' or 'DISABLED')
   * @param {string} nanoid - The unique identifier of the auth config
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or the status cannot be updated
   *
   * @example
   * ```typescript
   * // Disable an auth config
   * await composio.authConfigs.updateStatus('DISABLED', 'auth_abc123');
   *
   * // Enable an auth config
   * await composio.authConfigs.updateStatus('ENABLED', 'auth_abc123');
   * ```
   */
  updateStatus(status: 'ENABLED' | 'DISABLED', nanoid: string): Promise<AuthConfigUpdateStatusResponse>;
  /**
   * Enables an authentication configuration.
   *
   * This is a convenience method that calls updateStatus with 'ENABLED'.
   * When enabled, the auth config can be used to create new connected accounts
   * and authenticate with third-party services.
   *
   * @param {string} nanoid - The unique identifier of the auth config to enable
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or enabled
   *
   * @example
   * ```typescript
   * // Enable an auth config
   * await composio.authConfigs.enable('auth_abc123');
   * ```
   */
  enable(nanoid: string): Promise<AuthConfigUpdateStatusResponse>;
  /**
   * Disables an authentication configuration.
   *
   * This is a convenience method that calls updateStatus with 'DISABLED'.
   * When disabled, the auth config cannot be used to create new connected accounts
   * or authenticate with third-party services, but existing connections may continue to work.
   *
   * @param {string} nanoid - The unique identifier of the auth config to disable
   * @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
   * @throws {Error} If the auth config cannot be found or disabled
   *
   * @example
   * ```typescript
   * // Disable an auth config
   * await composio.authConfigs.disable('auth_abc123');
   * ```
   */
  disable(nanoid: string): Promise<AuthConfigUpdateStatusResponse>;
}
//#endregion
//#region src/models/ConnectedAccounts.d.ts
/**
 * ConnectedAccounts class
 *
 * This class is used to manage connected accounts in the Composio SDK.
 * Connected accounts are used to authenticate with third-party services.
 */
declare class ConnectedAccounts {
  private client;
  constructor(client: ComposioClient);
  /**
   * Lists all connected accounts based on provided filter criteria.
   *
   * This method retrieves connected accounts from the Composio API with optional filtering.
   *
   * @param {ConnectedAccountListParams} [query] - Optional query parameters for filtering connected accounts
   * @returns {Promise<ConnectedAccountListResponse>} A paginated list of connected accounts
   * @throws {ValidationError} If the query fails validation against the expected schema
   * @example
   * ```typescript
   * // List all connected accounts
   * const allAccounts = await composio.connectedAccounts.list();
   *
   * // List accounts for a specific user
   * const userAccounts = await composio.connectedAccounts.list({
   *   userIds: ['user123']
   * });
   *
   * // List accounts for a specific toolkit
   * const githubAccounts = await composio.connectedAccounts.list({
   *   toolkitSlugs: ['github']
   * });
   * ```
   */
  list(query?: ConnectedAccountListParams): Promise<ConnectedAccountListResponse>;
  /**
   * Compound function to create a new connected account.
   * This function creates a new connected account and returns a connection request.
   * Users can then wait for the connection to be established using the `waitForConnection` method.
   *
   * @param {string} userId - User ID of the connected account
   * @param {string} authConfigId - Auth config ID of the connected account
   * @param {CreateConnectedAccountOptions} options - Options for creating a new connected account
   * @returns {Promise<ConnectionRequest>} Connection request object
   *
   * @example
   * ```typescript
   * // For OAuth2 authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     callbackUrl: 'https://your-app.com/callback',
   *     config: AuthScheme.OAuth2({
   *       access_token: 'your_access_token',
   *       token_type: 'Bearer'
   *     })
   *   }
   * );
   *
   * // For API Key authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     config: AuthScheme.ApiKey({
   *       api_key: 'your_api_key'
   *     })
   *   }
   * );
   *
   * // For Basic authentication
   * const connectionRequest = await composio.connectedAccounts.initiate(
   *   'user_123',
   *   'auth_config_123',
   *   {
   *     config: AuthScheme.Basic({
   *       username: 'your_username',
   *       password: 'your_password'
   *     })
   *   }
   * );
   * ```
   *
   * @link https://docs.composio.dev/reference/connected-accounts/create-connected-account
   */
  initiate(userId: string, authConfigId: string, options?: CreateConnectedAccountOptions): Promise<ConnectionRequest>;
  /**
   * @description Create a Composio Connect Link for a user to connect their account to a given auth config. This method will return an external link which you can use the user to connect their account.
   *
   * @docs https://docs.composio.dev/reference/connected-accounts/create-connected-account#create-a-composio-connect-link
   *
   * @param userId {string} - The external user ID to create the connected account for.
   * @param authConfigId {string} - The auth config ID to create the connected account for.
   * @param options {CreateConnectedAccountOptions} - Options for creating a new connected account.
   * @param options.callbackUrl {string} - The url to redirect the user to post connecting their account.
   * @returns {ConnectionRequest} Connection request object
   *
   * @example
   * ```typescript
   * // create a connection request and redirect the user to the redirect url
   * const connectionRequest = await composio.connectedAccounts.link('user_123', 'auth_config_123');
   * const redirectUrl = connectionRequest.redirectUrl;
   * console.log(`Visit: ${redirectUrl} to authenticate your account`);
   *
   * // Wait for the connection to be established
   * const connectedAccount = await connectionRequest.waitForConnection()
   * ```
   *
   * @example
   * ```typescript
   * // create a connection request and redirect the user to the redirect url
   * const connectionRequest = await composio.connectedAccounts.link('user_123', 'auth_config_123', {
   *   callbackUrl: 'https://your-app.com/callback'
   * });
   * const redirectUrl = connectionRequest.redirectUrl;
   * console.log(`Visit: ${redirectUrl} to authenticate your account`);
   *
   * // Wait for the connection to be established
   * const connectedAccount = await composio.connectedAccounts.waitForConnection(connectionRequest.id);
   * ```
   */
  link(userId: string, authConfigId: string, options?: CreateConnectedAccountLinkOptions): Promise<ConnectionRequest>;
  /**
   * Waits for a connection request to complete and become active.
   *
   * This method continuously polls the Composio API to check the status of a connection
   * until it either becomes active, enters a terminal error state, or times out.
   *
   * @param {string} connectedAccountId - The ID of the connected account to wait for
   * @param {number} [timeout=60000] - Maximum time to wait in milliseconds (default: 60 seconds)
   * @returns {Promise<ConnectedAccountRetrieveResponse>} The finalized connected account data
   * @throws {ComposioConnectedAccountNotFoundError} If the connected account cannot be found
   * @throws {ConnectionRequestFailedError} If the connection enters a failed, expired, or deleted state
   * @throws {ConnectionRequestTimeoutError} If the connection does not complete within the timeout period
   *
   * @example
   * ```typescript
   * // Wait for a connection to complete with default timeout
   * const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc');
   *
   * // Wait with a custom timeout of 2 minutes
   * const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc', 120000);
   * ```
   */
  waitForConnection(connectedAccountId: string, timeout?: number): Promise<ConnectedAccountRetrieveResponse>;
  /**
   * Retrieves a specific connected account by its ID.
   *
   * This method fetches detailed information about a single connected account
   * and transforms the response to the SDK's standardized format.
   *
   * @param {string} nanoid - The unique identifier of the connected account
   * @returns {Promise<ConnectedAccountRetrieveResponse>} The connected account details
   * @throws {Error} If the connected account cannot be found or an API error occurs
   *
   * @example
   * ```typescript
   * // Get a connected account by ID
   * const account = await composio.connectedAccounts.get('conn_abc123');
   * console.log(account.status); // e.g., 'ACTIVE'
   * console.log(account.toolkit.slug); // e.g., 'github'
   * ```
   */
  get(nanoid: string): Promise<ConnectedAccountRetrieveResponse>;
  /**
   * Deletes a connected account.
   *
   * This method permanently removes a connected account from the Composio platform.
   * This action cannot be undone and will revoke any access tokens associated with the account.
   *
   * @param {string} nanoid - The unique identifier of the connected account to delete
   * @returns {Promise<ConnectedAccountDeleteResponse>} The deletion response
   * @throws {Error} If the account doesn't exist or cannot be deleted
   *
   * @example
   * ```typescript
   * // Delete a connected account
   * await composio.connectedAccounts.delete('conn_abc123');
   * ```
   */
  delete(nanoid: string): Promise<ConnectedAccountDeleteResponse>;
  /**
   * Refreshes a connected account's authentication credentials.
   *
   * This method attempts to refresh OAuth tokens or other credentials associated with
   * the connected account. This is useful when a token has expired or is about to expire.
   *
   * @param {string} nanoid - The unique identifier of the connected account to refresh
   * @returns {Promise<ConnectedAccountRefreshResponse>} The response containing the refreshed account details
   * @throws {Error} If the account doesn't exist or credentials cannot be refreshed
   *
   * @example
   * ```typescript
   * // Refresh a connected account's credentials
   * const refreshedAccount = await composio.connectedAccounts.refresh('conn_abc123');
   * ```
   */
  refresh(nanoid: string, options?: ConnectedAccountRefreshOptions): Promise<ConnectedAccountRefreshResponse>;
  /**
   * Update the status of a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @param {ConnectedAccountUpdateStatusParams} params - Parameters for updating the status
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Enable a connected account
   * const updatedAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   *   enabled: true
   * });
   *
   * // Disable a connected account with a reason
   * const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   *   enabled: false,
   *   reason: 'Token expired'
   * });
   * ```
   */
  updateStatus(nanoid: string, params: ConnectedAccountUpdateStatusParams): Promise<ConnectedAccountUpdateStatusResponse>;
  /**
   * Enable a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Enable a previously disabled connected account
   * const enabledAccount = await composio.connectedAccounts.enable('conn_abc123');
   * console.log(enabledAccount.isDisabled); // false
   * ```
   */
  enable(nanoid: string): Promise<ConnectedAccountUpdateStatusResponse>;
  /**
   * Disable a connected account
   * @param {string} nanoid - Unique identifier of the connected account
   * @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
   *
   * @example
   * ```typescript
   * // Disable a connected account
   * const disabledAccount = await composio.connectedAccounts.disable('conn_abc123');
   * console.log(disabledAccount.isDisabled); // true
   *
   * // You can also use updateStatus with a reason
   * // const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
   * //   enabled: false,
   * //   reason: 'No longer needed'
   * // });
   * ```
   */
  disable(nanoid: string): Promise<ConnectedAccountUpdateStatusResponse>;
}
//#endregion
//#region src/types/mcp.experimental.types.d.ts
declare const MCPServerInstanceSchema: z.ZodObject<{
  id: z.ZodString;
  name: z.ZodString;
  type: z.ZodLiteral<"streamable_http">;
  url: z.ZodString;
  userId: z.ZodString;
  allowedTools: z.ZodArray<z.ZodString, "many">;
  authConfigs: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
  name: string;
  type: "streamable_http";
  userId: string;
  id: string;
  allowedTools: string[];
  url: string;
  authConfigs: string[];
}, {
  name: string;
  type: "streamable_http";
  userId: string;
  id: string;
  allowedTools: string[];
  url: string;
  authConfigs: string[];
}>;
type MCPServerInstance = z.infer<typeof MCPServerInstanceSchema>;
declare const MCPConfigCreationParamsSchema: z.ZodObject<{
  toolkits: z.ZodArray<z.ZodUnion<[z.ZodObject<{
    toolkit: z.ZodOptional<z.ZodString>;
    authConfigId: z.ZodOptional<z.ZodString>;
  }, "strip", z.ZodTypeAny, {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  }, {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  }>, z.ZodString]>, "many">;
  allowedTools: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
  manuallyManageConnections: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
  toolkits: (string | {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  })[];
  allowedTools?: string[] | undefined;
  manuallyManageConnections?: boolean | undefined;
}, {
  toolkits: (string | {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  })[];
  allowedTools?: string[] | undefined;
  manuallyManageConnections?: boolean | undefined;
}>;
type MCPConfigCreationParams = z.infer<typeof MCPConfigCreationParamsSchema>;
declare const MCPConfigResponseSchema: z.ZodObject<{
  /**
   * Unique identifier for the newly created custom MCP server
   */
  id: z.ZodString;
  /**
   * Human-readable name of the custom MCP server
   */
  name: z.ZodString;
  /**
   * List of tool identifiers that are enabled for this server
   */
  allowedTools: z.ZodArray<z.ZodString, "many">;
  /**
   * ID references to the auth configurations used by this server
   */
  authConfigIds: z.ZodArray<z.ZodString, "many">;
  /**
   * Set of command line instructions for connecting various clients to this MCP server
   */
  commands: z.ZodObject<{
    /**
     * Command line instruction for Claude client setup
     */
    claude: z.ZodString;
    /**
     * Command line instruction for Cursor client setup
     */
    cursor: z.ZodString;
    /**
     * Command line instruction for Windsurf client setup
     */
    windsurf: z.ZodString;
  }, "strip", z.ZodTypeAny, {
    cursor: string;
    claude: string;
    windsurf: string;
  }, {
    cursor: string;
    claude: string;
    windsurf: string;
  }>;
  /**
   * URL endpoint for establishing Server-Sent Events (SSE) connection to this MCP server
   */
  MCPUrl: z.ZodString;
}, "strip", z.ZodTypeAny, {
  name: string;
  authConfigIds: string[];
  id: string;
  allowedTools: string[];
  commands: {
    cursor: string;
    claude: string;
    windsurf: string;
  };
  MCPUrl: string;
}, {
  name: string;
  authConfigIds: string[];
  id: string;
  allowedTools: string[];
  commands: {
    cursor: string;
    claude: string;
    windsurf: string;
  };
  MCPUrl: string;
}>;
type MCPConfigResponse = z.infer<typeof MCPConfigResponseSchema>;
interface MCPConfigCreateResponse extends MCPConfigResponse {
  /**
   * Creates an instance for a user of the specific MCP Server/COnfig
   * @param userId {string}
   * @returns {MCPServerInstance}
   */
  generate: (userId: string) => Promise<MCPServerInstance>;
}
declare const MCPGetInstanceParamsSchema: z.ZodObject<{
  manuallyManageConnections: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
}, "strip", z.ZodTypeAny, {
  manuallyManageConnections?: boolean | undefined;
}, {
  manuallyManageConnections?: boolean | undefined;
}>;
type MCPGetInstanceParams = z.infer<typeof MCPGetInstanceParamsSchema>;
declare const MCPListParamsSchema: z.ZodObject<{
  page: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
  limit: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
  toolkits: z.ZodDefault<z.ZodOptional<z.ZodArray<z.ZodString, "many">>>;
  authConfigs: z.ZodDefault<z.ZodOptional<z.ZodArray<z.ZodString, "many">>>;
  name: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  toolkits: string[];
  limit: number;
  page: number;
  authConfigs: string[];
  name?: string | undefined;
}, {
  name?: string | undefined;
  toolkits?: string[] | undefined;
  limit?: number | undefined;
  page?: number | undefined;
  authConfigs?: string[] | undefined;
}>;
type MCPListParams = z.infer<typeof MCPListParamsSchema>;
declare const MCPItemSchema: z.ZodObject<{
  /**
   * Unique identifier for the newly created custom MCP server
   */
  id: z.ZodString;
  /**
   * Human-readable name of the custom MCP server
   */
  name: z.ZodString;
  /**
   * List of tool identifiers that are enabled for this server
   */
  allowedTools: z.ZodArray<z.ZodString, "many">;
  /**
   * ID references to the auth configurations used by this server
   */
  authConfigIds: z.ZodArray<z.ZodString, "many">;
  /**
   * Set of command line instructions for connecting various clients to this MCP server
   */
  commands: z.ZodObject<{
    /**
     * Command line instruction for Claude client setup
     */
    claude: z.ZodString;
    /**
     * Command line instruction for Cursor client setup
     */
    cursor: z.ZodString;
    /**
     * Command line instruction for Windsurf client setup
     */
    windsurf: z.ZodString;
  }, "strip", z.ZodTypeAny, {
    cursor: string;
    claude: string;
    windsurf: string;
  }, {
    cursor: string;
    claude: string;
    windsurf: string;
  }>;
  /**
   * URL endpoint for establishing Server-Sent Events (SSE) connection to this MCP server
   */
  MCPUrl: z.ZodString;
} & {
  toolkitIcons: z.ZodRecord<z.ZodString, z.ZodString>;
  serverInstanceCount: z.ZodNumber;
  toolkits: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
  name: string;
  toolkits: string[];
  authConfigIds: string[];
  id: string;
  allowedTools: string[];
  commands: {
    cursor: string;
    claude: string;
    windsurf: string;
  };
  MCPUrl: string;
  toolkitIcons: Record<string, string>;
  serverInstanceCount: number;
}, {
  name: string;
  toolkits: string[];
  authConfigIds: string[];
  id: string;
  allowedTools: string[];
  commands: {
    cursor: string;
    claude: string;
    windsurf: string;
  };
  MCPUrl: string;
  toolkitIcons: Record<string, string>;
  serverInstanceCount: number;
}>;
type MCPItem = z.infer<typeof MCPItemSchema>;
declare const MCPListResponseSchema: z.ZodObject<{
  items: z.ZodArray<z.ZodObject<{
    /**
     * Unique identifier for the newly created custom MCP server
     */
    id: z.ZodString;
    /**
     * Human-readable name of the custom MCP server
     */
    name: z.ZodString;
    /**
     * List of tool identifiers that are enabled for this server
     */
    allowedTools: z.ZodArray<z.ZodString, "many">;
    /**
     * ID references to the auth configurations used by this server
     */
    authConfigIds: z.ZodArray<z.ZodString, "many">;
    /**
     * Set of command line instructions for connecting various clients to this MCP server
     */
    commands: z.ZodObject<{
      /**
       * Command line instruction for Claude client setup
       */
      claude: z.ZodString;
      /**
       * Command line instruction for Cursor client setup
       */
      cursor: z.ZodString;
      /**
       * Command line instruction for Windsurf client setup
       */
      windsurf: z.ZodString;
    }, "strip", z.ZodTypeAny, {
      cursor: string;
      claude: string;
      windsurf: string;
    }, {
      cursor: string;
      claude: string;
      windsurf: string;
    }>;
    /**
     * URL endpoint for establishing Server-Sent Events (SSE) connection to this MCP server
     */
    MCPUrl: z.ZodString;
  } & {
    toolkitIcons: z.ZodRecord<z.ZodString, z.ZodString>;
    serverInstanceCount: z.ZodNumber;
    toolkits: z.ZodArray<z.ZodString, "many">;
  }, "strip", z.ZodTypeAny, {
    name: string;
    toolkits: string[];
    authConfigIds: string[];
    id: string;
    allowedTools: string[];
    commands: {
      cursor: string;
      claude: string;
      windsurf: string;
    };
    MCPUrl: string;
    toolkitIcons: Record<string, string>;
    serverInstanceCount: number;
  }, {
    name: string;
    toolkits: string[];
    authConfigIds: string[];
    id: string;
    allowedTools: string[];
    commands: {
      cursor: string;
      claude: string;
      windsurf: string;
    };
    MCPUrl: string;
    toolkitIcons: Record<string, string>;
    serverInstanceCount: number;
  }>, "many">;
  currentPage: z.ZodNumber;
  totalPages: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
  items: {
    name: string;
    toolkits: string[];
    authConfigIds: string[];
    id: string;
    allowedTools: string[];
    commands: {
      cursor: string;
      claude: string;
      windsurf: string;
    };
    MCPUrl: string;
    toolkitIcons: Record<string, string>;
    serverInstanceCount: number;
  }[];
  totalPages: number;
  currentPage: number;
}, {
  items: {
    name: string;
    toolkits: string[];
    authConfigIds: string[];
    id: string;
    allowedTools: string[];
    commands: {
      cursor: string;
      claude: string;
      windsurf: string;
    };
    MCPUrl: string;
    toolkitIcons: Record<string, string>;
    serverInstanceCount: number;
  }[];
  totalPages: number;
  currentPage: number;
}>;
type MCPListResponse = z.infer<typeof MCPListResponseSchema>;
declare const MCPUpdateParamsSchema: z.ZodObject<{
  name: z.ZodOptional<z.ZodString>;
  toolkits: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodObject<{
    toolkit: z.ZodOptional<z.ZodString>;
    authConfigId: z.ZodOptional<z.ZodString>;
  }, "strip", z.ZodTypeAny, {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  }, {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  }>, z.ZodString]>, "many">>;
  allowedTools: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
  manuallyManageConnections: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
  name?: string | undefined;
  toolkits?: (string | {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  })[] | undefined;
  allowedTools?: string[] | undefined;
  manuallyManageConnections?: boolean | undefined;
}, {
  name?: string | undefined;
  toolkits?: (string | {
    toolkit?: string | undefined;
    authConfigId?: string | undefined;
  })[] | undefined;
  allowedTools?: string[] | undefined;
  manuallyManageConnections?: boolean | undefined;
}>;
type MCPUpdateParams = z.infer<typeof MCPUpdateParamsSchema>;
//#endregion
//#region src/models/MCP.d.ts
/**
 * MCP (Model Control Protocol) class
 * Handles MCP server operations.
 * When `config.experimental.mcp` is enabled, this class augments the features of `composio.mcp`.
 */
declare class MCP {
  client: Composio;
  constructor(client: Composio);
  /**
   * Create a new MCP configuration.
   * @param {Object} params - Parameters for creating the MCP configuration
   * @param {Array} params.authConfig - Array of auth configurations with id and allowed tools
   * @param {Object} params.options - Configuration options
   * @param {string} params.options.name - Unique name for the MCP configuration
   * @param {boolean} [params.options.manuallyManageConnections] - Whether to use chat-based authentication or manually connect accounts
   * @returns {Promise<McpServerCreateResponse<T>>} Created server details with instance getter
   *
   * @example
   * ```typescript
   * const server = await composio.mcpConfig.create("personal-mcp-server", {
   *   toolkits: ["github", "slack"],
   *   allowedTools: ["GMAIL_FETCH_EMAILS", "SLACK_SEND_MESSAGE"],
   *   manuallyManageConnections: false
   *  }
   * });
   *
   * const server = await composio.mcpConfig.create("personal-mcp-server", {
   *   toolkits: [{ toolkit: "gmail", authConfigId: "ac_243434343" }],
   *   allowedTools: ["GMAIL_FETCH_EMAILS"],
   *   manuallyManageConnections: false
   *  }
   * });
   * ```
   */
  create(name: string, mcpConfig: MCPConfigCreationParams): Promise<MCPConfigCreateResponse>;
  /**
   * List the MCP servers with optional filtering and pagination
   * @param {Object} options - Filtering and pagination options
   * @param {number} [options.page=1] - Page number for pagination (1-based)
   * @param {number} [options.limit=10] - Maximum number of items to return per page
   * @param {string[]} [options.toolkits=[]] - Array of toolkit names to filter by
   * @param {string[]} [options.authConfigs=[]] - Array of auth configuration IDs to filter by
   * @param {string} [options.name] - Filter by MCP server name (partial match)
   * @returns {Promise<MCPListResponse>} Paginated list of MCP servers with metadata
   *
   * @example
   * ```typescript
   * // List all MCP servers
   * const allServers = await composio.experimental.mcp.list({});
   *
   * // List with pagination
   * const pagedServers = await composio.experimental.mcp.list({
   *   page: 2,
   *   limit: 5
   * });
   *
   * // Filter by toolkit
   * const githubServers = await composio.experimental.mcp.list({
   *   toolkits: ['github', 'slack']
   * });
   *
   * // Filter by name
   * const namedServers = await composio.experimental.mcp.list({
   *   name: 'personal'
   * });
   * ```
   */
  list(options: MCPListParams): Promise<MCPListResponse>;
  /**
   * Retrieve detailed information about a specific MCP server by its ID
   * @param {string} serverId - The unique identifier of the MCP server to retrieve
   * @returns {Promise<MCPItem>} Complete MCP server details including configuration, tools, and metadata
   *
   * @example
   * ```typescript
   * // Get a specific MCP server by ID
   * const server = await composio.experimental.mcp.get("mcp_12345");
   *
   * console.log(server.name); // "My Personal MCP Server"
   * console.log(server.allowedTools); // ["GITHUB_CREATE_ISSUE", "SLACK_SEND_MESSAGE"]
   * console.log(server.toolkits); // ["github", "slack"]
   * console.log(server.serverInstanceCount); // 3
   *
   * // Access setup commands for different clients
   * console.log(server.commands.claude); // Claude setup command
   * console.log(server.commands.cursor); // Cursor setup command
   * console.log(server.commands.windsurf); // Windsurf setup command
   *
   * // Use the MCP URL for direct connections
   * const mcpUrl = server.MCPUrl;
   * ```
   *
   * @throws {ValidationError} When the server ID is invalid or server not found
   */
  get(serverId: string): Promise<MCPItem>;
  /**
   * Delete an MCP server configuration permanently
   * @param {string} serverId - The unique identifier of the MCP server to delete
   * @returns {Promise<{id: string; deleted: boolean}>} Confirmation object with server ID and deletion status
   *
   * @example
   * ```typescript
   * // Delete an MCP server by ID
   * const result = await composio.experimental.mcp.delete("mcp_12345");
   *
   * if (result.deleted) {
   *   console.log(`Server ${result.id} has been successfully deleted`);
   * } else {
   *   console.log(`Failed to delete server ${result.id}`);
   * }
   *
   * // Example with error handling
   * try {
   *   const result = await composio.experimental.mcp.delete("mcp_12345");
   *   console.log("Deletion successful:", result);
   * } catch (error) {
   *   console.error("Failed to delete MCP server:", error.message);
   * }
   *
   * // Delete and verify from list
   * await composio.experimental.mcp.delete("mcp_12345");
   * const servers = await composio.experimental.mcp.list({});
   * const serverExists = servers.items.some(server => server.id === "mcp_12345");
   * console.log("Server still exists:", serverExists); // Should be false
   * ```
   *
   * @throws {ValidationError} When the server ID is invalid or server not found
   * @throws {Error} When the server cannot be deleted due to active connections or other constraints
   *
   * @warning This operation is irreversible. Once deleted, the MCP server configuration and all its associated data will be permanently removed.
   */
  delete(serverId: string): Promise<{
    id: string;
    deleted: boolean;
  }>;
  /**
   * Update an existing MCP server configuration with new settings
   * @param {string} serverId - The unique identifier of the MCP server to update
   * @param {Object} config - Update configuration parameters
   * @param {string} [config.name] - New name for the MCP server
   * @param {Array} [config.toolkits] - Updated toolkit configurations
   * @param {string} [config.toolkits[].toolkit] - Toolkit identifier (e.g., "github", "slack")
   * @param {string} [config.toolkits[].authConfigId] - Auth configuration ID for the toolkit
   * @param {string[]} [config.toolkits[].allowedTools] - Specific tools to enable for this toolkit
   * @param {boolean} [config.manuallyManageConnections] - Whether to manually manage account connections
   * @returns {Promise<MCPItem>} Updated MCP server configuration with all details
   *
   * @example
   * ```typescript
   * // Update server name only
   * const updatedServer = await composio.experimental.mcp.update("mcp_12345", {
   *   name: "My Updated MCP Server"
   * });
   *
   * // Update toolkits and tools
   * const serverWithNewTools = await composio.experimental.mcp.update("mcp_12345", {
   *   toolkits: [
   *     {
   *       toolkit: "github",
   *       authConfigId: "auth_abc123",
   *       allowedTools: ["GITHUB_CREATE_ISSUE", "GITHUB_LIST_REPOS"]
   *     },
   *     {
   *       toolkit: "slack",
   *       authConfigId: "auth_xyz789",
   *       allowedTools: ["SLACK_SEND_MESSAGE", "SLACK_LIST_CHANNELS"]
   *     }
   *   ]
   * });
   *
   * // Update connection management setting
   * const serverWithManualAuth = await composio.experimental.mcp.update("mcp_12345", {
   *   name: "Manual Auth Server",
   *   manuallyManageConnections: true
   * });
   *
   * // Complete update example
   * const fullyUpdatedServer = await composio.experimental.mcp.update("mcp_12345", {
   *   name: "Production MCP Server",
   *   toolkits: [
   *     {
   *       toolkit: "gmail",
   *       authConfigId: "auth_gmail_prod",
   *     }
   *   ],
   *   allowedTools: ["GMAIL_SEND_EMAIL", "GMAIL_FETCH_EMAILS"]
   *   manuallyManageConnections: false
   * });
   *
   * console.log("Updated server:", fullyUpdatedServer.name);
   * console.log("New tools:", fullyUpdatedServer.allowedTools);
   * ```
   *
   * @throws {ValidationError} When the update parameters are invalid or malformed
   * @throws {Error} When the server ID doesn't exist or update fails
   *
   * @note Only provided fields will be updated. Omitted fields will retain their current values.
   * @note When updating toolkits, the entire toolkit configuration is replaced, not merged.
   */
  update(serverId: string, config: MCPUpdateParams): Promise<MCPItem>;
  /**
   * Get server URLs for an existing MCP server.
   * The response is wrapped according to the provider's specifications.
   *
   * @example
   * ```typescript
   * import { Composio } from "@composio/code";
   *
   * const composio = new Composio();
   * const mcp = await composio.experimental.mcp.generate("default", "<mcp_config_id>");
   * ```
   *
   * @param userId {string} external user id from your database for whom you want the server for
   * @param mcpConfigId {string} config id of the MCPConfig for which you want to create a server for
   * @param options {object} additional options
   * @param options.isChatAuth {boolean} Authenticate the users via chat when they use the MCP Server
   */
  generate(userId: string, mcpConfigId: string, options?: MCPGetInstanceParams): Promise<MCPServerInstance>;
}
//#endregion
//#region src/provider/OpenAIProvider.d.ts
type OpenAiTool = OpenAI.ChatCompletionTool;
type OpenAiToolCollection = Array<OpenAiTool>;
declare class OpenAIProvider extends BaseNonAgenticProvider<OpenAiToolCollection, OpenAiTool, McpServerGetResponse> {
  readonly name = "openai";
  /**
   * Creates a new instance of the OpenAIProvider.
   *
   * This is the default provider for the Composio SDK and is automatically
   * available without additional installation.
   *
   * @example
   * ```typescript
   * // The OpenAIProvider is used by default when initializing Composio
   * const composio = new Composio({
   *   apiKey: 'your-api-key'
   * });
   *
   * // You can also explicitly specify it
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   provider: new OpenAIProvider()
   * });
   * ```
   */
  constructor();
  /**
   * Transform MCP URL response into OpenAI-specific format.
   * OpenAI uses the standard format by default.
   *
   * @param data - The MCP URL response data
   * @returns Standard MCP server response format
   */
  wrapMcpServerResponse(data: McpUrlResponse): McpServerGetResponse;
  /**
   * Wraps a Composio tool in the OpenAI function calling format.
   *
   * This method transforms a Composio tool definition into the format
   * expected by OpenAI's function calling API.
   *
   * @param tool - The Composio tool to wrap
   * @returns The wrapped tool in OpenAI format
   *
   * @example
   * ```typescript
   * // Wrap a single tool for use with OpenAI
   * const composioTool = {
   *   slug: 'SEARCH_TOOL',
   *   description: 'Search for information',
   *   inputParameters: {
   *     type: 'object',
   *     properties: {
   *       query: { type: 'string' }
   *     },
   *     required: ['query']
   *   }
   * };
   *
   * const openAITool = provider.wrapTool(composioTool);
   * ```
   */
  wrapTool: (tool: Tool) => OpenAiTool;
  /**
   * Wraps multiple Composio tools in the OpenAI function calling format.
   *
   * This method transforms a list of Composio tools into the format
   * expected by OpenAI's function calling API.
   *
   * @param tools - Array of Composio tools to wrap
   * @returns Array of wrapped tools in OpenAI format
   *
   * @example
   * ```typescript
   * // Wrap multiple tools for use with OpenAI
   * const composioTools = [
   *   {
   *     slug: 'SEARCH_TOOL',
   *     description: 'Search for information',
   *     inputParameters: {
   *       type: 'object',
   *       properties: {
   *         query: { type: 'string' }
   *       }
   *     }
   *   },
   *   {
   *     slug: 'WEATHER_TOOL',
   *     description: 'Get weather information',
   *     inputParameters: {
   *       type: 'object',
   *       properties: {
   *         location: { type: 'string' }
   *       }
   *     }
   *   }
   * ];
   *
   * const openAITools = provider.wrapTools(composioTools);
   * ```
   */
  wrapTools: (tools: Tool[]) => OpenAiToolCollection;
  /**
   * Executes a tool call from OpenAI's chat completion.
   *
   * This method processes a tool call from OpenAI's chat completion API,
   * executes the corresponding Composio tool, and returns the result.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.ChatCompletionMessageToolCall} tool - The tool call from OpenAI
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<string>} The result of the tool call as a JSON string
   *
   * @example
   * ```typescript
   * // Execute a tool call from OpenAI
   * const toolCall = {
   *   id: 'call_abc123',
   *   type: 'function',
   *   function: {
   *     name: 'SEARCH_TOOL',
   *     arguments: '{"query":"composio documentation"}'
   *   }
   * };
   *
   * const result = await provider.executeToolCall(
   *   'user123',
   *   toolCall,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   * console.log(JSON.parse(result));
   * ```
   */
  executeToolCall(userId: string, tool: OpenAI.ChatCompletionMessageFunctionToolCall, options?: ExecuteToolFnOptions, modifiers?: ExecuteToolModifiers): Promise<string>;
  /**
   * Handles tool calls from OpenAI's chat completion response.
   *
   * This method processes tool calls from an OpenAI chat completion response,
   * executes each tool call, and returns the results.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.ChatCompletion} chatCompletion - The chat completion response from OpenAI
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<string[]>} Array of tool execution results as JSON strings
   *
   * @example
   * ```typescript
   * // Handle tool calls from a chat completion response
   * const chatCompletion = {
   *   choices: [
   *     {
   *       message: {
   *         tool_calls: [
   *           {
   *             id: 'call_abc123',
   *             type: 'function',
   *             function: {
   *               name: 'SEARCH_TOOL',
   *               arguments: '{"query":"composio documentation"}'
   *             }
   *           }
   *         ]
   *       }
   *     }
   *   ]
   * };
   *
   * const results = await provider.handleToolCalls(
   *   'user123',
   *   chatCompletion,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   * console.log(results); // Array of tool execution results
   * ```
   */
  handleToolCalls(userId: string, chatCompletion: OpenAI.ChatCompletion, options?: ExecuteToolFnOptions, modifiers?: ExecuteToolModifiers): Promise<OpenAI.ChatCompletionToolMessageParam[]>;
  /**
   * Handles all the tool calls from the OpenAI Assistant API.
   *
   * This method processes tool calls from an OpenAI Assistant run,
   * executes each tool call, and returns the tool outputs for submission.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. This method will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI.Beta.Threads.Run} run - The Assistant run object containing tool calls
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput[]>} Array of tool outputs for submission
   *
   *
   * @example
   * ```typescript
   * // Handle tool calls from an OpenAI Assistant run
   * const run = {
   *   id: 'run_abc123',
   *   required_action: {
   *     submit_tool_outputs: {
   *       tool_calls: [
   *         {
   *           id: 'call_xyz789',
   *           type: 'function',
   *           function: {
   *             name: 'SEARCH_TOOL',
   *             arguments: '{"query":"composio documentation"}'
   *           }
   *         }
   *       ]
   *     }
   *   }
   * };
   *
   * const toolOutputs = await provider.handleAssistantMessage(
   *   'user123',
   *   run,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Submit tool outputs back to OpenAI
   * await openai.beta.threads.runs.submitToolOutputs(
   *   thread.id,
   *   run.id,
   *   { tool_outputs: toolOutputs }
   * );
   * ```
   */
  handleAssistantMessage(userId: string, run: OpenAI.Beta.Threads.Run, options?: ExecuteToolFnOptions, modifiers?: ExecuteToolModifiers): Promise<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput[]>;
  /**
   * Waits for the assistant stream and handles the tool calls.
   *
   * This method processes an OpenAI Assistant stream, handles any tool calls
   * that require action, and yields each event from the stream. It's designed
   * for streaming Assistant responses while handling tool calls in real-time.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI} client - The OpenAI client instance
   * @param {Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>} runStream - The Assistant run stream
   * @param {OpenAI.Beta.Threads.Thread} thread - The thread object
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {AsyncGenerator<OpenAI.Beta.Assistants.AssistantStreamEvent, void, unknown>} Generator yielding stream events
   *
   *
   *
   * @example
   * ```typescript
   * // Process an OpenAI Assistant stream with tool calls
   * const thread = await openai.beta.threads.create();
   * const runStream = openai.beta.threads.runs.stream(thread.id, {
   *   assistant_id: 'asst_abc123',
   *   tools: provider.wrapTools(composioTools)
   * });
   *
   * // Process the stream and handle tool calls
   * const streamProcessor = provider.waitAndHandleAssistantStreamToolCalls(
   *   'user123',
   *   openai,
   *   runStream,
   *   thread,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Consume the stream events
   * for await (const event of streamProcessor) {
   *   if (event.event === 'thread.message.delta') {
   *     console.log(event.data.delta.content);
   *   }
   * }
   * ```
   */
  waitAndHandleAssistantStreamToolCalls(userId: string, client: OpenAI, runStream: Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>, thread: OpenAI.Beta.Threads.Thread, options?: ExecuteToolFnOptions, modifiers?: ExecuteToolModifiers): AsyncGenerator<OpenAI.Beta.Assistants.AssistantStreamEvent, void, unknown>;
  /**
   * Waits for the assistant tool calls and handles them.
   *
   * This method polls an OpenAI Assistant run until it completes or requires action,
   * handles any tool calls, and returns the final run object. It's designed for
   * non-streaming Assistant interactions.
   *
   * @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
   *
   * @param {string} userId - The user ID for authentication and tracking
   * @param {OpenAI} client - The OpenAI client instance
   * @param {OpenAI.Beta.Threads.Run} run - The initial run object
   * @param {OpenAI.Beta.Threads.Thread} thread - The thread object
   * @param {ExecuteToolFnOptions} [options] - Optional execution options
   * @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
   * @returns {Promise<OpenAI.Beta.Threads.Run>} The final run object after completion
   *
   * @example
   * ```typescript
   * // Process an OpenAI Assistant run with tool calls
   * const thread = await openai.beta.threads.create();
   * await openai.beta.threads.messages.create(thread.id, {
   *   role: 'user',
   *   content: 'Find information about Composio'
   * });
   *
   * let run = await openai.beta.threads.runs.create(thread.id, {
   *   assistant_id: 'asst_abc123',
   *   tools: provider.wrapTools(composioTools)
   * });
   *
   * // Wait for the run to complete, handling any tool calls
   * run = await provider.waitAndHandleAssistantToolCalls(
   *   'user123',
   *   openai,
   *   run,
   *   thread,
   *   { connectedAccountId: 'conn_xyz456' }
   * );
   *
   * // Get the final messages after run completion
   * const messages = await openai.beta.threads.messages.list(thread.id);
   * console.log(messages.data[0].content);
   * ```
   */
  waitAndHandleAssistantToolCalls(userId: string, client: OpenAI, run: OpenAI.Beta.Threads.Run, thread: OpenAI.Beta.Threads.Thread, options?: ExecuteToolFnOptions, modifiers?: ExecuteToolModifiers): Promise<OpenAI.Beta.Threads.Runs.Run>;
}
//#endregion
//#region src/types/composio.types.d.ts
type ComposioRequestHeaders = Record<string, string>;
//#endregion
//#region src/types/toolRouter.types.d.ts
declare const MCPServerTypeSchema: z.ZodEnum<["http", "sse"]>;
type MCPServerType = z.infer<typeof MCPServerTypeSchema>;
declare const ToolRouterConfigManageConnectionsSchema: z.ZodObject<{
  enable: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
  callbackUrl: z.ZodOptional<z.ZodString>;
  waitForConnections: z.ZodOptional<z.ZodBoolean>;
}, "strict", z.ZodTypeAny, {
  callbackUrl?: string | undefined;
  enable?: boolean | undefined;
  waitForConnections?: boolean | undefined;
}, {
  callbackUrl?: string | undefined;
  enable?: boolean | undefined;
  waitForConnections?: boolean | undefined;
}>;
declare const ToolRouterToolkitsParamSchema: z.ZodArray<z.ZodString, "many">;
declare const ToolRouterToolkitsDisabledConfigSchema: z.ZodObject<{
  disable: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
  disable: string[];
}, {
  disable: string[];
}>;
declare const ToolRouterToolkitsEnabledConfigSchema: z.ZodObject<{
  enable: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
  enable: string[];
}, {
  enable: string[];
}>;
declare const ToolRouterManageConnectionsConfigSchema: z.ZodObject<{
  enable: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
  callbackUrl: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  enable: boolean;
  callbackUrl?: string | undefined;
}, {
  callbackUrl?: string | undefined;
  enable?: boolean | undefined;
}>;
declare const ToolRouterTagsParamSchema: z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">;
declare const ToolRouterTagsEnableDisableSchema: z.ZodObject<{
  enable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
  disable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
}, "strict", z.ZodTypeAny, {
  enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
}, {
  enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
}>;
declare const ToolRouterConfigTagsSchema: z.ZodUnion<[z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">, z.ZodObject<{
  enable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
  disable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
}, "strict", z.ZodTypeAny, {
  enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
}, {
  enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
}>]>;
type ToolRouterConfigTags = z.infer<typeof ToolRouterConfigTagsSchema>;
/**
 *  Tools config - Configure tools per toolkit using toolkit slug as key
 * @example
 * ```typescript
 *  {
 *      gmail: {
 *          enable: ['gmail_search', 'gmail_send']
 *      },
 *      slack: {
 *          disable: ['slack_delete_message']
 *      }
 *  }
 * ```
 *
 * @example
 * ```typescript
 *  {
 *      gmail: ['gmail_search', 'gmail_send'],
 *      slack: { tags: ['readOnlyHint'] }
 *  }
 * ```
 */
declare const ToolRouterToolsParamSchema: z.ZodArray<z.ZodString, "many">;
type ToolRouterToolsParam = z.infer<typeof ToolRouterToolsParamSchema>;
declare const ToolRouterConfigToolsSchema: z.ZodEffects<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodObject<{
  enable: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
  enable: string[];
}, {
  enable: string[];
}>, z.ZodObject<{
  disable: z.ZodArray<z.ZodString, "many">;
}, "strict", z.ZodTypeAny, {
  disable: string[];
}, {
  disable: string[];
}>, z.ZodObject<{
  tags: z.ZodUnion<[z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">, z.ZodObject<{
    enable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
    disable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
  }, "strict", z.ZodTypeAny, {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  }, {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  }>]>;
}, "strict", z.ZodTypeAny, {
  tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  };
}, {
  tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  };
}>]>, string[] | {
  enable: string[];
} | {
  disable: string[];
} | {
  tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  };
}, string[] | {
  enable: string[];
} | {
  disable: string[];
} | {
  tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  };
}>;
type ToolRouterConfigTools = z.infer<typeof ToolRouterConfigToolsSchema>;
declare const ToolRouterCreateSessionConfigSchema: z.ZodObject<{
  tools: z.ZodOptional<z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodEffects<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodObject<{
    enable: z.ZodArray<z.ZodString, "many">;
  }, "strict", z.ZodTypeAny, {
    enable: string[];
  }, {
    enable: string[];
  }>, z.ZodObject<{
    disable: z.ZodArray<z.ZodString, "many">;
  }, "strict", z.ZodTypeAny, {
    disable: string[];
  }, {
    disable: string[];
  }>, z.ZodObject<{
    tags: z.ZodUnion<[z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">, z.ZodObject<{
      enable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
      disable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
    }, "strict", z.ZodTypeAny, {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    }, {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    }>]>;
  }, "strict", z.ZodTypeAny, {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }, {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }>]>, string[] | {
    enable: string[];
  } | {
    disable: string[];
  } | {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }, string[] | {
    enable: string[];
  } | {
    disable: string[];
  } | {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }>]>>>>;
  tags: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">, z.ZodObject<{
    enable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
    disable: z.ZodOptional<z.ZodArray<z.ZodEnum<["readOnlyHint", "destructiveHint", "idempotentHint", "openWorldHint"]>, "many">>;
  }, "strict", z.ZodTypeAny, {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  }, {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  }>]>>>;
  toolkits: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodArray<z.ZodString, "many">, z.ZodObject<{
    disable: z.ZodArray<z.ZodString, "many">;
  }, "strict", z.ZodTypeAny, {
    disable: string[];
  }, {
    disable: string[];
  }>, z.ZodObject<{
    enable: z.ZodArray<z.ZodString, "many">;
  }, "strict", z.ZodTypeAny, {
    enable: string[];
  }, {
    enable: string[];
  }>]>>>;
  authConfigs: z.ZodOptional<z.ZodDefault<z.ZodRecord<z.ZodString, z.ZodString>>>;
  connectedAccounts: z.ZodOptional<z.ZodDefault<z.ZodRecord<z.ZodString, z.ZodString>>>;
  manageConnections: z.ZodOptional<z.ZodDefault<z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodObject<{
    enable: z.ZodOptional<z.ZodDefault<z.ZodBoolean>>;
    callbackUrl: z.ZodOptional<z.ZodString>;
    waitForConnections: z.ZodOptional<z.ZodBoolean>;
  }, "strict", z.ZodTypeAny, {
    callbackUrl?: string | undefined;
    enable?: boolean | undefined;
    waitForConnections?: boolean | undefined;
  }, {
    callbackUrl?: string | undefined;
    enable?: boolean | undefined;
    waitForConnections?: boolean | undefined;
  }>]>>>>;
  workbench: z.ZodOptional<z.ZodOptional<z.ZodObject<{
    enableProxyExecution: z.ZodOptional<z.ZodBoolean>;
    autoOffloadThreshold: z.ZodOptional<z.ZodNumber>;
  }, "strip", z.ZodTypeAny, {
    enableProxyExecution?: boolean | undefined;
    autoOffloadThreshold?: number | undefined;
  }, {
    enableProxyExecution?: boolean | undefined;
    autoOffloadThreshold?: number | undefined;
  }>>>;
  experimental: z.ZodOptional<z.ZodOptional<z.ZodObject<{
    assistivePrompt: z.ZodOptional<z.ZodObject<{
      userTimezone: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
      userTimezone?: string | undefined;
    }, {
      userTimezone?: string | undefined;
    }>>;
  }, "strip", z.ZodTypeAny, {
    assistivePrompt?: {
      userTimezone?: string | undefined;
    } | undefined;
  }, {
    assistivePrompt?: {
      userTimezone?: string | undefined;
    } | undefined;
  }>>>;
}, "strip", z.ZodTypeAny, {
  tags?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  } | undefined;
  tools?: Record<string, string[] | {
    enable: string[];
  } | {
    disable: string[];
  } | {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }> | undefined;
  toolkits?: string[] | {
    disable: string[];
  } | {
    enable: string[];
  } | undefined;
  authConfigs?: Record<string, string> | undefined;
  connectedAccounts?: Record<string, string> | undefined;
  manageConnections?: boolean | {
    callbackUrl?: string | undefined;
    enable?: boolean | undefined;
    waitForConnections?: boolean | undefined;
  } | undefined;
  workbench?: {
    enableProxyExecution?: boolean | undefined;
    autoOffloadThreshold?: number | undefined;
  } | undefined;
  experimental?: {
    assistivePrompt?: {
      userTimezone?: string | undefined;
    } | undefined;
  } | undefined;
}, {
  tags?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
    enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
  } | undefined;
  tools?: Record<string, string[] | {
    enable: string[];
  } | {
    disable: string[];
  } | {
    tags: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | {
      enable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
      disable?: ("readOnlyHint" | "destructiveHint" | "idempotentHint" | "openWorldHint")[] | undefined;
    };
  }> | undefined;
  toolkits?: string[] | {
    disable: string[];
  } | {
    enable: string[];
  } | undefined;
  authConfigs?: Record<string, string> | undefined;
  connectedAccounts?: Record<string, string> | undefined;
  manageConnections?: boolean | {
    callbackUrl?: string | undefined;
    enable?: boolean | undefined;
    waitForConnections?: boolean | undefined;
  } | undefined;
  workbench?: {
    enableProxyExecution?: boolean | undefined;
    autoOffloadThreshold?: number | undefined;
  } | undefined;
  experimental?: {
    assistivePrompt?: {
      userTimezone?: string | undefined;
    } | undefined;
  } | undefined;
}>;
/**
 * The config for the tool router session.
 *
 * @param {ToolRouterToolkitsParamSchema | ToolRouterToolkitsDisabledConfigSchema | ToolRouterToolkitsEnabledConfigSchema} toolkits - The toolkits to use in the tool router session
 * @param {Record<string, ToolRouterToolsParam | ToolRouterConfigTools>} tools - The tools to configure per toolkit (key is toolkit slug)
 * @param {Array<'readOnlyHint' | 'destructiveHint' | 'idempotentHint' | 'openWorldHint'>} tags - Global tags to filter tools by behavior
 * @param {Record<string, string>} authConfigs - The auth configs to use in the tool router session
 * @param {Record<string, string>} connectedAccounts - The connected accounts to use in the tool router session
 * @param {ToolRouterConfigManageConnectionsSchema | boolean} manageConnections - The config for the manage connections in the tool router session. Defaults to true, if set to false, you need to manage connections manually. If set to an object, you can configure the manage connections settings.
 * @param {boolean} [manageConnections.enable] - Whether to use tools to manage connections in the tool router session @default true
 * @param {string} [manageConnections.callbackUrl] - The callback url to use in the tool router session
 * @param {object} workbench - Workbench configuration for tool execution
 * @param {boolean} [workbench.proxyExecutionEnabled] - Whether to enable proxy execution
 * @param {number} [workbench.autoOffloadThreshold] - Auto offload threshold in characters for moving execution to workbench
 */
type ToolRouterCreateSessionConfig = z.infer<typeof ToolRouterCreateSessionConfigSchema>;
declare const ToolkitConnectionStateSchema: z.ZodObject<{
  slug: z.ZodString;
  name: z.ZodString;
  logo: z.ZodOptional<z.ZodString>;
  isNoAuth: z.ZodDefault<z.ZodBoolean>;
  connection: z.ZodOptional<z.ZodObject<{
    isActive: z.ZodBoolean;
    authConfig: z.ZodOptional<z.ZodNullable<z.ZodObject<{
      id: z.ZodString;
      mode: z.ZodString;
      isComposioManaged: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    }, {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    }>>>;
    connectedAccount: z.ZodOptional<z.ZodObject<{
      id: z.ZodString;
      status: z.ZodString;
    }, "strip", z.ZodTypeAny, {
      status: string;
      id: string;
    }, {
      status: string;
      id: string;
    }>>;
  }, "strip", z.ZodTypeAny, {
    isActive: boolean;
    authConfig?: {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    } | null | undefined;
    connectedAccount?: {
      status: string;
      id: string;
    } | undefined;
  }, {
    isActive: boolean;
    authConfig?: {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    } | null | undefined;
    connectedAccount?: {
      status: string;
      id: string;
    } | undefined;
  }>>;
}, "strip", z.ZodTypeAny, {
  slug: string;
  name: string;
  isNoAuth: boolean;
  logo?: string | undefined;
  connection?: {
    isActive: boolean;
    authConfig?: {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    } | null | undefined;
    connectedAccount?: {
      status: string;
      id: string;
    } | undefined;
  } | undefined;
}, {
  slug: string;
  name: string;
  logo?: string | undefined;
  isNoAuth?: boolean | undefined;
  connection?: {
    isActive: boolean;
    authConfig?: {
      id: string;
      isComposioManaged: boolean;
      mode: string;
    } | null | undefined;
    connectedAccount?: {
      status: string;
      id: string;
    } | undefined;
  } | undefined;
}>;
declare const ToolkitConnectionsDetailsSchema: z.ZodObject<{
  items: z.ZodArray<z.ZodObject<{
    slug: z.ZodString;
    name: z.ZodString;
    logo: z.ZodOptional<z.ZodString>;
    isNoAuth: z.ZodDefault<z.ZodBoolean>;
    connection: z.ZodOptional<z.ZodObject<{
      isActive: z.ZodBoolean;
      authConfig: z.ZodOptional<z.ZodNullable<z.ZodObject<{
        id: z.ZodString;
        mode: z.ZodString;
        isComposioManaged: z.ZodBoolean;
      }, "strip", z.ZodTypeAny, {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      }, {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      }>>>;
      connectedAccount: z.ZodOptional<z.ZodObject<{
        id: z.ZodString;
        status: z.ZodString;
      }, "strip", z.ZodTypeAny, {
        status: string;
        id: string;
      }, {
        status: string;
        id: string;
      }>>;
    }, "strip", z.ZodTypeAny, {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    }, {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    }>>;
  }, "strip", z.ZodTypeAny, {
    slug: string;
    name: string;
    isNoAuth: boolean;
    logo?: string | undefined;
    connection?: {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    } | undefined;
  }, {
    slug: string;
    name: string;
    logo?: string | undefined;
    isNoAuth?: boolean | undefined;
    connection?: {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    } | undefined;
  }>, "many">;
  nextCursor: z.ZodOptional<z.ZodString>;
  totalPages: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
  items: {
    slug: string;
    name: string;
    isNoAuth: boolean;
    logo?: string | undefined;
    connection?: {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    } | undefined;
  }[];
  totalPages: number;
  nextCursor?: string | undefined;
}, {
  items: {
    slug: string;
    name: string;
    logo?: string | undefined;
    isNoAuth?: boolean | undefined;
    connection?: {
      isActive: boolean;
      authConfig?: {
        id: string;
        isComposioManaged: boolean;
        mode: string;
      } | null | undefined;
      connectedAccount?: {
        status: string;
        id: string;
      } | undefined;
    } | undefined;
  }[];
  totalPages: number;
  nextCursor?: string | undefined;
}>;
type ToolkitConnectionsDetails = z.infer<typeof ToolkitConnectionsDetailsSchema>;
type ToolkitConnectionState = z.infer<typeof ToolkitConnectionStateSchema>;
declare const ToolRouterMCPServerConfigSchema: z.ZodObject<{
  type: z.ZodEnum<["http", "sse"]>;
  url: z.ZodString;
  headers: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
}, "strip", z.ZodTypeAny, {
  type: "http" | "sse";
  url: string;
  headers?: Record<string, string> | undefined;
}, {
  type: "http" | "sse";
  url: string;
  headers?: Record<string, string> | undefined;
}>;
type ToolRouterMCPServerConfig = z.infer<typeof ToolRouterMCPServerConfigSchema>;
type ToolRouterToolsFn<TToolCollection, TTool, TProvider extends BaseComposioProvider<TToolCollection, TTool, unknown>> = (modifiers?: SessionMetaToolOptions) => Promise<ReturnType<TProvider['wrapTools']>>;
type ToolRouterAuthorizeFn = (toolkit: string, options?: {
  callbackUrl?: string;
}) => Promise<ConnectionRequest>;
declare const ToolRouterToolkitsOptionsSchema: z.ZodObject<{
  toolkits: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
  nextCursor: z.ZodOptional<z.ZodString>;
  limit: z.ZodOptional<z.ZodNumber>;
  isConnected: z.ZodOptional<z.ZodBoolean>;
  search: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
  nextCursor?: string | undefined;
  toolkits?: string[] | undefined;
  limit?: number | undefined;
  search?: string | undefined;
  isConnected?: boolean | undefined;
}, {
  nextCursor?: string | undefined;
  toolkits?: string[] | undefined;
  limit?: number | undefined;
  search?: string | undefined;
  isConnected?: boolean | undefined;
}>;
type ToolRouterToolkitsOptions = z.infer<typeof ToolRouterToolkitsOptionsSchema>;
type ToolRouterToolkitsFn = (options?: ToolRouterToolkitsOptions) => Promise<ToolkitConnectionsDetails>;
/**
 * Experimental features response from session creation.
 * Only returned on session creation, not on GET.
 */
interface ToolRouterSessionExperimental {
  /**
   * The assistive system prompt to inject into your agent for optimal tool router usage.
   */
  assistivePrompt?: string;
}
interface ToolRouterSession<TToolCollection, TTool, TProvider extends BaseComposioProvider<TToolCollection, TTool, unknown>> {
  /**
   * The session id of the tool router session.
   */
  sessionId: string;
  /**
   * The MCP server config of the tool router session.
   * Contains the URL, type ('http' or 'sse'), and headers for authentication.
   */
  mcp: ToolRouterMCPServerConfig;
  /**
   * Get the tools available in the session, formatted for your AI framework.
   * Requires a provider to be configured in the Composio constructor.
   */
  tools: ToolRouterToolsFn<TToolCollection, TTool, TProvider>;
  /**
   * Initiate an authorization flow for a toolkit.
   * Returns a ConnectionRequest with a redirect URL for the user.
   */
  authorize: ToolRouterAuthorizeFn;
  /**
   * Query the connection state of toolkits in the session.
   * Supports pagination and filtering by toolkit slugs.
   */
  toolkits: ToolRouterToolkitsFn;
  /**
   * Experimental features including the generated system prompt.
   * Only returned on session creation, not on GET.
   */
  experimental?: ToolRouterSessionExperimental;
}
//#endregion
//#region src/models/ToolRouter.d.ts
declare class ToolRouter<TToolCollection, TTool, TProvider extends BaseComposioProvider<TToolCollection, TTool, unknown>> {
  private client;
  private config?;
  constructor(client: Composio, config?: ComposioConfig<TProvider> | undefined);
  /**
   * Creates a function that authorizes a toolkit for a user.
   * @param sessionId {string} The session id to create the authorize function for
   * @returns {ToolRouterAuthorizeFn} The authorize function
   *
   */
  private createAuthorizeFn;
  /**
   *
   * @param sessionId {string} The session id to create the toolkits function for
   * @returns {ToolRouterToolkitsFn} The toolkits function
   *
   * @example
   * ```typescript
   * import { Composio } from '@composio/core';
   *
   * const composio = new Composio();
   * const session = await composio.toolRouter.use('session_123');
   *
   * const toolkits = await session.toolkits();
   * console.log(toolkits);
   * ```
   */
  private createToolkitsFn;
  /**
   * @internal
   * Creates a function that wraps the tools based on the provider.
   * The returned tools will be of the type the frameworks expects.
   *
   * @param sessionId - The session id to get the tools for
   * @returns A function that wraps the tools based on the provider with session-specific modifiers.
   */
  private createToolsFn;
  /**
   * Creates a MCP server config object.
   * @param type {MCPServerType} The type of the MCP server
   * @param url {string} The URL of the MCP server
   * @returns {ToolRouterMCPServerConfig} The MCP server config object
   */
  private createMCPServerConfig;
  /**
   * Creates a new tool router session for a user.
   *
   * @param userId {string} The user id to create the session for
   * @param config {ToolRouterCreateSessionConfig} The config for the tool router session
   * @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
   *
   * @example
   * ```typescript
   * import { Composio } from '@composio/core';
   *
   * const composio = new Composio();
   * const userId = 'user_123';
   *
   * const session = await composio.experimental.create(userId, {
   *   toolkits: ['gmail'],
   *   manageConnections: true,
   *   tools: {
   *     gmail: {
   *       disabled: ['gmail_send_email']
   *     }
   *   },
   *   tags: ['readOnlyHint']
   * });
   *
   * console.log(session.sessionId);
   * console.log(session.mcp.url);
   *
   * // Get tools formatted for your framework (requires provider)
   * const tools = await session.tools();
   *
   * // Check toolkit connection states
   * const toolkits = await session.toolkits();
   * ```
   */
  create(userId: string, config?: ToolRouterCreateSessionConfig): Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>;
  /**
   * Use an existing session
   * @param id {string} The id of the session to use
   * @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
   *
   * @example
   * ```typescript
   * import { Composio } from '@composio/core';
   *
   * const composio = new Composio();
   * const id = 'session_123';
   * const session = await composio.toolRouter.use(id);
   *
   * console.log(session.mcp.url);
   * console.log(session.mcp.headers);
   * ```
   */
  use(id: string): Promise<Omit<ToolRouterSession<TToolCollection, TTool, TProvider>, 'experimental'>>;
}
//#endregion
//#region src/composio.d.ts
type ComposioConfig<TProvider extends BaseComposioProvider<unknown, unknown, unknown> = OpenAIProvider> = {
  /**
   * The API key for the Composio API.
   * @example 'sk-1234567890'
   */
  apiKey?: string | null;
  /**
   * The base URL of the Composio API.
   * @example 'https://backend.composio.dev'
   */
  baseURL?: string | null;
  /**
   * Whether to allow tracking for the Composio instance.
   * @example true, false
   * @default true
   */
  allowTracking?: boolean;
  /**
   * Whether to automatically upload and download files during tool execution.
   * @example true, false
   * @default true
   */
  autoUploadDownloadFiles?: boolean;
  /**
   * The tool provider to use for this Composio instance.
   * @example new OpenAIProvider()
   */
  provider?: TProvider;
  /**
   * The host service name of the SDK where the SDK is running.
   * This is used to identify the host for telemetry. Ignore it if you are not using telemetry.
   * @example 'mcp', 'apollo', ' etc
   */
  host?: string;
  /**
   * Request options to be passed to the Composio API client.
   * This is useful for passing in a custom fetch implementation.
   * @example
   * ```typescript
   * const composio = new Composio({
   *   defaultHeaders: {
   *      'x-request-id': '1234567890',
   *   },
   * });
   * ```
   */
  defaultHeaders?: ComposioRequestHeaders;
  /**
   * Whether to disable version check for the Composio SDK.
   * @example true, false
   * @default false
   */
  disableVersionCheck?: boolean;
  /**
   * The versions of the toolkits to use for tool execution and retrieval.
   * Omit to use 'latest' for all toolkits.
   *
   * **Version Control:**
   * When executing tools manually (via `tools.execute()`), if this resolves to "latest",
   * you must either:
   * - Set `dangerouslySkipVersionCheck: true` in the execute params (not recommended for production)
   * - Specify a concrete version here or in environment variables
   * - Pass a specific `version` parameter to the execute call
   *
   * Defaults to 'latest' if nothing is provided.
   * You can specify individual toolkit versions via environment variables: `COMPOSIO_TOOLKIT_VERSION_GITHUB=20250902_00`
   *
   * @example Global version for all toolkits, omit to use 'latest'
   * ```typescript
   * const composio = new Composio();
   * ```
   *
   * @example Specific versions for different toolkits (recommended for production)
   * ```typescript
   * const composio = new Composio({
   *   toolkitVersions: {
   *     github: '20250909_00',
   *     slack: '20250902_00'
   *   }
   * });
   * ```
   *
   * @example Set via environment variables
   * ```typescript
   * // Set environment variables:
   * // COMPOSIO_TOOLKIT_VERSION_GITHUB=20250909_00
   * // COMPOSIO_TOOLKIT_VERSION_SLACK=20250902_00
   * const composio = new Composio(); // Will use env variables
   * ```
   */
  toolkitVersions?: ToolkitVersionParam;
};
/**
 * This is the core class for Composio.
 * It is used to initialize the Composio SDK and provide a global configuration.
 */
declare class Composio$1<TProvider extends BaseComposioProvider<unknown, unknown, unknown> = OpenAIProvider> {
  /**
   * The Composio API client.
   * @type {ComposioClient}
   */
  protected client: ComposioClient;
  /**
   * The configuration for the Composio SDK.
   * @type {ComposioConfig<TProvider>}
   */
  private config;
  /**
   * Core models for Composio.
   */
  /** List, retrieve, and execute tools */
  tools: Tools<unknown, unknown, TProvider>;
  /** Retrieve toolkit metadata and authorize user connections */
  toolkits: Toolkits;
  /** Manage webhook triggers and event subscriptions */
  triggers: Triggers<TProvider>;
  /** The tool provider instance used for wrapping tools in framework-specific formats */
  provider: TProvider;
  /** Upload and download files */
  files: Files;
  /** Manage authentication configurations for toolkits */
  authConfigs: AuthConfigs;
  /** Manage authenticated connections */
  connectedAccounts: ConnectedAccounts;
  /** Model Context Protocol server management */
  mcp: MCP;
  /**
   * Experimental feature, use with caution
   * @experimental
   */
  toolRouter: ToolRouter<unknown, unknown, TProvider>;
  /**
   * Creates a new tool router session for a user.
   *
   * @param userId {string} The user id to create the session for
   * @param config {ToolRouterConfig} The config for the tool router session
   * @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
   *
   * @example
   * ```typescript
   * import { Composio } from '@composio/core';
   *
   * const composio = new Composio();
   * const userId = 'user_123';
   *
   * const session = await composio.create(userId, {
   *  manageConnections: true,
   * });
   *
   * console.log(session.sessionId);
   * console.log(session.url);
   * console.log(session.tools());
   * ```
   */
  create: (userId: string, routerConfig?: ToolRouterCreateSessionConfig) => Promise<ToolRouterSession<unknown, unknown, TProvider>>;
  /**
   * Use an existing tool router session
   *
   * @param id {string} The id of the session to use
   * @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
   */
  use: (id: string) => Promise<ToolRouterSession<unknown, unknown, TProvider>>;
  /**
   * Creates a new instance of the Composio SDK.
   *
   * The constructor initializes the SDK with the provided configuration options,
   * sets up the API client, and initializes all core models (tools, toolkits, etc.).
   *
   * @param {ComposioConfig<TProvider>} config - Configuration options for the Composio SDK
   * @param {string} [config.apiKey] - The API key for authenticating with the Composio API
   * @param {string} [config.baseURL] - The base URL for the Composio API (defaults to production URL)
   * @param {boolean} [config.allowTracking=true] - Whether to allow anonymous usage analytics
   * @param {TProvider} [config.provider] - The provider to use for this Composio instance (defaults to OpenAIProvider)
   *
   * @example
   * ```typescript
   * // Initialize with default configuration
   * const composio = new Composio();
   *
   * // Initialize with custom API key and base URL
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   baseURL: 'https://api.composio.dev'
   * });
   *
   * // Initialize with custom provider
   * const composio = new Composio({
   *   apiKey: 'your-api-key',
   *   provider: new CustomProvider()
   * });
   * ```
   */
  constructor(config?: ComposioConfig<TProvider>);
  /**
   * Get the Composio SDK client.
   * @returns {ComposioClient} The Composio API client.
   */
  getClient(): ComposioClient;
  /**
   * Get the configuration SDK is initialized with
   * @returns {ComposioConfig<TProvider>} The configuration SDK is initialized with
   */
  getConfig(): ComposioConfig<TProvider>;
  /**
   * Creates a new instance of the Composio SDK with custom request options while preserving the existing configuration.
   * This method is particularly useful when you need to:
   * - Add custom headers for specific requests
   * - Track request contexts with unique identifiers
   * - Override default request behavior for a subset of operations
   *
   * The new instance inherits all configuration from the parent instance (apiKey, baseURL, provider, etc.)
   * but allows you to specify custom request options that will be used for all API calls made through this session.
   *
   * @deprecated DEPRECATED: This method will be removed in a future version of the SDK.
   *
   * @param {MergedRequestInit} fetchOptions - Custom request options to be used for all API calls in this session.
   *                                          This follows the Fetch API RequestInit interface with additional options.
   * @returns {Composio<TProvider>} A new Composio instance with the custom request options applied.
   *
   * @example
   * ```typescript
   * // Create a base Composio instance
   * const composio = new Composio({
   *   apiKey: 'your-api-key'
   * });
   *
   * // Create a session with request tracking headers
   * const composioWithCustomHeaders = composio.createSession({
   *   headers: {
   *     'x-request-id': '1234567890',
   *     'x-correlation-id': 'session-abc-123',
   *     'x-custom-header': 'custom-value'
   *   }
   * });
   *
   * // Use the session for making API calls with the custom headers
   * await composioWithCustomHeaders.tools.list();
   * ```
   */
  createSession(options?: {
    headers?: ComposioRequestHeaders;
  }): Composio$1<TProvider>;
  /**
   * Flush any pending telemetry and wait for it to complete.
   *
   * In Node.js-compatible environments, telemetry is automatically flushed on process exit.
   * However, in environments like Cloudflare Workers that don't support process exit events,
   * you should call this method manually to ensure all telemetry is sent.
   *
   * @returns {Promise<void>} A promise that resolves when all pending telemetry has been sent.
   *
   * @example
   * ```typescript
   * // In a Cloudflare Worker, use ctx.waitUntil to ensure telemetry is flushed
   * export default {
   *   async fetch(request: Request, env: Env, ctx: ExecutionContext) {
   *     const composio = new Composio({ apiKey: env.COMPOSIO_API_KEY });
   *
   *     // Do your work...
   *     const result = await composio.tools.execute(...);
   *
   *     // Ensure telemetry flushes before worker terminates
   *     ctx.waitUntil(composio.flush());
   *
   *     return new Response(JSON.stringify(result));
   *   }
   * };
   * ```
   */
  flush(): Promise<void>;
}
//#endregion
export { TriggerInstanceUpsertParamsSchema as $, InputParamsSchema as $n, ConnectedAccountAuthConfigSchema as $t, ToolkitConnectionStateSchema as A, ToolkitAuthConfigDetails as An, AuthConfigListResponse as At, TriggerInstanceListActiveParams as B, ToolkitMangedByEnumSchema as Bn, AuthDefaultConfigUpdateParamsSchema as Bt, ToolRouterToolkitsOptions as C, DefaultCreateConnectedAccountParamsSchema as Cn, WebhookPayloadV3 as Ct, ToolRouterToolsParam as D, ToolKitListResponseSchema as Dn, AuthConfigCreationToolAccessConfigSchema as Dt, ToolRouterToolsFn as E, ToolKitListResponse as En, WebhookVersions as Et, IncomingTriggerPayload as F, ToolkitAuthFieldsResponseSchema as Fn, AuthConfigType as Ft, TriggerInstanceListActiveResponseSchema as G, ToolkitSortByEnum as Gn, CreateAuthConfigParamsSchema as Gt, TriggerInstanceListActiveResponse as H, ToolkitRetrieveCategoriesResponseSchema as Hn, AuthSchemeType as Ht, IncomingTriggerPayloadSchema as I, ToolkitCategory as In, AuthConfigTypes as It, TriggerInstanceManageUpdateParams as J, CustomToolInputParameter as Jn, CreateComposioManagedAuthConfigParamsSchema as Jt, TriggerInstanceManageDeleteResponse as K, ToolkitSortByEnumSchema as Kn, CreateAuthConfigResponse as Kt, TriggerData as L, ToolkitCategorySchema as Ln, AuthConfigUpdateParams as Lt, ToolkitConnectionsDetailsSchema as M, ToolkitAuthField as Mn, AuthConfigRetrieveResponse as Mt, OpenAIProvider as N, ToolkitAuthFieldSchema as Nn, AuthConfigRetrieveResponseSchema as Nt, ToolRouterToolsParamSchema as O, ToolKitMeta as On, AuthConfigListParams as Ot, MCP as P, ToolkitAuthFieldsResponse as Pn, AuthConfigToolAccessConfigSchema as Pt, TriggerInstanceUpsertParams as Q, ExecuteMetadata as Qn, ConnectedAccountAuthConfig as Qt, TriggerEvent as R, ToolkitListParams as Rn, AuthConfigUpdateParamsSchema as Rt, ToolRouterToolkitsFn as S, CreateConnectedAccountResponseSchema as Sn, WebhookPayloadV2Schema as St, ToolRouterToolkitsParamSchema as T, ToolKitItemSchema as Tn, WebhookVersion as Tt, TriggerInstanceListActiveResponseItem as U, ToolkitRetrieveResponse as Un, AuthSchemeTypes as Ut, TriggerInstanceListActiveParamsSchema as V, ToolkitRetrieveCategoriesResponse as Vn, AuthSchemeEnum as Vt, TriggerInstanceListActiveResponseItemSchema as W, ToolkitRetrieveResponseSchema as Wn, CreateAuthConfigParams as Wt, TriggerInstanceManageUpdateResponse as X, CustomToolRegistry as Xn, ConnectionRequest as Xt, TriggerInstanceManageUpdateParamsSchema as Y, CustomToolOptions as Yn, CreateCustomAuthConfigParamsSchema as Yt, TriggerInstanceManageUpdateResponseSchema as Z, CustomToolRegistryItem as Zn, ConnectionRequestState as Zt, ToolRouterSessionExperimental as _, CreateConnectedAccountOptions as _n, WebhookPayload as _t, ToolRouterAuthorizeFn as a, ConnectedAccountRefreshOptions as an, TriggerSubscribeParamSchema as at, ToolRouterToolkitsDisabledConfigSchema as b, CreateConnectedAccountParamsSchema as bn, WebhookPayloadV1Schema as bt, ToolRouterConfigTagsSchema as c, ConnectedAccountRetrieveResponseSchema as cn, TriggerTypeSchema as ct, ToolRouterCreateSessionConfig as d, ConnectedAccountStatusSchema as dn, TriggersTypeListResponse as dt, ConnectedAccountListParams as en, TriggerInstanceUpsertResponse as et, ToolRouterCreateSessionConfigSchema as f, ConnectedAccountStatuses as fn, TriggersTypeListResponseSchema as ft, ToolRouterSession as g, CreateConnectedAccountLinkResponseSchema as gn, VerifyWebhookResult as gt, ToolRouterManageConnectionsConfigSchema as h, CreateConnectedAccountLinkResponse as hn, VerifyWebhookParamsSchema as ht, MCPServerTypeSchema as i, ConnectedAccountListResponseSchema as in, TriggerStatuses as it, ToolkitConnectionsDetails as j, ToolkitAuthConfigDetailsSchema as jn, AuthConfigListResponseSchema as jt, ToolkitConnectionState as k, ToolKitMetaSchema as kn, AuthConfigListParamsSchema as kt, ToolRouterConfigTools as l, ConnectedAccountStatus as ln, TriggersTypeListParams as lt, ToolRouterMCPServerConfigSchema as m, CreateConnectedAccountLinkOptionsSchema as mn, VerifyWebhookParams as mt, ComposioConfig as n, ConnectedAccountListResponse as nn, TriggerStatusEnum as nt, ToolRouterConfigManageConnectionsSchema as o, ConnectedAccountRefreshOptionsSchema as on, TriggerSubscribeParams as ot, ToolRouterMCPServerConfig as p, CreateConnectedAccountLinkOptions as pn, TriggersTypeRetrieveResponse as pt, TriggerInstanceManageDeleteResponseSchema as q, ToolkitsListParamsSchema as qn, CreateAuthConfigResponseSchema as qt, MCPServerType as r, ConnectedAccountListResponseItem as rn, TriggerStatusType as rt, ToolRouterConfigTags as s, ConnectedAccountRetrieveResponse as sn, TriggerType as st, Composio$1 as t, ConnectedAccountListParamsSchema as tn, TriggerInstanceUpsertResponseSchema as tt, ToolRouterConfigToolsSchema as u, ConnectedAccountStatusEnum as un, TriggersTypeListParamsSchema as ut, ToolRouterTagsEnableDisableSchema as v, CreateConnectedAccountOptionsSchema as vn, WebhookPayloadSchema as vt, ToolRouterToolkitsOptionsSchema as w, ToolKitItem as wn, WebhookPayloadV3Schema as wt, ToolRouterToolkitsEnabledConfigSchema as x, CreateConnectedAccountResponse as xn, WebhookPayloadV2 as xt, ToolRouterTagsParamSchema as y, CreateConnectedAccountParams as yn, WebhookPayloadV1 as yt, TriggerEventData as z, ToolkitMangedByEnum as zn, AuthCustomConfigUpdateParamsSchema as zt };