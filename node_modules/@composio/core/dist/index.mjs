import "./chunk-Dx2NuYGI.mjs";
import { c as COMPOSIO_DIR, d as IS_DEVELOPMENT_OR_CI, g as getEnvsWithPrefix, h as getEnvVariable, l as COMPOSIO_LOG_LEVEL, m as constants_exports, o as ComposioError, p as USER_DATA_FILE_NAME, s as logger_default, t as arrayBufferToBase64, u as DEFAULT_BASE_URL } from "./buffer-BFpVRahf.mjs";
import { t as telemetry } from "./Telemetry-Bn5VseVi.mjs";
import ComposioClient, { APIError } from "@composio/client";
import { FileToolModifier } from "#file_tool_modifier";
import z, { ZodError, z as z$1 } from "zod/v3";
import * as zodToJsonSchema from "zod-to-json-schema";
import { CONFIG_DEFAULTS } from "#config_defaults";
import { APIError as APIError$1 } from "openai";
import { platform } from "#platform";
import semver from "semver";
import { Files } from "#files";
import { jsonSchemaToZod } from "@composio/json-schema-to-zod";

//#region src/types/authConfigs.types.ts
const AuthConfigTypes = {
	CUSTOM: "use_custom_auth",
	COMPOSIO_MANAGED: "use_composio_managed_auth"
};
const AuthSchemeTypes = {
	OAUTH1: "OAUTH1",
	OAUTH2: "OAUTH2",
	API_KEY: "API_KEY",
	BASIC: "BASIC",
	BEARER_TOKEN: "BEARER_TOKEN",
	BILLCOM_AUTH: "BILLCOM_AUTH",
	GOOGLE_SERVICE_ACCOUNT: "GOOGLE_SERVICE_ACCOUNT",
	NO_AUTH: "NO_AUTH",
	BASIC_WITH_JWT: "BASIC_WITH_JWT",
	CALCOM_AUTH: "CALCOM_AUTH",
	SERVICE_ACCOUNT: "SERVICE_ACCOUNT",
	SAML: "SAML",
	DCR_OAUTH: "DCR_OAUTH"
};
const AuthConfigCreationToolAccessConfigSchema = z$1.object({ toolsForConnectedAccountCreation: z$1.array(z$1.string()).optional() });
const AuthConfigToolAccessConfigSchema = z$1.object({
	toolsAvailableForExecution: z$1.array(z$1.string()).optional(),
	toolsForConnectedAccountCreation: z$1.array(z$1.string()).optional()
});
const AuthSchemeEnum = z$1.enum([
	"OAUTH2",
	"OAUTH1",
	"API_KEY",
	"BASIC",
	"BILLCOM_AUTH",
	"BEARER_TOKEN",
	"GOOGLE_SERVICE_ACCOUNT",
	"NO_AUTH",
	"BASIC_WITH_JWT",
	"CALCOM_AUTH",
	"SERVICE_ACCOUNT",
	"SAML",
	"DCR_OAUTH"
]);
const CreateCustomAuthConfigParamsSchema = z$1.object({
	type: z$1.literal("use_custom_auth"),
	name: z$1.string().optional(),
	credentials: z$1.record(z$1.string(), z$1.union([
		z$1.string(),
		z$1.number(),
		z$1.boolean()
	])),
	authScheme: AuthSchemeEnum,
	proxyConfig: z$1.object({
		proxyUrl: z$1.string(),
		proxyAuthKey: z$1.string().optional()
	}).optional(),
	toolAccessConfig: AuthConfigCreationToolAccessConfigSchema.optional(),
	isEnabledForToolRouter: z$1.boolean().optional()
});
const CreateComposioManagedAuthConfigParamsSchema = z$1.object({
	type: z$1.literal("use_composio_managed_auth"),
	name: z$1.string().optional(),
	credentials: z$1.object({
		scopes: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional(),
		user_scopes: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional()
	}).passthrough().optional(),
	toolAccessConfig: AuthConfigCreationToolAccessConfigSchema.optional(),
	isEnabledForToolRouter: z$1.boolean().optional()
});
/**
* Discriminated union of all possible auth config types.
*/
const CreateAuthConfigParamsSchema = z$1.discriminatedUnion("type", [CreateCustomAuthConfigParamsSchema, CreateComposioManagedAuthConfigParamsSchema]);
const CreateAuthConfigResponseSchema = z$1.object({
	id: z$1.string(),
	authScheme: z$1.string(),
	isComposioManaged: z$1.boolean(),
	toolkit: z$1.string()
});
const AuthConfigRetrieveResponseSchema = z$1.object({
	id: z$1.string(),
	name: z$1.string(),
	toolkit: z$1.object({
		logo: z$1.string(),
		slug: z$1.string()
	}),
	noOfConnections: z$1.number(),
	status: z$1.enum(["ENABLED", "DISABLED"]),
	uuid: z$1.string(),
	authScheme: AuthSchemeEnum.optional(),
	credentials: z$1.record(z$1.string(), z$1.unknown()).optional(),
	expectedInputFields: z$1.array(z$1.unknown()).optional(),
	isEnabledForToolRouter: z$1.boolean().optional(),
	restrictToFollowingTools: z$1.array(z$1.string()).optional(),
	isComposioManaged: z$1.boolean().optional(),
	createdBy: z$1.string().optional(),
	createdAt: z$1.string().optional(),
	lastUpdatedAt: z$1.string().optional(),
	toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
const AuthConfigListParamsSchema = z$1.object({
	cursor: z$1.string().optional(),
	isComposioManaged: z$1.boolean().optional(),
	limit: z$1.number().optional(),
	toolkit: z$1.string().optional()
});
const AuthConfigListResponseSchema = z$1.object({
	items: z$1.array(AuthConfigRetrieveResponseSchema),
	nextCursor: z$1.string().nullable(),
	totalPages: z$1.number()
});
const AuthCustomConfigUpdateParamsSchema = z$1.object({
	type: z$1.literal("custom"),
	credentials: z$1.object({
		scopes: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional(),
		user_scopes: z$1.union([z$1.string(), z$1.array(z$1.string())]).optional()
	}).passthrough().optional(),
	isEnabledForToolRouter: z$1.boolean().optional(),
	restrictToFollowingTools: z$1.array(z$1.string()).optional(),
	toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
const AuthDefaultConfigUpdateParamsSchema = z$1.object({
	type: z$1.literal("default"),
	scopes: z$1.string().optional(),
	isEnabledForToolRouter: z$1.boolean().optional(),
	restrictToFollowingTools: z$1.array(z$1.string()).optional(),
	toolAccessConfig: AuthConfigToolAccessConfigSchema.optional()
});
const AuthConfigUpdateParamsSchema = z$1.discriminatedUnion("type", [AuthCustomConfigUpdateParamsSchema, AuthDefaultConfigUpdateParamsSchema]);

//#endregion
//#region src/types/connectedAccountAuthStates.types.ts
const ConnectionStatuses = {
	INITIALIZING: "INITIALIZING",
	INITIATED: "INITIATED",
	ACTIVE: "ACTIVE",
	FAILED: "FAILED",
	EXPIRED: "EXPIRED",
	INACTIVE: "INACTIVE"
};
const RedirectableAuthSchemeSchema = z$1.enum([AuthSchemeTypes.OAUTH1, AuthSchemeTypes.OAUTH2]);
const BaseSchemeRaw = z$1.object({
	subdomain: z$1.string().optional(),
	["your-domain"]: z$1.string().optional(),
	region: z$1.string().optional(),
	shop: z$1.string().optional(),
	account_url: z$1.string().optional(),
	COMPANYDOMAIN: z$1.string().optional(),
	extension: z$1.string().optional(),
	form_api_base_url: z$1.string().optional(),
	instanceEndpoint: z$1.string().optional(),
	api_url: z$1.string().optional(),
	borneo_dashboard_url: z$1.string().optional(),
	proxy_username: z$1.string().optional(),
	proxy_password: z$1.string().optional(),
	domain: z$1.string().optional(),
	version: z$1.string().optional(),
	dc: z$1.string().optional(),
	site_name: z$1.string().optional(),
	instanceName: z$1.string().optional(),
	account_id: z$1.string().optional(),
	your_server: z$1.string().optional(),
	server_location: z$1.string().optional(),
	base_url: z$1.string().optional(),
	api_key: z$1.string().optional(),
	generic_api_key: z$1.string().optional(),
	bearer_token: z$1.string().optional(),
	basic_encoded: z$1.string().optional(),
	long_redirect_url: z$1.boolean().optional(),
	state_prefix: z$1.string().optional(),
	registration_access_token: z$1.string().optional(),
	registration_client_uri: z$1.string().optional(),
	composio_link_redirect_url: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth2InitiatingConnectionDataSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const Oauth2InitiatedConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.INITIATED),
	code_verifier: z$1.string().optional(),
	redirectUrl: z$1.string(),
	callback_url: z$1.string().optional(),
	finalRedirectUri: z$1.string().optional(),
	webhook_signature: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth2ActiveConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.ACTIVE),
	access_token: z$1.string(),
	id_token: z$1.string().optional(),
	token_type: z$1.string().optional(),
	refresh_token: z$1.string().nullish(),
	expires_in: z$1.union([
		z$1.string(),
		z$1.number(),
		z$1.null()
	]).optional(),
	scope: z$1.union([
		z$1.string(),
		z$1.array(z$1.string()),
		z$1.null()
	]).optional(),
	webhook_signature: z$1.string().optional(),
	authed_user: z$1.object({
		access_token: z$1.string().optional(),
		scope: z$1.string().optional()
	}).optional().describe("for slack user scopes")
}).catchall(z$1.unknown());
const Oauth2FailedConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.FAILED),
	error: z$1.string().optional(),
	error_description: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth2ExpiredConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.EXPIRED),
	expired_at: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth2InactiveConnectionDataSchema = Oauth2InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.INACTIVE),
	access_token: z$1.string(),
	id_token: z$1.string().optional(),
	token_type: z$1.string().optional(),
	refresh_token: z$1.string().nullish(),
	expires_in: z$1.union([
		z$1.string(),
		z$1.number(),
		z$1.null()
	]).optional(),
	scope: z$1.union([
		z$1.string(),
		z$1.array(z$1.string()),
		z$1.null()
	]).optional(),
	webhook_signature: z$1.string().optional(),
	authed_user: z$1.object({
		access_token: z$1.string().optional(),
		scope: z$1.string().optional()
	}).optional().describe("for slack user scopes")
}).catchall(z$1.unknown());
const Oauth2ConnectionDataSchema = z$1.discriminatedUnion("status", [
	Oauth2InitiatingConnectionDataSchema,
	Oauth2InitiatedConnectionDataSchema,
	Oauth2ActiveConnectionDataSchema,
	Oauth2FailedConnectionDataSchema,
	Oauth2ExpiredConnectionDataSchema,
	Oauth2InactiveConnectionDataSchema
]);
const CustomOauth2ConnectionDataSchema = Oauth2ActiveConnectionDataSchema.omit({ status: true });
const Oauth1InitiatingConnectionDataSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const Oauth1InitiatedConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.INITIATED),
	authUri: z$1.string(),
	oauth_token: z$1.string(),
	oauth_token_secret: z$1.string(),
	redirectUrl: z$1.string(),
	callbackUrl: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth1ActiveConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.ACTIVE),
	oauth_token: z$1.string(),
	oauth_token_secret: z$1.string(),
	consumer_key: z$1.string().optional(),
	oauth_verifier: z$1.string().optional(),
	redirectUrl: z$1.string().optional(),
	callback_url: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth1FailedConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.FAILED),
	error: z$1.string().optional(),
	error_description: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth1ExpiredConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.EXPIRED),
	expired_at: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth1InactiveConnectionDataSchema = Oauth1InitiatingConnectionDataSchema.extend({
	status: z$1.literal(ConnectionStatuses.INACTIVE),
	oauth_token: z$1.string(),
	oauth_token_secret: z$1.string(),
	consumer_key: z$1.string().optional(),
	oauth_verifier: z$1.string().optional(),
	redirectUrl: z$1.string().optional(),
	callback_url: z$1.string().optional()
}).catchall(z$1.unknown());
const Oauth1ConnectionDataSchema = z$1.discriminatedUnion("status", [
	Oauth1InitiatingConnectionDataSchema,
	Oauth1InitiatedConnectionDataSchema,
	Oauth1ActiveConnectionDataSchema,
	Oauth1FailedConnectionDataSchema,
	Oauth1ExpiredConnectionDataSchema,
	Oauth1InactiveConnectionDataSchema
]);
const CustomOauth1ConnectionDataSchema = Oauth1ActiveConnectionDataSchema.omit({ status: true });
const BillcomAuthInitiatingSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const BillcomAuthConnectionDataSchema = z$1.discriminatedUnion("status", [
	BillcomAuthInitiatingSchema,
	BillcomAuthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.INITIATED),
		redirectUrl: z$1.string()
	}).catchall(z$1.unknown()),
	BillcomAuthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		sessionId: z$1.string(),
		devKey: z$1.string()
	}).catchall(z$1.unknown()),
	BillcomAuthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	BillcomAuthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown()),
	BillcomAuthInitiatingSchema.extend({ status: z$1.literal(ConnectionStatuses.INACTIVE) }).catchall(z$1.unknown())
]);
const BasicBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const BasicConnectionDataSchema = z$1.discriminatedUnion("status", [
	BasicBaseSchema,
	BasicBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	BasicBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		username: z$1.string(),
		password: z$1.string()
	}).catchall(z$1.unknown()),
	BasicBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		username: z$1.string(),
		password: z$1.string()
	}).catchall(z$1.unknown()),
	BasicBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		username: z$1.string(),
		password: z$1.string(),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	BasicBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		username: z$1.string(),
		password: z$1.string(),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomBasicConnectionDataSchema = BaseSchemeRaw.extend({
	username: z$1.string(),
	password: z$1.string()
}).catchall(z$1.unknown());
const ApiKeyBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const ApiKeyConnectionDataSchema = z$1.discriminatedUnion("status", [
	ApiKeyBaseSchema,
	ApiKeyBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	ApiKeyBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		api_key: z$1.string().optional(),
		generic_api_key: z$1.string().optional()
	}).catchall(z$1.unknown()),
	ApiKeyBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		api_key: z$1.string().optional(),
		generic_api_key: z$1.string().optional()
	}).catchall(z$1.unknown()),
	ApiKeyBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	ApiKeyBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomApiKeyConnectionDataSchema = BaseSchemeRaw.extend({
	api_key: z$1.string().optional(),
	generic_api_key: z$1.string().optional()
}).catchall(z$1.unknown());
const BearerTokenBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const BearerTokenConnectionDataSchema = z$1.discriminatedUnion("status", [
	BearerTokenBaseSchema,
	BearerTokenBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	BearerTokenBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		token: z$1.string()
	}).catchall(z$1.unknown()),
	BearerTokenBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		token: z$1.string()
	}).catchall(z$1.unknown()),
	BearerTokenBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	BearerTokenBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomBearerTokenConnectionDataSchema = BaseSchemeRaw.extend({ token: z$1.string() }).catchall(z$1.unknown());
const GoogleServiceAccountBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const GoogleServiceAccountConnectionDataSchema = z$1.discriminatedUnion("status", [
	GoogleServiceAccountBaseSchema,
	GoogleServiceAccountBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INITIATED),
		redirectUrl: z$1.string(),
		composio_link_redirect_url: z$1.string().optional()
	}).catchall(z$1.unknown()),
	GoogleServiceAccountBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		credentials_json: z$1.string()
	}).catchall(z$1.unknown()),
	GoogleServiceAccountBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		credentials_json: z$1.string()
	}).catchall(z$1.unknown()),
	GoogleServiceAccountBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	GoogleServiceAccountBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const NoAuthBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const NoAuthConnectionDataSchema = z$1.discriminatedUnion("status", [
	NoAuthBaseSchema,
	NoAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	NoAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.ACTIVE) }).catchall(z$1.unknown()),
	NoAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INACTIVE) }).catchall(z$1.unknown()),
	NoAuthBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	NoAuthBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomNoAuthConnectionDataSchema = BaseSchemeRaw.catchall(z$1.unknown());
const CalcomAuthBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const CalcomAuthConnectionDataSchema = z$1.discriminatedUnion("status", [
	CalcomAuthBaseSchema,
	CalcomAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	CalcomAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.ACTIVE) }).catchall(z$1.unknown()),
	CalcomAuthBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INACTIVE) }).catchall(z$1.unknown()),
	CalcomAuthBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	CalcomAuthBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const BasicWithJwtBaseSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const BasicWithJwtConnectionDataSchema = z$1.discriminatedUnion("status", [
	BasicWithJwtBaseSchema,
	BasicWithJwtBaseSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	BasicWithJwtBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		username: z$1.string(),
		password: z$1.string()
	}).catchall(z$1.unknown()),
	BasicWithJwtBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		username: z$1.string(),
		password: z$1.string()
	}).catchall(z$1.unknown()),
	BasicWithJwtBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		username: z$1.string(),
		password: z$1.string(),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	BasicWithJwtBaseSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		username: z$1.string(),
		password: z$1.string(),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomBasicWithJwtConnectionDataSchema = BaseSchemeRaw.extend({
	username: z$1.string(),
	password: z$1.string()
}).catchall(z$1.unknown());
const ServiceAccountInitiatingSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const ServiceAccountConnectionDataSchema = z$1.discriminatedUnion("status", [
	ServiceAccountInitiatingSchema,
	ServiceAccountInitiatingSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	ServiceAccountInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		application_id: z$1.string(),
		installation_id: z$1.string(),
		private_key: z$1.string()
	}).catchall(z$1.unknown()),
	ServiceAccountInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		application_id: z$1.string(),
		installation_id: z$1.string(),
		private_key: z$1.string()
	}).catchall(z$1.unknown())
]);
const CustomServiceAccountConnectionDataSchema = z$1.object({
	application_id: z$1.string(),
	installation_id: z$1.string(),
	private_key: z$1.string()
}).merge(BaseSchemeRaw).catchall(z$1.unknown());
const SamlInitiatingSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const SamlConnectionDataSchema = z$1.discriminatedUnion("status", [
	SamlInitiatingSchema,
	SamlInitiatingSchema.extend({ status: z$1.literal(ConnectionStatuses.INITIATED) }).catchall(z$1.unknown()),
	SamlInitiatingSchema.extend({ status: z$1.literal(ConnectionStatuses.ACTIVE) }).catchall(z$1.unknown()),
	SamlInitiatingSchema.extend({ status: z$1.literal(ConnectionStatuses.INACTIVE) }).catchall(z$1.unknown()),
	SamlInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	SamlInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
BaseSchemeRaw.catchall(z$1.unknown());
const DcrOauthInitiatingSchema = BaseSchemeRaw.extend({ status: z$1.literal(ConnectionStatuses.INITIALIZING) }).catchall(z$1.unknown());
const DcrOauthConnectionDataSchema = z$1.discriminatedUnion("status", [
	DcrOauthInitiatingSchema,
	DcrOauthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.INITIATED),
		client_id: z$1.string(),
		redirectUrl: z$1.string(),
		client_secret: z$1.string().optional(),
		callback_url: z$1.string().optional(),
		client_id_issued_at: z$1.number().optional(),
		client_secret_expires_at: z$1.number().optional(),
		code_verifier: z$1.string().optional(),
		finalRedirectUri: z$1.string().optional()
	}).catchall(z$1.unknown()),
	DcrOauthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.ACTIVE),
		access_token: z$1.string(),
		client_id: z$1.string(),
		token_type: z$1.string().optional(),
		refresh_token: z$1.string().nullish(),
		expires_in: z$1.union([
			z$1.string(),
			z$1.number(),
			z$1.null()
		]).optional(),
		scope: z$1.union([
			z$1.string(),
			z$1.array(z$1.string()),
			z$1.null()
		]).optional(),
		id_token: z$1.string().optional(),
		client_secret: z$1.string().optional(),
		client_id_issued_at: z$1.number().optional(),
		client_secret_expires_at: z$1.number().optional()
	}).catchall(z$1.unknown()),
	DcrOauthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.INACTIVE),
		access_token: z$1.string(),
		client_id: z$1.string(),
		token_type: z$1.string().optional(),
		refresh_token: z$1.string().nullish(),
		expires_in: z$1.union([
			z$1.string(),
			z$1.number(),
			z$1.null()
		]).optional(),
		scope: z$1.union([
			z$1.string(),
			z$1.array(z$1.string()),
			z$1.null()
		]).optional(),
		id_token: z$1.string().optional(),
		client_secret: z$1.string().optional(),
		client_id_issued_at: z$1.number().optional(),
		client_secret_expires_at: z$1.number().optional()
	}).catchall(z$1.unknown()),
	DcrOauthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.FAILED),
		error: z$1.string().optional(),
		error_description: z$1.string().optional()
	}).catchall(z$1.unknown()),
	DcrOauthInitiatingSchema.extend({
		status: z$1.literal(ConnectionStatuses.EXPIRED),
		expired_at: z$1.string().optional()
	}).catchall(z$1.unknown())
]);
const CustomDcrOauthConnectionDataSchema = z$1.object({
	access_token: z$1.string(),
	client_id: z$1.string()
}).merge(BaseSchemeRaw).catchall(z$1.unknown());
const ConnectionDataSchema = z$1.discriminatedUnion("authScheme", [
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.OAUTH1),
		val: Oauth1ConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.OAUTH2),
		val: Oauth2ConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.API_KEY),
		val: ApiKeyConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BASIC),
		val: BasicConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BEARER_TOKEN),
		val: BearerTokenConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.GOOGLE_SERVICE_ACCOUNT),
		val: GoogleServiceAccountConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.NO_AUTH),
		val: NoAuthConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.CALCOM_AUTH),
		val: CalcomAuthConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BILLCOM_AUTH),
		val: BillcomAuthConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BASIC_WITH_JWT),
		val: BasicWithJwtConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.SERVICE_ACCOUNT),
		val: ServiceAccountConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.SAML),
		val: SamlConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.DCR_OAUTH),
		val: DcrOauthConnectionDataSchema
	})
]);
const CustomConnectionDataSchema = z$1.discriminatedUnion("authScheme", [
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.OAUTH2),
		toolkitSlug: z$1.string(),
		val: CustomOauth2ConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.DCR_OAUTH),
		toolkitSlug: z$1.string(),
		val: CustomDcrOauthConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.API_KEY),
		toolkitSlug: z$1.string(),
		val: CustomApiKeyConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BASIC_WITH_JWT),
		toolkitSlug: z$1.string(),
		val: CustomBasicWithJwtConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BASIC),
		toolkitSlug: z$1.string(),
		val: CustomBasicConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.BEARER_TOKEN),
		toolkitSlug: z$1.string(),
		val: CustomBearerTokenConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.OAUTH1),
		toolkitSlug: z$1.string(),
		val: CustomOauth1ConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.NO_AUTH),
		toolkitSlug: z$1.string(),
		val: CustomNoAuthConnectionDataSchema
	}),
	z$1.object({
		authScheme: z$1.literal(AuthSchemeTypes.SERVICE_ACCOUNT),
		toolkitSlug: z$1.string(),
		val: CustomServiceAccountConnectionDataSchema
	})
]);

//#endregion
//#region src/types/tool.types.ts
/**
* Toolkit is the collection of tools,
* A toolkit can be thought of as an app which provides a set of tools/actions/triggers.
*
* eg. Google Toolkit, which provides tools like Google Search, Google Maps, Google Translate, etc.
*/
const ToolkitSchema = z$1.object({
	slug: z$1.string().describe("The slug of the toolkit"),
	name: z$1.string().describe("The name of the toolkit"),
	logo: z$1.string().describe("The logo of the toolkit").optional()
});
const JSONSchemaType = z$1.enum([
	"string",
	"number",
	"integer",
	"boolean",
	"object",
	"array",
	"null"
]);
const JSONSchemaPropertySchema = z$1.object({
	type: z$1.union([JSONSchemaType, z$1.array(JSONSchemaType)]).optional(),
	description: z$1.string().optional(),
	anyOf: z$1.lazy(() => z$1.array(JSONSchemaPropertySchema)).optional(),
	oneOf: z$1.lazy(() => z$1.array(JSONSchemaPropertySchema)).optional(),
	allOf: z$1.lazy(() => z$1.array(JSONSchemaPropertySchema)).optional(),
	not: z$1.lazy(() => JSONSchemaPropertySchema).optional(),
	title: z$1.string().optional(),
	default: z$1.any().optional(),
	nullable: z$1.boolean().optional(),
	properties: z$1.lazy(() => z$1.record(z$1.string(), JSONSchemaPropertySchema)).optional(),
	required: z$1.array(z$1.string()).optional(),
	file_uploadable: z$1.boolean().optional(),
	file_downloadable: z$1.boolean().optional(),
	items: z$1.lazy(() => z$1.union([JSONSchemaPropertySchema, z$1.array(JSONSchemaPropertySchema)])).optional(),
	enum: z$1.array(z$1.any()).optional(),
	const: z$1.any().optional(),
	minimum: z$1.number().optional(),
	maximum: z$1.number().optional(),
	exclusiveMinimum: z$1.number().optional(),
	exclusiveMaximum: z$1.number().optional(),
	multipleOf: z$1.number().optional(),
	minLength: z$1.number().optional(),
	maxLength: z$1.number().optional(),
	pattern: z$1.string().optional(),
	format: z$1.string().optional(),
	minItems: z$1.number().optional(),
	maxItems: z$1.number().optional(),
	uniqueItems: z$1.boolean().optional(),
	minProperties: z$1.number().optional(),
	maxProperties: z$1.number().optional(),
	patternProperties: z$1.lazy(() => z$1.record(z$1.string(), JSONSchemaPropertySchema)).optional(),
	additionalProperties: z$1.union([z$1.boolean(), z$1.lazy(() => JSONSchemaPropertySchema)]).optional(),
	examples: z$1.array(z$1.any()).optional(),
	readOnly: z$1.boolean().optional(),
	writeOnly: z$1.boolean().optional(),
	if: z$1.lazy(() => JSONSchemaPropertySchema).optional(),
	then: z$1.lazy(() => JSONSchemaPropertySchema).optional(),
	else: z$1.lazy(() => JSONSchemaPropertySchema).optional(),
	$ref: z$1.string().optional(),
	definitions: z$1.record(z$1.string(), z$1.lazy(() => JSONSchemaPropertySchema)).optional(),
	$defs: z$1.record(z$1.string(), z$1.lazy(() => JSONSchemaPropertySchema)).optional()
});
const ParametersSchema = z$1.object({
	type: z$1.literal("object"),
	anyOf: z$1.array(JSONSchemaPropertySchema).optional(),
	oneOf: z$1.array(JSONSchemaPropertySchema).optional(),
	allOf: z$1.array(JSONSchemaPropertySchema).optional(),
	not: JSONSchemaPropertySchema.optional(),
	properties: z$1.record(z$1.string(), JSONSchemaPropertySchema),
	required: z$1.array(z$1.string()).optional(),
	title: z$1.string().optional(),
	default: z$1.any().optional(),
	nullable: z$1.boolean().optional(),
	description: z$1.string().optional(),
	additionalProperties: z$1.boolean().default(false).optional()
});
/**
* Tool is a single action that can be performed by a toolkit.
* Tool is simlar to an action that an app can perform.
*
* eg. Google Search, Google Maps, Google Translate, etc.
*/
const ToolSchema = z$1.object({
	slug: z$1.string().describe("The slug of the tool. eg. \"GOOGLE_SEARCH\""),
	name: z$1.string().describe(`The name of the tool. eg. "Google Search"`),
	description: z$1.string().optional().describe("The description of the tool"),
	inputParameters: ParametersSchema.optional().describe("The input parameters of the tool"),
	outputParameters: ParametersSchema.optional().describe("The output parameters of the tool"),
	tags: z$1.array(z$1.string()).describe("The tags of the tool. eg: Important").default([]).optional(),
	toolkit: ToolkitSchema.describe("The toolkit of the tool").optional(),
	version: z$1.string().describe("The version of the tool, e.g. \"20250909_00\"").optional(),
	isDeprecated: z$1.boolean().describe("Whether the tool is deprecated").optional(),
	availableVersions: z$1.array(z$1.string()).describe("Available versions of the tool.").default([]).optional(),
	scopes: z$1.array(z$1.string()).describe("The scopes of the tool. eg: [\"task:add\"]").optional(),
	isNoAuth: z$1.boolean().describe("Do the tool support no auth?").optional()
});
/**
* ToolListResponse Schema
*/
const ToolListResponseSchema = z$1.object({
	items: z$1.array(ToolSchema),
	nextCursor: z$1.string().nullable().optional(),
	totalPages: z$1.number()
});
const ToolkitLatestVersionSchema = z$1.literal("latest");
const ToolkitVersionSchema = z$1.union([ToolkitLatestVersionSchema, z$1.string()]);
const ToolkitVersionsSchema = z$1.record(z$1.string(), ToolkitVersionSchema);
const ToolkitVersionParamSchema = z$1.union([
	ToolkitVersionsSchema,
	ToolkitLatestVersionSchema,
	z$1.undefined()
]).describe("The versioning of the toolkits. eg: { \"github\": \"latest\", \"slack\": \"20250902_00\" }");
const ToolListParamsSchema = z$1.object({
	tools: z$1.array(z$1.string()).optional(),
	toolkits: z$1.array(z$1.string()).optional(),
	scopes: z$1.array(z$1.string()).optional(),
	tags: z$1.array(z$1.string()).optional(),
	limit: z$1.number().optional(),
	search: z$1.string().optional(),
	authConfigIds: z$1.array(z$1.string()).optional(),
	important: z$1.boolean().optional()
});
/**
* CustomAuthParams is the parameters for the custom authentication.
*/
const CustomAuthParamsSchema = z$1.object({
	baseURL: z$1.string().optional(),
	body: z$1.record(z$1.string(), z$1.unknown()).optional(),
	parameters: z$1.array(z$1.object({
		in: z$1.enum(["query", "header"]),
		name: z$1.string(),
		value: z$1.union([z$1.string(), z$1.number()])
	}))
});
/**
* Parameters for tool execution.
*
* @property {boolean} [allowTracing] - Enable tracing for this tool execution
* @property {string} [connectedAccountId] - The connected account ID to use for authenticated tools
* @property {CustomAuthParams} [customAuthParams] - Custom authentication parameters
* @property {CustomConnectionData} [customConnectionData] - Custom connection data (takes priority over customAuthParams)
* @property {Record<string, unknown>} [arguments] - The arguments to pass to the tool
* @property {string} [userId] - The user ID to execute the tool for (required for no-auth apps)
* @property {string} [version] - The specific version of the tool to execute (e.g., "20250909_00" or "latest")
* @property {boolean} [dangerouslySkipVersionCheck] - Skip version validation when using "latest" version.
*   **Warning:** This may cause unexpected behavior when new toolkit versions are released.
*   Only use this if you understand the risks. Recommended alternatives:
*   - Specify a concrete version in the `version` parameter
*   - Configure toolkit versions at SDK initialization level
*   - Set toolkit version via environment variable (COMPOSIO_TOOLKIT_VERSION_<TOOLKIT_SLUG>)
* @property {string} [text] - Additional text input for the tool
*
* @example Recommended: Execute with a specific version
* ```typescript
* const params: ToolExecuteParams = {
*   userId: 'default',
*   version: '20250909_00',
*   arguments: { owner: 'composio', repo: 'sdk' }
* };
* ```
*
* @example With dangerouslySkipVersionCheck (use with caution)
* ```typescript
* const params: ToolExecuteParams = {
*   userId: 'default',
*   dangerouslySkipVersionCheck: true,
*   arguments: { userId: 'pg' }
* };
* ```
*/
const ToolExecuteParamsSchema = z$1.object({
	allowTracing: z$1.boolean().optional(),
	connectedAccountId: z$1.string().optional(),
	customAuthParams: CustomAuthParamsSchema.optional(),
	customConnectionData: CustomConnectionDataSchema.optional(),
	arguments: z$1.record(z$1.string(), z$1.unknown()).optional(),
	userId: z$1.string().optional(),
	version: z$1.union([z$1.literal("latest"), z$1.string()]).optional(),
	dangerouslySkipVersionCheck: z$1.boolean().optional(),
	text: z$1.string().optional()
});
const ToolExecuteMetaParamsSchema = z$1.object({
	sessionId: z$1.string(),
	arguments: z$1.record(z$1.string(), z$1.unknown()).optional()
});
/**
* ToolResponse Schema
*/
const ToolExecuteResponseSchema = z$1.object({
	data: z$1.record(z$1.string(), z$1.unknown()),
	error: z$1.string().nullable(),
	successful: z$1.boolean(),
	logId: z$1.string().optional(),
	sessionInfo: z$1.unknown().optional()
});
const ToolProxyParamsSchema = z$1.object({
	endpoint: z$1.string(),
	method: z$1.enum([
		"GET",
		"POST",
		"PUT",
		"DELETE",
		"PATCH"
	]),
	body: z$1.unknown().optional(),
	parameters: z$1.array(z$1.object({
		in: z$1.enum(["query", "header"]),
		name: z$1.string(),
		value: z$1.union([z$1.string(), z$1.number()])
	})).optional(),
	connectedAccountId: z$1.string().optional(),
	customConnectionData: CustomConnectionDataSchema.describe("DEPRECATED: This field is deprecated and will be removed in the future.").optional()
});

//#endregion
//#region src/errors/ConnectedAccountsErrors.ts
const ConnectedAccountErrorCodes = {
	CONNECTED_ACCOUNT_NOT_FOUND: "CONNECTED_ACCOUNT_NOT_FOUND",
	MULTIPLE_CONNECTED_ACCOUNTS: "MULTIPLE_CONNECTED_ACCOUNTS",
	FAILED_TO_CREATE_CONNECTED_ACCOUNT_LINK: "FAILED_TO_CREATE_CONNECTED_ACCOUNT_LINK"
};
var ComposioConnectedAccountNotFoundError = class extends ComposioError {
	constructor(message = "Connected account not found", options = {}) {
		super(message, {
			...options,
			code: ConnectedAccountErrorCodes.CONNECTED_ACCOUNT_NOT_FOUND,
			statusCode: 404,
			possibleFixes: options.possibleFixes || ["Ensure the connected account exists and is active in your Composio dashboard"]
		});
		this.name = "ComposioConnectedAccountNotFoundError";
	}
};
var ComposioMultipleConnectedAccountsError = class extends ComposioError {
	constructor(message = "Multiple connected accounts found", options = {}) {
		super(message, {
			...options,
			code: ConnectedAccountErrorCodes.MULTIPLE_CONNECTED_ACCOUNTS,
			possibleFixes: options.possibleFixes || ["Use the allowMultiple flag to allow multiple connected accounts per user for an auth config"]
		});
		this.name = "ComposioMultipleConnectedAccountsError";
	}
};
var ComposioFailedToCreateConnectedAccountLink = class extends ComposioError {
	constructor(message = "Failed to create connected account link", options = {}) {
		super(message, {
			...options,
			code: ConnectedAccountErrorCodes.FAILED_TO_CREATE_CONNECTED_ACCOUNT_LINK
		});
		this.name = "ComposioFailedToCreateConnectedAccountLink";
	}
};

//#endregion
//#region src/errors/ToolErrors.ts
const ToolErrorCodes = {
	TOOLSET_NOT_DEFINED: "TOOLSET_NOT_DEFINED",
	TOOL_NOT_FOUND: "TOOL_NOT_FOUND",
	INVALID_MODIFIER: "INVALID_MODIFIER",
	CUSTOM_TOOLS_NOT_INITIALIZED: "CUSTOM_TOOLS_NOT_INITIALIZED",
	TOOL_EXECUTION_ERROR: "TOOL_EXECUTION_ERROR",
	INVALID_EXECUTE_FUNCTION: "INVALID_EXECUTE_FUNCTION",
	GLOBAL_EXECUTE_TOOL_FN_NOT_SET: "GLOBAL_EXECUTE_TOOL_FN_NOT_SET",
	TOOL_VERSION_REQUIRED: "TOOL_VERSION_REQUIRED"
};
var ComposioProviderNotDefinedError = class extends ComposioError {
	constructor(message = "Provider not defined", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.TOOLSET_NOT_DEFINED,
			possibleFixes: options.possibleFixes || ["Ensure that the provider is defined in the Composio project and passed into the tool instance"]
		});
		this.name = "ComposioProviderNotDefinedError";
	}
};
var ComposioToolNotFoundError = class extends ComposioError {
	constructor(message = "Tool not found", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.TOOL_NOT_FOUND,
			possibleFixes: options.possibleFixes || ["Ensure the tool slug is correct and exists in the Composio project"]
		});
		this.name = "ComposioToolNotFoundError";
	}
};
var ComposioInvalidModifierError = class extends ComposioError {
	constructor(message = "Invalid modifier", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.INVALID_MODIFIER,
			possibleFixes: options.possibleFixes || ["Ensure the modifier is a function and returns a valid result"]
		});
		this.name = "ComposioInvalidModifierError";
	}
};
var ComposioCustomToolsNotInitializedError = class extends ComposioError {
	constructor(message = "Custom tools not initialized", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.CUSTOM_TOOLS_NOT_INITIALIZED,
			possibleFixes: options.possibleFixes || ["Ensure the custom tools class is initialized in the Tools instance"]
		});
		this.name = "ComposioCustomToolsNotInitializedError";
	}
};
var ComposioToolExecutionError = class extends ComposioError {
	constructor(message = "Tool execution error", options = {}) {
		super(message, {
			...options,
			code: options.code || ToolErrorCodes.TOOL_EXECUTION_ERROR,
			cause: options.cause,
			possibleFixes: options.possibleFixes || ["Ensure the tool is correctly configured and the input is valid", "Ensure the userId is correct and has an active connected account for the user in case of non NoAuth toolkits"]
		});
		this.name = "ComposioToolExecutionError";
	}
};
var ComposioInvalidExecuteFunctionError = class extends ComposioError {
	constructor(message = "Invalid execute function", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.INVALID_EXECUTE_FUNCTION,
			possibleFixes: options.possibleFixes || ["Ensure the execute function is a valid function and returns a valid result"]
		});
		this.name = "ComposioInvalidExecuteFunctionError";
	}
};
var ComposioGlobalExecuteToolFnNotSetError = class extends ComposioError {
	constructor(message = "Global execute tool function not set", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.GLOBAL_EXECUTE_TOOL_FN_NOT_SET,
			possibleFixes: options.possibleFixes || ["Ensure the global execute tool function is set in the provider"]
		});
		this.name = "ComposioGlobalExecuteToolFnNotSetError";
	}
};
/**
* Error thrown when toolkit version is not specified for manual tool execution.
*
* This error is thrown when attempting to execute a tool manually (via `tools.execute()`)
* and the resolved version is "latest" without `dangerouslySkipVersionCheck` set to true.
*
* **Why this error exists:**
* Using "latest" version in manual execution can lead to unexpected behavior when new
* toolkit versions are released, potentially breaking your application. For production
* use, it's recommended to pin specific toolkit versions.
*
* **How to fix:**
* 1. Specify a concrete version in the execute call
* 2. Configure toolkit versions at SDK initialization
* 3. Set toolkit version via environment variable
* 4. Use dangerouslySkipVersionCheck (not recommended for production)
*
* @example ❌ This will throw ComposioToolVersionRequiredError if toolkitVersions is 'latest'
* ```typescript
* await composio.tools.execute('GITHUB_GET_REPOS', {
*   userId: 'default',
*   arguments: { owner: 'composio' }
* });
* ```
*
* @example ✅ Fix 1: Pass specific version in execute call
* ```typescript
* await composio.tools.execute('GITHUB_GET_REPOS', {
*   userId: 'default',
*   version: '20250909_00',
*   arguments: { owner: 'composio' }
* });
* ```
*
* @example ✅ Fix 2: Configure toolkit versions at SDK level
* ```typescript
* const composio = new Composio({
*   toolkitVersions: { github: '20250909_00' }
* });
* await composio.tools.execute('GITHUB_GET_REPOS', {
*   userId: 'default',
*   arguments: { owner: 'composio' }
* });
* ```
*
* @example ✅ Fix 3: Use environment variable
* ```typescript
* // Set: COMPOSIO_TOOLKIT_VERSION_GITHUB=20250909_00
* await composio.tools.execute('GITHUB_GET_REPOS', {
*   userId: 'default',
*   arguments: { owner: 'composio' }
* });
* ```
*
* @example ⚠️ Fix 4: Skip version check (not recommended for production)
* ```typescript
* await composio.tools.execute('GITHUB_GET_REPOS', {
*   userId: 'default',
*   dangerouslySkipVersionCheck: true,
*   arguments: { owner: 'composio' }
* });
* ```
*/
var ComposioToolVersionRequiredError = class extends ComposioError {
	constructor(message = "Toolkit version not specified. For manual execution of the tool please pass a specific toolkit version", options = {}) {
		super(message, {
			...options,
			code: ToolErrorCodes.TOOL_VERSION_REQUIRED,
			possibleFixes: options.possibleFixes || [
				"Pass the toolkit version as a parameter to the execute function (\"latest\" is not supported in manual execution)",
				"Set the toolkit versions in the Composio config (toolkitVersions: { <toolkit-slug>: \"<toolkit-version>\" })",
				"Set the toolkit version in the environment variable (COMPOSIO_TOOLKIT_VERSION_<TOOLKIT_SLUG>)",
				"Set dangerouslySkipVersionCheck to true (this might cause unexpected behavior when new versions of the tools are released)"
			]
		});
	}
};
const ERROR_CODE_HANDLERS = new Map([[1803, (msg) => new ComposioConnectedAccountNotFoundError(msg)]]);
const handleToolExecutionError = (tool, actualError) => {
	if (actualError instanceof APIError && actualError.error) {
		const errorBody = actualError.error;
		const errorCode = errorBody?.error?.code;
		const errorMessage = errorBody?.error?.message;
		if (errorCode && ERROR_CODE_HANDLERS.has(errorCode)) return ERROR_CODE_HANDLERS.get(errorCode)(errorMessage || "An error occurred");
	}
	return new ComposioToolExecutionError(`Error executing the tool ${tool}`, {
		cause: actualError,
		possibleFixes: ["Ensure the tool slug is correct and the input arguments for the tool is valid"]
	});
};

//#endregion
//#region src/errors/AuthConfigErrors.ts
const AuthConfigErrorCodes = { AUTH_CONFIG_NOT_FOUND: "AUTH_CONFIG_NOT_FOUND" };
var ComposioAuthConfigNotFoundError = class extends ComposioError {
	constructor(message = "Auth config not found", options = {}) {
		super(message, {
			...options,
			code: AuthConfigErrorCodes.AUTH_CONFIG_NOT_FOUND,
			possibleFixes: options.possibleFixes || [
				"Check if the auth config exists",
				"Check if the auth config id is correct",
				"Check if the auth config is enabled"
			]
		});
		this.name = "ComposioAuthConfigNotFoundError";
	}
};

//#endregion
//#region src/errors/ConnectionRequestErrors.ts
const ConnectionRequestErrorCodes = {
	CONNECTION_REQUEST_TIMEOUT: "CONNECTION_REQUEST_TIMEOUT",
	CONNECTION_REQUEST_FAILED: "CONNECTION_REQUEST_FAILED"
};
var ConnectionRequestTimeoutError = class extends ComposioError {
	constructor(message = "Connection request timed out", options = {}) {
		super(message, {
			...options,
			code: ConnectionRequestErrorCodes.CONNECTION_REQUEST_TIMEOUT
		});
		this.name = "ConnectionRequestTimeoutError";
	}
};
var ConnectionRequestFailedError = class extends ComposioError {
	constructor(message = "Connection request failed", options = {}) {
		super(message, {
			...options,
			code: ConnectionRequestErrorCodes.CONNECTION_REQUEST_FAILED
		});
		this.name = "ConnectionRequestFailedError";
	}
};

//#endregion
//#region src/errors/ToolkitErrors.ts
const ToolkitErrorCodes = { TOOLKIT_NOT_FOUND: "TOOLKIT_NOT_FOUND" };
var ComposioToolkitNotFoundError = class extends ComposioError {
	constructor(message = "Toolkit not found", options = {}) {
		super(message, {
			...options,
			code: "TOOLKIT_NOT_FOUND",
			possibleFixes: options.possibleFixes || ["Ensure the toolkit is correctly configured and the slug is valid"]
		});
		this.name = "ComposioToolkitNotFoundError";
	}
};
var ComposioToolkitFetchError = class extends ComposioError {
	constructor(message = "Failed to fetch toolkit", options = {}) {
		super(message, {
			...options,
			code: "TOOLKIT_FETCH_ERROR",
			possibleFixes: options.possibleFixes || [
				"Ensure the toolkit slug is valid",
				"Ensure you are using the correct API key",
				"Ensure you are using the correct API endpoint / Base URL and it is working"
			]
		});
		this.name = "ComposioToolkitFetchError";
	}
};

//#endregion
//#region src/errors/ValidationErrors.ts
/**
* Represents an input validation error using Zod.
*/
const ValidationErrorCodes = {
	VALIDATION_ERROR: "VALIDATION_ERROR",
	JSON_SCHEMA_TO_ZOD_ERROR: "JSON_SCHEMA_TO_ZOD_ERROR"
};
var ValidationError = class extends ComposioError {
	constructor(message = "Input validation failed", options = {}) {
		const { cause: providedZodError, ...restOptions } = options;
		let zodErrorInstance;
		if (providedZodError instanceof ZodError) zodErrorInstance = providedZodError;
		else zodErrorInstance = new ZodError([{
			path: [],
			message: "Invalid input",
			code: "custom"
		}]);
		const issues = zodErrorInstance.issues.map((issue) => `[${issue.code}] ${issue.path.join(".")} - ${issue.message}`);
		super(message, {
			...restOptions,
			code: options.code || ValidationErrorCodes.VALIDATION_ERROR,
			possibleFixes: issues,
			cause: zodErrorInstance
		});
		this.name = "ValidationError";
		this.message = `${message}: ${this.generateUserFriendlyMessage()}`;
	}
	generateUserFriendlyMessage() {
		if (this.cause instanceof ZodError && this.cause.issues.length > 0) {
			const issue = this.cause.issues[0];
			const param = issue.path.join(".") || "parameter";
			if (issue.code === "invalid_type") return `The ${param} should be a ${issue.expected}, but you provided a ${issue.received}`;
			return issue.message;
		}
		return "Please check your input parameters";
	}
};
var JsonSchemaToZodError = class extends ComposioError {
	constructor(message = "Failed to convert JSON schema to Zod schema", options = {}) {
		super(message, {
			...options,
			code: options.code || ValidationErrorCodes.JSON_SCHEMA_TO_ZOD_ERROR
		});
	}
};

//#endregion
//#region src/errors/SDKErrors.ts
const SDKErrorCodes = { NO_API_KEY_PROVIDED: "NO_API_KEY_PROVIDED" };
var ComposioNoAPIKeyError = class extends ComposioError {
	constructor(message = "No Composio API key provided", options = {}) {
		const defaultCause = "Couldn't find an API key in the params, environment variables or in the user config file";
		super(message, {
			...options,
			code: SDKErrorCodes.NO_API_KEY_PROVIDED,
			cause: options.cause || defaultCause,
			possibleFixes: options.possibleFixes || [
				"Ensure you have an API key passed in the params, or in environment variable (COMPOSIO_API_KEY) or in the user config file",
				"To get an API key, please sign up at https://composio.dev/signup",
				"You can also use the Composio CLI to create a project and get an API key"
			],
			statusCode: 401
		});
		this.name = "ComposioNoAPIKeyError";
	}
};

//#endregion
//#region src/errors/TriggerErrors.ts
const TriggerErrorCodes = {
	TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS: "TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS",
	TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT: "TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT",
	TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL: "TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL",
	TRIGGER_FAILED_TO_UNSUBSCRIBE_FROM_PUSHER_CHANNEL: "TRIGGER_FAILED_TO_UNSUBSCRIBE_FROM_PUSHER_CHANNEL",
	TRIGGER_TYPE_NOT_FOUND: "TRIGGER_TYPE_NOT_FOUND",
	WEBHOOK_SIGNATURE_VERIFICATION_FAILED: "WEBHOOK_SIGNATURE_VERIFICATION_FAILED",
	WEBHOOK_PAYLOAD_INVALID: "WEBHOOK_PAYLOAD_INVALID"
};
var ComposioFailedToGetSDKRealtimeCredentialsError = class extends ComposioError {
	constructor(message = "Failed to get SDK realtime credentials", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.TRIGGER_FAILED_TO_GET_SDK_REALTIME_CREDENTIALS,
			possibleFixes: options.possibleFixes || ["Please contact support."]
		});
		this.name = "ComposioFailedToGetSDKRealtimeCredentialsError";
	}
};
var ComposioFailedToCreatePusherClientError = class extends ComposioError {
	constructor(message = "Failed to create Pusher client", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.TRIGGER_FAILED_TO_CREATE_PUSHER_CLIENT,
			possibleFixes: options.possibleFixes || ["Please contact support."]
		});
		this.name = "ComposioFailedToCreatePusherClientError";
	}
};
var ComposioFailedToSubscribeToPusherChannelError = class extends ComposioError {
	constructor(message = "Failed to subscribe to Pusher channel", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.TRIGGER_FAILED_TO_SUBSCRIBE_TO_PUSHER_CHANNEL,
			possibleFixes: options.possibleFixes || ["Please contact support."]
		});
		this.name = "ComposioFailedToSubscribeToPusherChannelError";
	}
};
var ComposioFailedToUnsubscribeFromPusherChannelError = class extends ComposioError {
	constructor(message = "Failed to unsubscribe from Pusher channel", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.TRIGGER_FAILED_TO_UNSUBSCRIBE_FROM_PUSHER_CHANNEL,
			possibleFixes: options.possibleFixes || ["Please contact support."]
		});
		this.name = "ComposioFailedToUnsubscribeFromPusherChannelError";
	}
};
var ComposioTriggerTypeNotFoundError = class extends ComposioError {
	constructor(message = "Trigger type not found", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.TRIGGER_TYPE_NOT_FOUND,
			statusCode: 404,
			possibleFixes: options.possibleFixes || ["Please contact support."]
		});
		this.name = "ComposioTriggerTypeNotFoundError";
	}
};
var ComposioWebhookSignatureVerificationError = class extends ComposioError {
	constructor(message = "Webhook signature verification failed", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.WEBHOOK_SIGNATURE_VERIFICATION_FAILED,
			statusCode: 401,
			possibleFixes: options.possibleFixes || [
				"Verify that the webhook secret is correct.",
				"Ensure the raw request body is passed without modifications.",
				"Check that the signature header value is being passed correctly."
			]
		});
		this.name = "ComposioWebhookSignatureVerificationError";
	}
};
var ComposioWebhookPayloadError = class extends ComposioError {
	constructor(message = "Invalid webhook payload", options = {}) {
		super(message, {
			...options,
			code: TriggerErrorCodes.WEBHOOK_PAYLOAD_INVALID,
			statusCode: 400,
			possibleFixes: options.possibleFixes || ["Ensure the webhook payload is valid JSON.", "Verify the payload structure matches the expected format."]
		});
		this.name = "ComposioWebhookPayloadError";
	}
};

//#endregion
//#region src/types/connectedAccounts.types.ts
/**
* Connected Account create parameters
*/
const ConnectedAccountStatuses = {
	INITIALIZING: "INITIALIZING",
	INITIATED: "INITIATED",
	ACTIVE: "ACTIVE",
	FAILED: "FAILED",
	EXPIRED: "EXPIRED",
	INACTIVE: "INACTIVE"
};
const ConnectedAccountStatusSchema = z$1.enum([
	ConnectedAccountStatuses.INITIALIZING,
	ConnectedAccountStatuses.INITIATED,
	ConnectedAccountStatuses.ACTIVE,
	ConnectedAccountStatuses.FAILED,
	ConnectedAccountStatuses.EXPIRED,
	ConnectedAccountStatuses.INACTIVE
]);
const CreateConnectedAccountParamsSchema = z$1.object({
	authConfig: z$1.object({ id: z$1.string() }),
	connection: z$1.object({
		data: z$1.record(z$1.string(), z$1.unknown()).optional(),
		callbackUrl: z$1.string().optional(),
		userId: z$1.string().optional()
	})
});
const DefaultCreateConnectedAccountParamsSchema = z$1.object({
	auth_config: z$1.object({ id: z$1.string() }),
	connection: z$1.object({
		state: ConnectionDataSchema.optional(),
		data: z$1.record(z$1.string(), z$1.unknown()).optional(),
		callback_url: z$1.string().optional(),
		user_id: z$1.string().optional()
	})
});
const CreateConnectedAccountOptionsSchema = z$1.object({
	allowMultiple: z$1.boolean().optional(),
	callbackUrl: z$1.string().optional(),
	config: ConnectionDataSchema.optional()
});
/**
* Connected Account create response
*/
const CreateConnectedAccountResponseSchema = z$1.object({
	id: z$1.string(),
	status: ConnectedAccountStatusSchema,
	redirectUrl: z$1.string().nullable()
});
const ConnectedAccountAuthConfigSchema = z$1.object({
	id: z$1.string(),
	isComposioManaged: z$1.boolean(),
	isDisabled: z$1.boolean()
});
const ConnectedAccountRetrieveResponseSchema = z$1.object({
	id: z$1.string(),
	authConfig: ConnectedAccountAuthConfigSchema,
	data: z$1.record(z$1.string(), z$1.unknown()).optional(),
	params: z$1.record(z$1.string(), z$1.unknown()).optional(),
	status: ConnectedAccountStatusSchema,
	statusReason: z$1.string().nullable(),
	toolkit: z$1.object({ slug: z$1.string() }),
	state: ConnectionDataSchema.optional(),
	testRequestEndpoint: z$1.string().optional(),
	isDisabled: z$1.boolean(),
	createdAt: z$1.string(),
	updatedAt: z$1.string()
});
const ConnectedAccountListParamsSchema = z$1.object({
	authConfigIds: z$1.array(z$1.string()).nullable().optional().describe("The auth config ids of the connected accounts"),
	cursor: z$1.string().nullish().describe("The cursor to paginate through the connected accounts"),
	limit: z$1.number().nullable().optional().describe("The limit of the connected accounts to return"),
	orderBy: z$1.enum(["created_at", "updated_at"]).optional().describe("The order by of the connected accounts"),
	statuses: z$1.array(ConnectedAccountStatusSchema).nullable().optional().describe("The statuses of the connected accounts"),
	toolkitSlugs: z$1.array(z$1.string()).nullable().optional().describe("The toolkit slugs of the connected accounts"),
	userIds: z$1.array(z$1.string()).nullable().optional().describe("The user ids of the connected accounts")
});
const ConnectedAccountListResponseSchema = z$1.object({
	items: z$1.array(ConnectedAccountRetrieveResponseSchema).describe("The list of connected accounts"),
	nextCursor: z$1.string().nullish().describe("The next cursor to paginate through the connected accounts"),
	totalPages: z$1.number().describe("The total number of pages of connected accounts")
});
const CreateConnectedAccountLinkOptionsSchema = z$1.object({ callbackUrl: z$1.string().optional() });
const CreateConnectedAccountLinkResponseSchema = z$1.object({ redirectUrl: z$1.string() });
const ConnectedAccountRefreshOptionsSchema = z$1.object({
	redirectUrl: z$1.string().optional(),
	validateCredentials: z$1.boolean().optional()
});

//#endregion
//#region src/utils/transform.ts
function transform(raw) {
	return { with(schema) {
		return { using(transformer, options) {
			const transformed = transformer(raw);
			const result = schema.safeParse(transformed);
			if (!result.success) {
				logger_default.error(result.error);
				return transformed;
			}
			return result.data;
		} };
	} };
}

//#endregion
//#region src/utils/transformers/connectedAccounts.ts
/**
* Transforms the raw connected account response from the Composio API to the SDK format.
*
* This method converts property names from snake_case to camelCase and reorganizes
* the data structure to match the SDK's standardized format.
*
* @param {RawConnectedAccountListResponse['items'][0]|RawConnectedAccountRetrieveResponse} response - The raw API response to transform
* @returns {Promise<ConnectedAccountRetrieveResponse>} The transformed response
* @throws {ZodError} If the response fails validation against the expected schema
*
* @private
*/
function transformConnectedAccountResponse(response) {
	const parseState = (state) => {
		try {
			return state ? ConnectionDataSchema.parse(state) : void 0;
		} catch (error) {
			logger_default.warn("Unsupported auth scheme in connected account state, ignoring state field", { error });
			return;
		}
	};
	return transform(response).with(ConnectedAccountRetrieveResponseSchema).using((response$1) => ({
		...response$1,
		authConfig: {
			...response$1.auth_config,
			id: response$1.auth_config.id,
			isComposioManaged: response$1.auth_config.is_composio_managed,
			isDisabled: response$1.auth_config.is_disabled
		},
		data: response$1.data ?? void 0,
		state: parseState(response$1.state),
		status: response$1.status,
		statusReason: response$1.status_reason,
		isDisabled: response$1.is_disabled,
		createdAt: response$1.created_at,
		updatedAt: response$1.updated_at,
		testRequestEndpoint: response$1.test_request_endpoint
	}));
}
/**
* Transforms the raw connected account list response from the Composio API to the SDK format.
*
* This method converts property names from snake_case to camelCase and reorganizes
* the data structure to match the SDK's standardized format.
*
* @param {RawConnectedAccountListResponse} response - The raw API response to transform
* @returns {ConnectedAccountListResponse} The transformed response
* @throws {ZodError} If the response fails validation against the expected schema
*
* @private
*/
function transformConnectedAccountListResponse(response) {
	return transform(response).with(ConnectedAccountListResponseSchema).using((response$1) => ({
		items: response$1.items.map(transformConnectedAccountResponse),
		nextCursor: response$1.next_cursor ?? null,
		totalPages: response$1.total_pages
	}));
}

//#endregion
//#region src/models/CustomTools.ts
var CustomTools = class {
	client;
	customToolsRegistry;
	constructor(client) {
		if (!client) throw new ComposioError("ComposioClient is required");
		this.client = client;
		this.customToolsRegistry = /* @__PURE__ */ new Map();
		telemetry.instrument(this, "CustomTools");
	}
	/**
	* Create a custom tool and registers it in the registry.
	* This is just an in memory registry and is not persisted.
	* @param {CustomToolOptions} toolOptions CustomToolOptions
	* @returns {Tool} The tool created
	*
	* @example
	* ```typescript
	* // Create a custom tool with input parameters
	* const customTool = await composio.customTools.createTool({
	*   name: 'My Custom Tool',
	*   description: 'A tool that performs a custom operation',
	*   slug: 'MY_CUSTOM_TOOL',
	*   inputParams: z.object({
	*     query: z.string().describe('The search query'),
	*     limit: z.number().optional().describe('Maximum number of results')
	*   }),
	*   execute: async (input, connectionConfig, executeToolRequest) => {
	*     // Custom implementation logic
	*     return {
	*       data: { results: ['result1', 'result2'] }
	*     };
	*   }
	* });
	* ```
	*/
	async createTool(toolOptions) {
		const { slug, execute, inputParams, name, description } = toolOptions;
		if (!slug || !execute || !inputParams || !name) throw new Error("Invalid tool options");
		const paramsSchemaJson = zodToJsonSchema.default(inputParams, { name: "input" }).definitions.input;
		const toolSchema = {
			name,
			slug,
			description,
			inputParameters: {
				title: name,
				type: "object",
				description,
				properties: paramsSchemaJson.properties,
				required: paramsSchemaJson.required
			},
			outputParameters: {
				type: "object",
				title: `Response for ${name}`,
				properties: {}
			},
			tags: [],
			toolkit: {
				name: "custom",
				slug: "custom"
			}
		};
		this.customToolsRegistry.set(slug.toLowerCase(), {
			options: toolOptions,
			schema: toolSchema
		});
		return toolSchema;
	}
	/**
	* Get all the custom tools from the registry.
	* @param {string[]} param0.toolSlugs The slugs of the tools to get
	* @returns {ToolList} The list of tools
	*
	* @example
	* ```typescript
	* // Get all custom tools
	* const allTools = await composio.customTools.getCustomTools({});
	*
	* // Get specific custom tools by slug
	* const specificTools = await composio.customTools.getCustomTools({
	*   toolSlugs: ['MY_CUSTOM_TOOL', 'ANOTHER_CUSTOM_TOOL']
	* });
	* ```
	*/
	async getCustomTools({ toolSlugs }) {
		const tools = [];
		if (toolSlugs) for (const slug of toolSlugs) {
			const tool = this.customToolsRegistry.get(slug.toLowerCase());
			if (tool) tools.push(tool.schema);
		}
		else return Array.from(this.customToolsRegistry.values()).map((tool) => tool.schema);
		return tools;
	}
	/**
	* Get a custom tool by slug from the registry.
	* @param {string} slug The slug of the tool to get
	* @returns {Tool} The tool
	*
	* @example
	* ```typescript
	* // Get a specific custom tool by its slug
	* const myTool = await composio.customTools.getCustomToolBySlug('MY_CUSTOM_TOOL');
	* if (myTool) {
	*   console.log(`Found tool: ${myTool.name}`);
	* } else {
	*   console.log('Tool not found');
	* }
	* ```
	*/
	async getCustomToolBySlug(slug) {
		try {
			return this.customToolsRegistry.get(slug.toLowerCase())?.schema;
		} catch (error) {
			logger_default.error(`Error getting custom tool: ${error}`);
			return;
		}
	}
	/**
	* Get the connected account for the user and toolkit.
	* @param {string} toolkitSlug The slug of the toolkit
	* @param {ExecuteMetadata} metadata The metadata of the execution
	* @returns {ConnectedAccount} The connected account
	*/
	async getConnectedAccountForToolkit(toolkitSlug, userId, connectedAccountId) {
		try {
			await this.client.toolkits.retrieve(toolkitSlug);
			if ((await this.client.toolkits.retrieve(toolkitSlug)).auth_config_details?.some((details) => details.mode === AuthSchemeTypes.NO_AUTH)) return null;
		} catch (error) {
			throw new ComposioToolNotFoundError(`Toolkit with slug ${toolkitSlug} not found`, { cause: error });
		}
		const connectedAccounts = await this.client.connectedAccounts.list({
			toolkit_slugs: [toolkitSlug],
			user_ids: [userId]
		});
		if (!connectedAccounts.items.length) throw new ComposioConnectedAccountNotFoundError(`No connected accounts found for toolkit ${toolkitSlug}`);
		const connectedAccount = connectedAccountId ? connectedAccounts.items.find((item) => item.id === connectedAccountId) : connectedAccounts.items[0];
		if (!connectedAccount) throw new ComposioConnectedAccountNotFoundError(`Connected account not found for toolkit ${toolkitSlug} for user ${userId}`);
		return transformConnectedAccountResponse(connectedAccount);
	}
	/**
	* Execute a custom tool
	*
	* @description If a toolkit is used, the connected account id is used to execute the tool.
	* If a connected account id is provided, it is used to execute the tool.
	* If a connected account id is not provided, the first connected account for the toolkit is used.
	*
	* @param {slug} slug The slug of the tool to execute
	* @param {Record<string, unknown>} inputParams The input parameters for the tool
	* @param {ExecuteMetadata} metadata The metadata of the execution
	* @returns {Promise<ToolExecuteResponse>} The response from the tool
	*/
	async executeCustomTool(slug, body) {
		const tool = this.customToolsRegistry.get(slug.toLowerCase());
		if (!tool) throw new ComposioToolNotFoundError(`Tool with slug ${slug} not found`);
		let connectionConfig = null;
		const { toolkitSlug, execute, inputParams } = tool.options;
		let connectedAccountId = body.connectedAccountId;
		if (toolkitSlug && toolkitSlug !== "custom" && body.userId) {
			const connectedAccount = await this.getConnectedAccountForToolkit(toolkitSlug, body.userId, body.connectedAccountId);
			logger_default.debug(`[CustomTool] Connected account for ${toolkitSlug} found for user ${body.userId}`, JSON.stringify(connectedAccount, null, 2));
			if (!connectedAccount) throw new ComposioConnectedAccountNotFoundError(`Connected account not found for toolkit ${toolkitSlug} for user ${body.userId}`, { meta: {
				toolkitSlug,
				userId: body.userId
			} });
			connectionConfig = connectedAccount.state ?? null;
			connectedAccountId = connectedAccount.id;
		}
		if (typeof execute !== "function") throw new ComposioInvalidExecuteFunctionError("Invalid execute function", { meta: { toolSlug: slug } });
		const executeToolRequest = async (data) => {
			if (toolkitSlug && toolkitSlug === "custom") throw new ComposioInvalidExecuteFunctionError("Custom tools without a toolkit cannot be executed using the executeToolRequest function", { possibleFixes: ["Please manually execute the tool using your logic.", "Pass a toolkit slug to execute the tool on behalf of a toolkit credentials"] });
			const parameters = data.parameters?.map((param) => ({
				name: param.name,
				type: param.in,
				value: param.value.toString()
			}));
			return {
				data: (await this.client.tools.proxy({
					endpoint: data.endpoint,
					method: data.method,
					parameters,
					body: data.body,
					connected_account_id: connectedAccountId,
					custom_connection_data: data.customConnectionData
				})).data,
				error: null,
				successful: true,
				logId: void 0,
				sessionInfo: void 0
			};
		};
		const parsedInput = inputParams.safeParse(body.arguments);
		if (!parsedInput.success) throw new ValidationError("Invalid input parameters", { cause: parsedInput.error });
		return execute(parsedInput.data, connectionConfig, executeToolRequest);
	}
};

//#endregion
//#region src/utils/toolkitVersion.ts
/**
* Gets the version for a specific toolkit based on the provided toolkit versions configuration.
*
* @param toolkitSlug - The slug/name of the toolkit to get the version for
* @param toolkitVersions - Optional toolkit versions configuration (string for global version or object mapping toolkit slugs to versions)
* @returns The toolkit version to use - either the specific version from config, or 'latest' as fallback
*/
const getToolkitVersion = (toolkitSlug, toolkitVersions) => {
	if (typeof toolkitVersions === "string") return toolkitVersions;
	if (toolkitVersions && Object.keys(toolkitVersions).length > 0) return toolkitVersions[toolkitSlug] ?? "latest";
	return "latest";
};

//#endregion
//#region src/models/Tools.ts
/**
* This class is used to manage tools in the Composio SDK.
* It provides methods to list, get, and execute tools.
*/
var Tools = class {
	client;
	customTools;
	provider;
	autoUploadDownloadFiles;
	toolkitVersions;
	constructor(client, config) {
		if (!client) throw new Error("ComposioClient is required");
		if (!config?.provider) throw new ComposioProviderNotDefinedError("Provider not passed into Tools instance");
		this.client = client;
		this.customTools = new CustomTools(client);
		this.provider = config.provider;
		this.autoUploadDownloadFiles = config?.autoUploadDownloadFiles ?? CONFIG_DEFAULTS.autoUploadDownloadFiles;
		this.toolkitVersions = config?.toolkitVersions ?? CONFIG_DEFAULTS.toolkitVersions;
		this.execute = this.execute.bind(this);
		this.provider._setExecuteToolFn(this.createExecuteFnForProviders());
		this.getRawComposioToolBySlug = this.getRawComposioToolBySlug.bind(this);
		this.getRawComposioTools = this.getRawComposioTools.bind(this);
		telemetry.instrument(this, "Tools");
	}
	/**
	* Transforms tool data from snake_case API format to camelCase for internal SDK use.
	*
	* This method standardizes the property naming convention for tools retrieved from the Composio API,
	* making them more consistent with JavaScript/TypeScript conventions.
	*
	* @param {ToolRetrieveResponse | ComposioToolListResponse['items'][0]} tool - The tool object to transform
	* @returns {Tool} The transformed tool with camelCase properties
	*
	* @private
	*/
	transformToolCases(tool) {
		return ToolSchema.parse({
			...tool,
			inputParameters: tool.input_parameters,
			outputParameters: tool.output_parameters,
			availableVersions: tool.available_versions,
			isDeprecated: tool.deprecated?.is_deprecated ?? false,
			isNoAuth: tool.no_auth
		});
	}
	/**
	* Transforms tool execution response from snake_case API format to camelCase.
	*
	* This method converts the response received from the Composio API to a standardized format
	* with consistent property naming that follows JavaScript/TypeScript conventions.
	*
	* @param {ComposioToolExecuteResponse} response - The raw API response to transform
	* @returns {ToolExecuteResponse} The transformed response with camelCase properties
	*
	* @private
	*/
	transformToolExecuteResponse(response) {
		return ToolExecuteResponseSchema.parse({
			data: response.data,
			error: response.error,
			successful: response.successful,
			logId: response.log_id,
			sessionInfo: response.session_info
		});
	}
	/**
	* Applies the default schema modifiers to the tools
	* @param tools - The tools to apply the default schema modifiers to
	* @returns The tools with the default schema modifiers applied
	*/
	async applyDefaultSchemaModifiers(tools) {
		if (this.autoUploadDownloadFiles) {
			const fileToolModifier = new FileToolModifier(this.client);
			return await Promise.all(tools.map((tool) => fileToolModifier.modifyToolSchema(tool.slug, tool.toolkit?.slug ?? "unknown", tool)));
		} else return tools;
	}
	/**
	* Applies the before execute modifiers to the tool execution params
	* @param options.toolSlug - The slug of the tool
	* @param options.toolkitSlug - The slug of the toolkit
	* @param options.params - The params of the tool execution
	* @param modifier - The modifier to apply
	* @returns The modified params
	*/
	async applyBeforeExecuteModifiers(tool, { toolSlug, toolkitSlug, params }, modifier) {
		let modifiedParams = params;
		if (this.autoUploadDownloadFiles) modifiedParams = await new FileToolModifier(this.client).fileUploadModifier(tool, {
			toolSlug,
			toolkitSlug,
			params: modifiedParams
		});
		if (modifier) if (typeof modifier === "function") modifiedParams = await modifier({
			toolSlug,
			toolkitSlug,
			params: modifiedParams
		});
		else throw new ComposioInvalidModifierError("Invalid beforeExecute modifier. Not a function.");
		return modifiedParams;
	}
	/**
	* Applies the after execute modifiers to the tool execution result
	* @param options.toolSlug - The slug of the tool
	* @param options.toolkitSlug - The slug of the toolkit
	* @param options.result - The result of the tool execution
	* @param modifier - The modifier to apply
	* @returns The modified result
	*/
	async applyAfterExecuteModifiers(tool, { toolSlug, toolkitSlug, result }, modifier) {
		let modifiedResult = result;
		if (this.autoUploadDownloadFiles) modifiedResult = await new FileToolModifier(this.client).fileDownloadModifier(tool, {
			toolSlug,
			toolkitSlug,
			result: modifiedResult
		});
		if (modifier) if (typeof modifier === "function") modifiedResult = await modifier({
			toolSlug,
			toolkitSlug,
			result: modifiedResult
		});
		else throw new ComposioInvalidModifierError("Invalid afterExecute modifier. Not a function.");
		return modifiedResult;
	}
	/**
	* Lists all tools available in the Composio SDK including custom tools.
	*
	* This method fetches tools from the Composio API in raw format and combines them with
	* any registered custom tools. The response can be filtered and modified as needed.
	* It provides access to the underlying tool data without provider-specific wrapping.
	*
	* @param {ToolListParams} query - Query parameters to filter the tools (required)
	* @param {GetRawComposioToolsOptions} [options] - Optional configuration for tool retrieval
	* @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform tool schemas
	* @returns {Promise<ToolList>} List of tools matching the query criteria
	*
	* @example
	* ```typescript
	* // Get tools from specific toolkits
	* const githubTools = await composio.tools.getRawComposioTools({
	*   toolkits: ['github'],
	*   limit: 10
	* });
	*
	* // Get specific tools by slug
	* const specificTools = await composio.tools.getRawComposioTools({
	*   tools: ['GITHUB_GET_REPOS', 'HACKERNEWS_GET_USER']
	* });
	*
	* // Get tools from specific toolkits
	* const githubTools = await composio.tools.getRawComposioTools({
	*   toolkits: ['github'],
	*   limit: 10
	* });
	*
	* // Get tools with schema transformation
	* const customizedTools = await composio.tools.getRawComposioTools({
	*   toolkits: ['github'],
	*   limit: 5
	* }, {
	*   modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
	*     // Add custom properties to tool schema
	*     return {
	*       ...schema,
	*       customProperty: `Modified ${toolSlug} from ${toolkitSlug}`,
	*       tags: [...(schema.tags || []), 'customized']
	*     };
	*   }
	* });
	*
	* // Search for tools
	* const searchResults = await composio.tools.getRawComposioTools({
	*   search: 'user management'
	* });
	*
	* // Get tools by authentication config
	* const authSpecificTools = await composio.tools.getRawComposioTools({
	*   authConfigIds: ['auth_config_123']
	* });
	* ```
	*/
	async getRawComposioTools(query, options) {
		if ("tools" in query && "toolkits" in query) throw new ValidationError("Invalid tool list parameters. You should not use tools and toolkits filter together.");
		const queryParams = ToolListParamsSchema.safeParse(query);
		if (queryParams.error) throw new ValidationError("Invalid tool list parameters", { cause: queryParams.error });
		const shouldAutoApplyImportant = "toolkits" in queryParams.data && !("tools" in queryParams.data) && !("tags" in queryParams.data) && !("search" in queryParams.data) && !("limit" in queryParams.data) && queryParams.data.important !== false;
		const effectiveImportant = "important" in queryParams.data ? queryParams.data.important : shouldAutoApplyImportant;
		if (!("tools" in queryParams.data || "toolkits" in queryParams.data || "search" in queryParams.data || "authConfigIds" in queryParams.data)) throw new ValidationError("Invalid tool list parameters, atleast one of the following parameters is required: tools, toolkits, search, authConfigIds");
		let limit = "limit" in queryParams.data ? queryParams.data.limit : void 0;
		if ("tools" in queryParams.data) limit = 9999;
		const filters = {
			..."tools" in queryParams.data ? { tool_slugs: queryParams.data.tools?.join(",") } : {},
			..."toolkits" in queryParams.data ? { toolkit_slug: queryParams.data.toolkits?.join(",") } : {},
			...limit ? { limit } : {},
			..."tags" in queryParams.data ? { tags: queryParams.data.tags } : {},
			..."scopes" in queryParams.data ? { scopes: queryParams.data.scopes } : {},
			..."search" in queryParams.data ? { search: queryParams.data.search } : {},
			..."authConfigIds" in queryParams.data ? { auth_config_ids: queryParams.data.authConfigIds } : {},
			...effectiveImportant ? { important: "true" } : {},
			toolkit_versions: this.toolkitVersions
		};
		logger_default.debug(`Fetching tools with filters: ${JSON.stringify(filters, null, 2)}`);
		const tools = await this.client.tools.list(filters);
		if (!tools) return [];
		const caseTransformedTools = tools.items.map((tool) => this.transformToolCases(tool));
		const customTools = await this.customTools.getCustomTools({ toolSlugs: "tools" in queryParams.data ? queryParams.data.tools : void 0 });
		let modifiedTools = await this.applyDefaultSchemaModifiers([...caseTransformedTools, ...customTools]);
		if (options?.modifySchema) {
			const modifier = options.modifySchema;
			if (typeof modifier === "function") {
				const modifiedPromises = modifiedTools.map((tool) => modifier({
					toolSlug: tool.slug,
					toolkitSlug: tool.toolkit?.slug ?? "unknown",
					schema: tool
				}));
				modifiedTools = await Promise.all(modifiedPromises);
			} else throw new ComposioInvalidModifierError("Invalid schema modifier. Not a function.");
		}
		return modifiedTools;
	}
	/**
	* Fetches the meta tools for a tool router session.
	* This method fetches the meta tools from the Composio API and transforms them to the expected format.
	* It provides access to the underlying meta tool data without provider-specific wrapping.
	*
	* @param sessionId {string} The session id to get the meta tools for
	* @param options {SchemaModifierOptions} Optional configuration for tool retrieval
	* @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform the tool schema
	* @returns {Promise<ToolList>} The list of meta tools
	*
	* @example
	* ```typescript
	* const metaTools = await composio.tools.getRawToolRouterMetaTools('session_123');
	* console.log(metaTools);
	* ```
	*/
	async getRawToolRouterMetaTools(sessionId, options) {
		let modifiedTools = (await this.client.toolRouter.session.tools(sessionId)).items.map((tool) => this.transformToolCases(tool));
		if (options?.modifySchema) {
			const modifier = options.modifySchema;
			if (typeof modifier === "function") {
				const modifiedPromises = modifiedTools.map((tool) => modifier({
					toolSlug: tool.slug,
					toolkitSlug: tool.toolkit?.slug ?? "unknown",
					schema: tool
				}));
				modifiedTools = await Promise.all(modifiedPromises);
			} else throw new ComposioInvalidModifierError("Invalid schema modifier. Not a function.");
		}
		return modifiedTools;
	}
	/**
	* Retrieves a specific tool by its slug from the Composio API.
	*
	* This method fetches a single tool in raw format without provider-specific wrapping,
	* providing direct access to the tool's schema and metadata. Tool versions are controlled
	* at the Composio SDK initialization level through the `toolkitVersions` configuration.
	*
	* @param {string} slug - The unique identifier of the tool (e.g., 'GITHUB_GET_REPOS')
	* @param {GetRawComposioToolBySlugOptions} [options] - Optional configuration for tool retrieval
	* @param {TransformToolSchemaModifier} [options.modifySchema] - Function to transform the tool schema
	* @returns {Promise<Tool>} The requested tool with its complete schema and metadata
	*
	* @example
	* ```typescript
	* // Get a tool by slug
	* const tool = await composio.tools.getRawComposioToolBySlug('GITHUB_GET_REPOS');
	* console.log(tool.name, tool.description);
	*
	* // Get a tool with schema transformation
	* const customizedTool = await composio.tools.getRawComposioToolBySlug(
	*   'SLACK_SEND_MESSAGE',
	*   {
	*     modifySchema: ({ toolSlug, toolkitSlug, schema }) => {
	*       return {
	*         ...schema,
	*         description: `Enhanced ${schema.description} with custom modifications`,
	*         customMetadata: {
	*           lastModified: new Date().toISOString(),
	*           toolkit: toolkitSlug
	*         }
	*       };
	*     }
	*   }
	* );
	*
	* // Get a custom tool (will check custom tools first)
	* const customTool = await composio.tools.getRawComposioToolBySlug('MY_CUSTOM_TOOL');
	*
	* // Access tool properties
	* const githubTool = await composio.tools.getRawComposioToolBySlug('GITHUB_CREATE_ISSUE');
	* console.log({
	*   slug: githubTool.slug,
	*   name: githubTool.name,
	*   toolkit: githubTool.toolkit?.name,
	*   version: githubTool.version,
	*   availableVersions: githubTool.availableVersions,
	*   inputParameters: githubTool.inputParameters
	* });
	* ```
	*/
	async getRawComposioToolBySlug(slug, options) {
		const customTool = await this.customTools.getCustomToolBySlug(slug);
		if (customTool) {
			logger_default.debug(`Found ${slug} to be a custom tool`, JSON.stringify(customTool, null, 2));
			return customTool;
		} else logger_default.debug(`Tool ${slug} is not a custom tool. Fetching from Composio API`);
		let tool;
		try {
			const retrieveParams = options?.version ? { version: options.version } : { toolkit_versions: this.toolkitVersions };
			tool = await this.client.tools.retrieve(slug, retrieveParams);
		} catch (error) {
			throw new ComposioToolNotFoundError(`Unable to retrieve tool with slug ${slug}`, { cause: error });
		}
		let [modifiedTool] = await this.applyDefaultSchemaModifiers([this.transformToolCases(tool)]);
		if (options?.modifySchema) {
			const modifier = options.modifySchema;
			if (typeof modifier === "function") modifiedTool = await modifier({
				toolSlug: slug,
				toolkitSlug: modifiedTool.toolkit?.slug ?? "unknown",
				schema: modifiedTool
			});
			else throw new ComposioInvalidModifierError("Invalid schema modifier. Not a function.");
		}
		return modifiedTool;
	}
	/**
	* Get a tool or list of tools based on the provided arguments.
	* This is an implementation method that handles all overloads.
	*
	* @param {string} userId - The user id to get the tool(s) for
	* @param {ToolListParams | string} arg2 - Either a slug string or filters object
	* @param {ProviderOptions<TProvider> | ToolkitVersion} [arg3] - Optional provider options or version string
	* @param {ProviderOptions<TProvider>} [arg4] - Optional provider options (when arg3 is version)
	* @returns {Promise<TToolCollection>} The tool collection
	*/
	async get(userId, arg2, arg3) {
		const options = arg3;
		if (typeof arg2 === "string") {
			const tool = await this.getRawComposioToolBySlug(arg2, { modifySchema: options?.modifySchema });
			return this.wrapToolsForProvider(userId, [tool], options);
		} else {
			const tools = await this.getRawComposioTools(arg2, { modifySchema: options?.modifySchema });
			return this.wrapToolsForProvider(userId, tools, options);
		}
	}
	/**
	* @internal
	* Creates a global execute tool function.
	* This function is used by providers to execute tools.
	* It skips the version check for provider controlled execution.
	* @returns {GlobalExecuteToolFn} The global execute tool function
	*/
	createExecuteFnForProviders() {
		return async (slug, body, modifiers) => {
			return await this.execute(slug, {
				...body,
				dangerouslySkipVersionCheck: body.dangerouslySkipVersionCheck ?? true
			}, modifiers);
		};
	}
	/**
	* @internal
	* Utility to wrap a given set of tools in the format expected by the provider
	*
	* @param userId - The user id to get the tools for
	* @param tools - The tools to wrap
	* @param modifiers - The modifiers to be applied to the tools
	* @returns The wrapped tools
	*/
	wrapToolsForProvider(userId, tools, modifiers) {
		const executeToolFn = this.createExecuteToolFn(userId, modifiers);
		return this.provider.wrapTools(tools, executeToolFn);
	}
	/**
	* @internal
	* Utility to wrap a given set of tools in the format expected by the tool router
	*
	* @param {string} sessionId - The session id to execute the tool for
	* @param {Tool[]} tools - The tools to wrap
	* @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
	* @returns {Tool[]} The wrapped tools
	*/
	wrapToolsForToolRouter(sessionId, tools, modifiers) {
		const executeToolFn = this.createExecuteToolFnForToolRouter(sessionId, modifiers);
		return this.provider.wrapTools(tools, executeToolFn);
	}
	/**
	* @internal
	* @description
	* Creates a function that executes a tool.
	* This function is used by agentic providers to execute the tool
	*
	* @param {string} userId - The user id
	* @param {ExecuteToolModifiers} modifiers - The modifiers to be applied to the tool
	* @returns {ExecuteToolFn} The execute tool function
	*/
	createExecuteToolFn(userId, modifiers) {
		const executeToolFn = async (toolSlug, input) => {
			return await this.execute(toolSlug, {
				userId,
				arguments: input,
				dangerouslySkipVersionCheck: true
			}, modifiers);
		};
		return executeToolFn;
	}
	/**
	* @internal
	* Creates a function that executes a tool for a tool router session
	*
	* @param {string} sessionId - The session id to execute the tool for
	* @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
	* @returns {ExecuteToolFn} The execute tool function
	*/
	createExecuteToolFnForToolRouter(sessionId, modifiers) {
		const executeToolFn = async (toolSlug, input) => {
			return await this.executeMetaTool(toolSlug, {
				sessionId,
				arguments: input
			}, modifiers);
		};
		return executeToolFn;
	}
	/**
	* @internal
	* Executes a composio tool via API without modifiers
	* @param tool - The tool to execute
	* @param body - The body of the tool execution
	* @returns The response from the tool execution
	*/
	async executeComposioTool(tool, body) {
		const toolkitVersion = body.version ?? getToolkitVersion(tool.toolkit?.slug ?? "unknown", this.toolkitVersions);
		if (toolkitVersion === "latest" && !body.dangerouslySkipVersionCheck) throw new ComposioToolVersionRequiredError();
		try {
			const result = await this.client.tools.execute(tool.slug, {
				allow_tracing: body.allowTracing,
				connected_account_id: body.connectedAccountId,
				custom_auth_params: body.customAuthParams,
				custom_connection_data: body.customConnectionData,
				arguments: body.arguments,
				user_id: body.userId,
				version: toolkitVersion,
				text: body.text
			});
			return this.transformToolExecuteResponse(result);
		} catch (error) {
			throw handleToolExecutionError(tool.slug, error);
		}
	}
	/**
	* Executes a given tool with the provided parameters.
	*
	* This method calls the Composio API or a custom tool handler to execute the tool and returns the response.
	* It automatically determines whether to use a custom tool or a Composio API tool based on the slug.
	*
	* **Version Control:**
	* By default, manual tool execution requires a specific toolkit version. If the version resolves to "latest",
	* the execution will throw a `ComposioToolVersionRequiredError` unless `dangerouslySkipVersionCheck` is set to `true`.
	* This helps prevent unexpected behavior when new toolkit versions are released.
	*
	* @param {string} slug - The slug/ID of the tool to be executed
	* @param {ToolExecuteParams} body - The parameters to be passed to the tool
	* @param {string} [body.version] - The specific version of the tool to execute (e.g., "20250909_00")
	* @param {boolean} [body.dangerouslySkipVersionCheck] - Skip version validation for "latest" version (use with caution)
	* @param {string} [body.userId] - The user ID to execute the tool for
	* @param {string} [body.connectedAccountId] - The connected account ID to use for authenticated tools
	* @param {Record<string, unknown>} [body.arguments] - The arguments to pass to the tool
	* @param {ExecuteToolModifiers} [modifiers] - Optional modifiers to transform the request or response
	* @returns {Promise<ToolExecuteResponse>} - The response from the tool execution
	*
	* @throws {ComposioCustomToolsNotInitializedError} If the CustomTools instance is not initialized
	* @throws {ComposioConnectedAccountNotFoundError} If the connected account is not found
	* @throws {ComposioToolNotFoundError} If the tool with the given slug is not found
	* @throws {ComposioToolVersionRequiredError} If version resolves to "latest" and dangerouslySkipVersionCheck is not true
	* @throws {ComposioToolExecutionError} If there is an error during tool execution
	*
	* @example Execute with a specific version (recommended for production)
	* ```typescript
	* const result = await composio.tools.execute('GITHUB_GET_REPOS', {
	*   userId: 'default',
	*   version: '20250909_00',
	*   arguments: { owner: 'composio' }
	* });
	* ```
	*
	* @example Execute with dangerouslySkipVersionCheck (not recommended for production)
	* ```typescript
	* const result = await composio.tools.execute('HACKERNEWS_GET_USER', {
	*   userId: 'default',
	*   arguments: { userId: 'pg' },
	*   dangerouslySkipVersionCheck: true // Allows execution with "latest" version
	* });
	* ```
	*
	* @example Execute with SDK-level toolkit versions configuration
	* ```typescript
	* // If toolkitVersions are set during Composio initialization, no need to pass version
	* const composio = new Composio({ toolkitVersions: { github: '20250909_00' } });
	* const result = await composio.tools.execute('GITHUB_GET_REPOS', {
	*   userId: 'default',
	*   arguments: { owner: 'composio' }
	* });
	* ```
	*
	* @example Execute with modifiers
	* ```typescript
	* const result = await composio.tools.execute('GITHUB_GET_ISSUES', {
	*   userId: 'default',
	*   version: '20250909_00',
	*   arguments: { owner: 'composio', repo: 'sdk' }
	* }, {
	*   beforeExecute: ({ toolSlug, toolkitSlug, params }) => {
	*     console.log(`Executing ${toolSlug} from ${toolkitSlug}`);
	*     return params;
	*   },
	*   afterExecute: ({ toolSlug, toolkitSlug, result }) => {
	*     console.log(`Completed ${toolSlug}`);
	*     return result;
	*   }
	* });
	* ```
	*/
	async execute(slug, body, modifiers) {
		if (!this.customTools) throw new ComposioCustomToolsNotInitializedError("CustomTools not initialized. Make sure Tools class is properly constructed.");
		const executeParams = ToolExecuteParamsSchema.safeParse(body);
		if (!executeParams.success) throw new ValidationError("Invalid tool execute parameters", { cause: executeParams.error });
		const customTool = await this.customTools.getCustomToolBySlug(slug);
		const tool = customTool ?? await this.getRawComposioToolBySlug(slug, { version: body.version });
		const toolkitSlug = tool.toolkit?.slug ?? "unknown";
		const params = await this.applyBeforeExecuteModifiers(tool, {
			toolSlug: slug,
			toolkitSlug,
			params: executeParams.data
		}, modifiers?.beforeExecute);
		let result = customTool ? await this.customTools.executeCustomTool(customTool.slug, params) : await this.executeComposioTool(tool, params);
		result = await this.applyAfterExecuteModifiers(tool, {
			toolSlug: slug,
			toolkitSlug,
			result
		}, modifiers?.afterExecute);
		return result;
	}
	/**
	* Executes a composio meta tool based on tool router session
	*
	* @param {string} toolSlug - The slug of the tool to execute
	* @param {ToolExecuteMetaParams} body - The execution parameters
	* @param {string} body.sessionId - The session id to execute the tool for
	* @param {Record<string, unknown>} body.arguments - The input to pass to the tool
	* @param {SessionExecuteMetaModifiers} modifiers - The modifiers to apply to the tool
	* @returns {Promise<ToolExecuteResponse>} The response from the tool execution
	*/
	async executeMetaTool(toolSlug, body, modifiers) {
		const executeMetaParams = ToolExecuteMetaParamsSchema.safeParse(body);
		if (!executeMetaParams.success) throw new ValidationError("Invalid tool execute meta parameters", { cause: executeMetaParams.error });
		let modifiedParams = body.arguments ?? {};
		if (modifiers?.beforeExecute) modifiedParams = await modifiers.beforeExecute({
			toolSlug,
			toolkitSlug: "composio",
			sessionId: body.sessionId,
			params: modifiedParams
		});
		const response = await this.client.toolRouter.session.executeMeta(body.sessionId, {
			slug: toolSlug,
			arguments: modifiedParams
		});
		let result = {
			data: response.data,
			error: response.error,
			successful: !response.error,
			logId: response.log_id
		};
		if (modifiers?.afterExecute) result = await modifiers.afterExecute({
			toolSlug,
			toolkitSlug: "composio",
			sessionId: body.sessionId,
			result
		});
		return result;
	}
	/**
	* Fetches the list of all available tools in the Composio SDK.
	*
	* This method is mostly used by the CLI to get the list of tools.
	* No filtering is done on the tools, the list is cached in the backend, no further optimization is required.
	* @returns {Promise<ToolRetrieveEnumResponse>} The complete list of all available tools with their metadata
	*
	* @example
	* ```typescript
	* // Get all available tools as an enum
	* const toolsEnum = await composio.tools.getToolsEnum();
	* console.log(toolsEnum.items);
	* ```
	*/
	async getToolsEnum() {
		return this.client.tools.retrieveEnum();
	}
	/**
	* Fetches the input parameters for a given tool.
	*
	* This method is used to get the input parameters for a tool before executing it.
	*
	* @param {string} slug - The ID of the tool to find input for
	* @param {ToolGetInputParams} body - The parameters to be passed to the tool
	* @returns {Promise<ToolGetInputResponse>} The input parameters schema for the specified tool
	*
	* @example
	* ```typescript
	* // Get input parameters for a specific tool
	* const inputParams = await composio.tools.getInput('GITHUB_CREATE_ISSUE', {
	*   userId: 'default'
	* });
	* console.log(inputParams.schema);
	* ```
	*/
	async getInput(slug, body) {
		return this.client.tools.getInput(slug, body);
	}
	/**
	* Proxies a custom request to a toolkit/integration.
	*
	* This method allows sending custom requests to a specific toolkit or integration
	* when you need more flexibility than the standard tool execution methods provide.
	*
	* @param {ToolProxyParams} body - The parameters for the proxy request including toolkit slug and custom data
	* @returns {Promise<ToolProxyResponse>} The response from the proxied request
	*
	* @example
	* ```typescript
	* // Send a custom request to a toolkit
	* const response = await composio.tools.proxyExecute({
	*   toolkitSlug: 'github',
	*   userId: 'default',
	*   data: {
	*     endpoint: '/repos/owner/repo/issues',
	*     method: 'GET'
	*   }
	* });
	* console.log(response.data);
	* ```
	*/
	async proxyExecute(body) {
		const toolProxyParams = ToolProxyParamsSchema.safeParse(body);
		if (!toolProxyParams.success) throw new ValidationError("Invalid tool proxy parameters", { cause: toolProxyParams.error });
		const parameters = [];
		const parameterTypes = {
			header: "header",
			query: "query"
		};
		if (toolProxyParams.data.parameters) parameters.push(...(toolProxyParams.data.parameters ?? []).map((value) => ({
			name: value.name,
			type: value.in === "header" ? parameterTypes.header : parameterTypes.query,
			value: value.value.toString()
		})));
		return this.client.tools.proxy({
			endpoint: toolProxyParams.data.endpoint,
			method: toolProxyParams.data.method,
			body: toolProxyParams.data.body,
			connected_account_id: toolProxyParams.data.connectedAccountId,
			parameters,
			custom_connection_data: toolProxyParams.data.customConnectionData
		});
	}
	/**
	* Creates a custom tool that can be used within the Composio SDK.
	*
	* Custom tools allow you to extend the functionality of Composio with your own implementations
	* while keeping a consistent interface for both built-in and custom tools.
	*
	* @param {CustomToolOptions} body - The configuration for the custom tool
	* @returns {Promise<Tool>} The created custom tool
	*
	* @example
	* ```typescript
	* // creating a custom tool with a toolkit
	* await composio.tools.createCustomTool({
	*   name: 'My Custom Tool',
	*   description: 'A custom tool that does something specific',
	*   slug: 'MY_CUSTOM_TOOL',
	*   userId: 'default',
	*   connectedAccountId: '123',
	*   toolkitSlug: 'github',
	*   inputParameters: z.object({
	*     param1: z.string().describe('First parameter'),
	*   }),
	*   execute: async (input, connectionConfig, executeToolRequest) => {
	*     // Custom logic here
	*     return { data: { result: 'Success!' } };
	*   }
	* });
	* ```
	*
	* @example
	* ```typescript
	* // creating a custom tool without a toolkit
	* await composio.tools.createCustomTool({
	*   name: 'My Custom Tool',
	*   description: 'A custom tool that does something specific',
	*   slug: 'MY_CUSTOM_TOOL',
	*   inputParameters: z.object({
	*     param1: z.string().describe('First parameter'),
	*   }),
	*   execute: async (input) => {
	*     // Custom logic here
	*     return { data: { result: 'Success!' } };
	*   }
	* });
	*/
	async createCustomTool(body) {
		return this.customTools.createTool(body);
	}
};

//#endregion
//#region src/types/toolkit.types.ts
/**
* Toolkit list params
*/
const ToolkitMangedByEnumSchema = z$1.enum([
	"all",
	"composio",
	"project"
]);
const ToolkitSortByEnumSchema = z$1.enum(["usage", "alphabetically"]);
const ToolkitsListParamsSchema = z$1.object({
	category: z$1.string().optional(),
	managedBy: ToolkitMangedByEnumSchema.optional(),
	sortBy: ToolkitSortByEnumSchema.optional(),
	cursor: z$1.string().optional(),
	limit: z$1.number().optional()
});
/**
* Toolkits response
*/
const ToolKitMetaSchema = z$1.object({
	categories: z$1.array(z$1.object({
		slug: z$1.string(),
		name: z$1.string()
	})).optional(),
	appUrl: z$1.string().optional(),
	createdAt: z$1.string().optional(),
	description: z$1.string().optional(),
	logo: z$1.string().optional(),
	toolsCount: z$1.number().optional(),
	triggersCount: z$1.number().optional(),
	updatedAt: z$1.string().optional(),
	availableVersions: z$1.array(z$1.string()).optional()
});
const ToolKitItemSchema = z$1.object({
	name: z$1.string(),
	slug: z$1.string(),
	meta: ToolKitMetaSchema,
	isLocalToolkit: z$1.boolean(),
	authSchemes: z$1.array(z$1.string()).optional(),
	composioManagedAuthSchemes: z$1.array(z$1.string()).optional(),
	noAuth: z$1.boolean().optional()
});
const ToolKitListResponseSchema = z$1.array(ToolKitItemSchema);
/**
* Toolkit retrieve response
*/
const ToolkitAuthFieldSchema = z$1.object({
	description: z$1.string(),
	displayName: z$1.string(),
	required: z$1.boolean(),
	name: z$1.string(),
	type: z$1.string(),
	default: z$1.string().nullable().optional()
});
const ToolkitAuthConfigDetailsSchema = z$1.object({
	name: z$1.string(),
	mode: z$1.string(),
	fields: z$1.object({
		authConfigCreation: z$1.object({
			optional: z$1.array(ToolkitAuthFieldSchema),
			required: z$1.array(ToolkitAuthFieldSchema)
		}),
		connectedAccountInitiation: z$1.object({
			optional: z$1.array(ToolkitAuthFieldSchema),
			required: z$1.array(ToolkitAuthFieldSchema)
		})
	}),
	proxy: z$1.object({ baseUrl: z$1.string().optional() }).optional()
});
const ToolkitRetrieveResponseSchema = z$1.object({
	name: z$1.string(),
	slug: z$1.string(),
	meta: ToolKitMetaSchema,
	isLocalToolkit: z$1.boolean(),
	composioManagedAuthSchemes: z$1.array(z$1.string()).optional(),
	authConfigDetails: z$1.array(ToolkitAuthConfigDetailsSchema).optional(),
	baseUrl: z$1.string().optional(),
	getCurrentUserEndpoint: z$1.string().optional(),
	getCurrentUserEndpointMethod: z$1.string().optional()
});
/**
* Toolkit categories response
*/
const ToolkitCategorySchema = z$1.object({
	id: z$1.string(),
	name: z$1.string()
});
const ToolkitRetrieveCategoriesResponseSchema = z$1.object({
	items: z$1.array(ToolkitCategorySchema),
	nextCursor: z$1.string().nullable(),
	totalPages: z$1.number()
});
const ToolkitAuthFieldsResponseSchema = z$1.array(ToolkitAuthFieldSchema.extend({ required: z$1.boolean().optional() }));

//#endregion
//#region src/utils/transformers/authConfigs.ts
/**
* Transforms an auth config response from API format to SDK format.
*
* This method converts property names from snake_case to camelCase and reorganizes
* the data structure to match the SDK's standardized format for auth configurations.
*
* @param {RawAuthConfigRetrieveResponse} authConfig - The raw API response to transform
* @returns {AuthConfigRetrieveResponse} The transformed auth config data
*
* @private
*/
function transformAuthConfigRetrieveResponse(authConfig) {
	return transform(authConfig).with(AuthConfigRetrieveResponseSchema).using((authConfig$1) => ({
		id: authConfig$1.id,
		name: authConfig$1.name,
		noOfConnections: authConfig$1.no_of_connections,
		status: authConfig$1.status,
		toolkit: {
			logo: authConfig$1.toolkit.logo,
			slug: authConfig$1.toolkit.slug
		},
		isEnabledForToolRouter: authConfig$1.is_enabled_for_tool_router,
		uuid: authConfig$1.uuid,
		authScheme: authConfig$1.auth_scheme,
		credentials: authConfig$1.credentials,
		expectedInputFields: authConfig$1.expected_input_fields,
		isComposioManaged: authConfig$1.is_composio_managed,
		createdBy: authConfig$1.created_by,
		createdAt: authConfig$1.created_at,
		lastUpdatedAt: authConfig$1.last_updated_at,
		restrictToFollowingTools: authConfig$1.tool_access_config?.tools_for_connected_account_creation,
		toolAccessConfig: authConfig$1.tool_access_config ? {
			toolsAvailableForExecution: authConfig$1.tool_access_config.tools_available_for_execution,
			toolsForConnectedAccountCreation: authConfig$1.tool_access_config.tools_for_connected_account_creation
		} : void 0
	}));
}
/**
* Transforms the raw auth config list response from the Composio API to the SDK format.
*
* This method converts property names from snake_case to camelCase and reorganizes
* the data structure to match the SDK's standardized format for auth configurations.
*
* @param {RawAuthConfigListResponse} response - The raw API response to transform
* @returns {AuthConfigListResponse} The transformed response
*
* @private
*/
function transformAuthConfigListResponse(response) {
	return transform(response).with(AuthConfigListResponseSchema).using((response$1) => ({
		items: response$1.items.map(transformAuthConfigRetrieveResponse),
		nextCursor: response$1.next_cursor ?? null,
		totalPages: response$1.total_pages
	}));
}
/**
* Transforms the raw create auth config response from the Composio API to the SDK format.
*
* This method converts property names from snake_case to camelCase and reorganizes
* the data structure to match the SDK's standardized format for auth configurations.
*
* @param {RawCreateAuthConfigResponse} response - The raw API response to transform
* @returns {CreateAuthConfigResponse} The transformed response
*
* @private
*/
function transformCreateAuthConfigResponse(response) {
	return transform(response).with(CreateAuthConfigResponseSchema).using((response$1) => ({
		id: response$1.auth_config.id,
		authScheme: response$1.auth_config.auth_scheme,
		isComposioManaged: response$1.auth_config.is_composio_managed,
		toolkit: response$1.toolkit.slug
	}));
}

//#endregion
//#region src/models/AuthConfigs.ts
/**
* AuthConfigs class
*
* This class is used to manage authentication configurations in the Composio SDK.
* Auth configs are used to configure authentication providers and settings.
*/
var AuthConfigs = class {
	client;
	constructor(client) {
		this.client = client;
		telemetry.instrument(this, "AuthConfigs");
	}
	/**
	* Protected getter for the client instance.
	* This is primarily used for testing purposes.
	* @protected
	*/
	getClient() {
		return this.client;
	}
	/**
	* Lists authentication configurations based on provided filter criteria.
	*
	* This method retrieves auth configs from the Composio API, transforms them to the SDK format,
	* and supports filtering by various parameters.
	*
	* @param {AuthConfigListParams} [query] - Optional query parameters for filtering auth configs
	* @returns {Promise<AuthConfigListResponse>} A paginated list of auth configurations
	* @throws {ValidationError} If the query parameters or response fail validation
	*
	* @example
	* ```typescript
	* // List all auth configs
	* const allConfigs = await composio.authConfigs.list();
	*
	* // List auth configs for a specific toolkit
	* const githubConfigs = await composio.authConfigs.list({
	*   toolkit: 'github'
	* });
	*
	* // List Composio-managed auth configs
	* const managedConfigs = await composio.authConfigs.list({
	*   isComposioManaged: true
	* });
	* ```
	*/
	async list(query) {
		const parsedQuery = query ? AuthConfigListParamsSchema.parse(query) : void 0;
		return transformAuthConfigListResponse(await this.client.authConfigs.list({
			cursor: parsedQuery?.cursor,
			is_composio_managed: parsedQuery?.isComposioManaged,
			limit: parsedQuery?.limit,
			toolkit_slug: parsedQuery?.toolkit
		}));
	}
	/**
	* Create a new auth config
	* @param {string} toolkit - Unique identifier of the toolkit
	* @param {CreateAuthConfigParams} options - Options for creating a new auth config
	* @returns {Promise<CreateAuthConfigResponse>} Created auth config
	*
	* @example
	* const authConfig = await authConfigs.create('my-toolkit', {
	*   type: AuthConfigTypes.CUSTOM,
	*   name: 'My Custom Auth Config',
	*   authScheme: AuthSchemeTypes.API_KEY,
	*   credentials: {
	*     apiKey: '1234567890',
	*   },
	* });
	*
	* @link https://docs.composio.dev/reference/auth-configs/create-auth-config
	*/
	async create(toolkit, options = { type: "use_composio_managed_auth" }) {
		const parsedOptions = CreateAuthConfigParamsSchema.safeParse(options);
		if (parsedOptions.error) throw new ValidationError("Failed to parse auth config create options", { cause: parsedOptions.error });
		return transformCreateAuthConfigResponse(await this.client.authConfigs.create({
			toolkit: { slug: toolkit },
			auth_config: parsedOptions.data.type === "use_custom_auth" ? {
				type: parsedOptions.data.type,
				name: parsedOptions.data.name,
				authScheme: parsedOptions.data.authScheme,
				credentials: parsedOptions.data.credentials,
				is_enabled_for_tool_router: parsedOptions.data.isEnabledForToolRouter,
				proxy_config: parsedOptions.data.proxyConfig ? {
					proxy_url: parsedOptions.data.proxyConfig.proxyUrl,
					proxy_auth_key: parsedOptions.data.proxyConfig.proxyAuthKey
				} : void 0,
				tool_access_config: parsedOptions.data.toolAccessConfig ? { tools_for_connected_account_creation: parsedOptions.data.toolAccessConfig.toolsForConnectedAccountCreation } : void 0
			} : {
				type: parsedOptions.data.type,
				credentials: parsedOptions.data.credentials,
				name: parsedOptions.data.name,
				is_enabled_for_tool_router: parsedOptions.data.isEnabledForToolRouter,
				tool_access_config: parsedOptions.data.toolAccessConfig ? { tools_for_connected_account_creation: parsedOptions.data.toolAccessConfig.toolsForConnectedAccountCreation } : void 0
			}
		}));
	}
	/**
	* Retrieves a specific authentication configuration by its ID.
	*
	* This method fetches detailed information about a single auth config
	* and transforms the response to the SDK's standardized format.
	*
	* @param {string} nanoid - The unique identifier of the auth config to retrieve
	* @returns {Promise<AuthConfigRetrieveResponse>} The auth config details
	* @throws {Error} If the auth config cannot be found or an API error occurs
	* @throws {ValidationError} If the response fails validation
	*
	* @example
	* ```typescript
	* // Get an auth config by ID
	* const authConfig = await composio.authConfigs.get('auth_abc123');
	* console.log(authConfig.name); // e.g., 'GitHub Auth'
	* console.log(authConfig.toolkit.slug); // e.g., 'github'
	* ```
	*/
	async get(nanoid) {
		return transformAuthConfigRetrieveResponse(await this.client.authConfigs.retrieve(nanoid));
	}
	/**
	* Updates an existing authentication configuration.
	*
	* This method allows you to modify properties of an auth config such as credentials,
	* scopes, or tool restrictions. The update type (custom or default) determines which
	* fields can be updated.
	*
	* @param {string} nanoid - The unique identifier of the auth config to update
	* @param {AuthConfigUpdateParams} data - The data to update, which can be either custom or default type
	* @returns {Promise<AuthConfigUpdateResponse>} The updated auth config
	* @throws {ValidationError} If the update parameters are invalid
	* @throws {Error} If the auth config cannot be found or updated
	*
	* @example
	* ```typescript
	* // Update a custom auth config with new credentials
	* const updatedConfig = await composio.authConfigs.update('auth_abc123', {
	*   type: 'custom',
	*   credentials: {
	*     apiKey: 'new-api-key-value'
	*   }
	* });
	*
	* // Update a default auth config with new scopes
	* const updatedConfig = await composio.authConfigs.update('auth_abc123', {
	*   type: 'default',
	*   scopes: ['read:user', 'repo']
	* });
	* ```
	*/
	async update(nanoid, data) {
		const parsedData = AuthConfigUpdateParamsSchema.safeParse(data);
		if (parsedData.error) throw new ValidationError("Failed to parse auth config update data", { cause: parsedData.error });
		return this.client.authConfigs.update(nanoid, parsedData.data.type === "custom" ? {
			type: "custom",
			credentials: parsedData.data.credentials,
			is_enabled_for_tool_router: parsedData.data.isEnabledForToolRouter,
			tool_access_config: {
				tools_for_connected_account_creation: parsedData.data.toolAccessConfig?.toolsForConnectedAccountCreation,
				tools_available_for_execution: parsedData.data.toolAccessConfig?.toolsAvailableForExecution ?? parsedData.data.restrictToFollowingTools
			}
		} : {
			type: "default",
			scopes: parsedData.data.scopes,
			is_enabled_for_tool_router: parsedData.data.isEnabledForToolRouter,
			tool_access_config: {
				tools_for_connected_account_creation: parsedData.data.toolAccessConfig?.toolsForConnectedAccountCreation,
				tools_available_for_execution: parsedData.data.toolAccessConfig?.toolsAvailableForExecution ?? parsedData.data.restrictToFollowingTools
			}
		});
	}
	/**
	* Deletes an authentication configuration.
	*
	* This method permanently removes an auth config from the Composio platform.
	* This action cannot be undone and will prevent any connected accounts that use
	* this auth config from functioning.
	*
	* @param {string} nanoid - The unique identifier of the auth config to delete
	* @returns {Promise<AuthConfigDeleteResponse>} The deletion response
	* @throws {Error} If the auth config doesn't exist or cannot be deleted
	*
	* @example
	* ```typescript
	* // Delete an auth config
	* await composio.authConfigs.delete('auth_abc123');
	* ```
	*/
	async delete(nanoid) {
		return this.client.authConfigs.delete(nanoid);
	}
	/**
	* Updates the status of an authentication configuration.
	*
	* This method allows you to enable or disable an auth config. When disabled,
	* the auth config cannot be used to create new connected accounts or authenticate
	* with third-party services.
	*
	* @param {string} status - The status to set ('ENABLED' or 'DISABLED')
	* @param {string} nanoid - The unique identifier of the auth config
	* @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
	* @throws {Error} If the auth config cannot be found or the status cannot be updated
	*
	* @example
	* ```typescript
	* // Disable an auth config
	* await composio.authConfigs.updateStatus('DISABLED', 'auth_abc123');
	*
	* // Enable an auth config
	* await composio.authConfigs.updateStatus('ENABLED', 'auth_abc123');
	* ```
	*/
	async updateStatus(status, nanoid) {
		return this.client.authConfigs.updateStatus(status, { nanoid });
	}
	/**
	* Enables an authentication configuration.
	*
	* This is a convenience method that calls updateStatus with 'ENABLED'.
	* When enabled, the auth config can be used to create new connected accounts
	* and authenticate with third-party services.
	*
	* @param {string} nanoid - The unique identifier of the auth config to enable
	* @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
	* @throws {Error} If the auth config cannot be found or enabled
	*
	* @example
	* ```typescript
	* // Enable an auth config
	* await composio.authConfigs.enable('auth_abc123');
	* ```
	*/
	async enable(nanoid) {
		return this.client.authConfigs.updateStatus("ENABLED", { nanoid });
	}
	/**
	* Disables an authentication configuration.
	*
	* This is a convenience method that calls updateStatus with 'DISABLED'.
	* When disabled, the auth config cannot be used to create new connected accounts
	* or authenticate with third-party services, but existing connections may continue to work.
	*
	* @param {string} nanoid - The unique identifier of the auth config to disable
	* @returns {Promise<AuthConfigUpdateStatusResponse>} The updated auth config details
	* @throws {Error} If the auth config cannot be found or disabled
	*
	* @example
	* ```typescript
	* // Disable an auth config
	* await composio.authConfigs.disable('auth_abc123');
	* ```
	*/
	async disable(nanoid) {
		return this.client.authConfigs.updateStatus("DISABLED", { nanoid });
	}
};

//#endregion
//#region src/models/ConnectionRequest.ts
/**
* @fileoverview Connection request function for Composio SDK, used to manage an initiated connection request.
*
* @author Musthaq Ahamad <musthaq@composio.dev>
* @date 2025-05-05
* @module ConnectionRequest
*/
/**
* Creates a connection request object with methods to manage the connection lifecycle.
*
* @param {ComposioClient} client - The Composio client instance
* @param {string} connectedAccountId - The ID of the connected account
* @param {ConnectedAccountStatus} [status] - Initial status of the connection
* @param {string | null} [redirectUrl] - OAuth redirect URL if applicable
* @returns {ConnectionRequestState & { waitForConnection: (timeout?: number) => Promise<ConnectedAccountRetrieveResponse> }}
* Connection request object with state and methods
*/
function createConnectionRequest(client, connectedAccountId, status, redirectUrl) {
	const state = {
		id: connectedAccountId,
		status: status || ConnectedAccountStatuses.INITIATED,
		redirectUrl
	};
	telemetry.instrument(state, "ConnectionRequest");
	/**
	* Waits for the connection request to complete and become active.
	*
	* This method continuously polls the Composio API to check the status of the connection request
	* until it either becomes active, enters a terminal error state, or times out.
	*
	* @param {number} [timeout=60000] - Maximum time to wait in milliseconds before timing out (default: 60 seconds)
	* @returns {Promise<ConnectedAccountRetrieveResponse>} The final connected account response when successful
	* @throws {ComposioConnectedAccountNotFoundError} If the connected account cannot be found
	* @throws {ConnectionRequestFailedError} If the connection enters a failed, expired, or deleted state
	* @throws {ConnectionRequestTimeoutError} If the connection request does not complete within the timeout period
	*
	* @example
	* ```typescript
	* // Wait for connection with default timeout (60 seconds)
	* try {
	*   const connection = await connectionRequest.waitForConnection();
	*   console.log('Connection established:', connection.id);
	* } catch (error) {
	*   console.error('Connection failed:', error.message);
	* }
	*
	* // Wait for connection with custom timeout (2 minutes)
	* const connection = await connectionRequest.waitForConnection(120000);
	* ```
	*/
	async function waitForConnection(timeout = 6e4) {
		try {
			const response = await client.connectedAccounts.retrieve(state.id);
			if (response.status === ConnectedAccountStatuses.ACTIVE) {
				state.status = ConnectedAccountStatuses.ACTIVE;
				return transformConnectedAccountResponse(response);
			}
		} catch (error) {
			if (error instanceof ComposioClient.NotFoundError) throw new ComposioConnectedAccountNotFoundError(`Connected account with id ${state.id} not found`, { meta: { connectedAccountId: state.id } });
			else throw error;
		}
		const terminalErrorStates = [ConnectedAccountStatuses.FAILED, ConnectedAccountStatuses.EXPIRED];
		const start = Date.now();
		const pollInterval = 1e3;
		while (Date.now() - start < timeout) try {
			const response = await client.connectedAccounts.retrieve(state.id);
			state.status = response.status;
			if (response.status === ConnectedAccountStatuses.ACTIVE) return transformConnectedAccountResponse(response);
			if (terminalErrorStates.includes(response.status)) throw new ConnectionRequestFailedError(`Connection request failed with status: ${response.status}${response.status_reason ? `, reason: ${response.status_reason}` : ""}`, { meta: {
				connectedAccountId: state.id,
				status: response.status,
				statusReason: response.status_reason
			} });
			await new Promise((resolve) => setTimeout(resolve, pollInterval));
		} catch (error) {
			throw error;
		}
		throw new ConnectionRequestTimeoutError(`Connection request timed out for ${state.id}`);
	}
	return {
		...state,
		waitForConnection,
		toJSON: () => ({ ...state }),
		toString: () => JSON.stringify(state, null, 2)
	};
}

//#endregion
//#region src/models/ConnectedAccounts.ts
/**
* ConnectedAccounts class
*
* This class is used to manage connected accounts in the Composio SDK.
* Connected accounts are used to authenticate with third-party services.
*/
var ConnectedAccounts = class {
	client;
	constructor(client) {
		this.client = client;
		telemetry.instrument(this, "ConnectedAccounts");
	}
	/**
	* Lists all connected accounts based on provided filter criteria.
	*
	* This method retrieves connected accounts from the Composio API with optional filtering.
	*
	* @param {ConnectedAccountListParams} [query] - Optional query parameters for filtering connected accounts
	* @returns {Promise<ConnectedAccountListResponse>} A paginated list of connected accounts
	* @throws {ValidationError} If the query fails validation against the expected schema
	* @example
	* ```typescript
	* // List all connected accounts
	* const allAccounts = await composio.connectedAccounts.list();
	*
	* // List accounts for a specific user
	* const userAccounts = await composio.connectedAccounts.list({
	*   userIds: ['user123']
	* });
	*
	* // List accounts for a specific toolkit
	* const githubAccounts = await composio.connectedAccounts.list({
	*   toolkitSlugs: ['github']
	* });
	* ```
	*/
	async list(query) {
		let rawQuery = void 0;
		if (query) {
			const parsedQuery = ConnectedAccountListParamsSchema.safeParse(query);
			if (!parsedQuery.success) throw new ValidationError("Failed to parse connected account list query", { cause: parsedQuery.error });
			rawQuery = {
				auth_config_ids: parsedQuery.data.authConfigIds,
				cursor: parsedQuery.data.cursor?.toString(),
				limit: parsedQuery.data.limit,
				order_by: parsedQuery.data.orderBy,
				statuses: parsedQuery.data.statuses,
				toolkit_slugs: parsedQuery.data.toolkitSlugs,
				user_ids: parsedQuery.data.userIds
			};
		}
		return transformConnectedAccountListResponse(await this.client.connectedAccounts.list(rawQuery));
	}
	/**
	* Compound function to create a new connected account.
	* This function creates a new connected account and returns a connection request.
	* Users can then wait for the connection to be established using the `waitForConnection` method.
	*
	* @param {string} userId - User ID of the connected account
	* @param {string} authConfigId - Auth config ID of the connected account
	* @param {CreateConnectedAccountOptions} options - Options for creating a new connected account
	* @returns {Promise<ConnectionRequest>} Connection request object
	*
	* @example
	* ```typescript
	* // For OAuth2 authentication
	* const connectionRequest = await composio.connectedAccounts.initiate(
	*   'user_123',
	*   'auth_config_123',
	*   {
	*     callbackUrl: 'https://your-app.com/callback',
	*     config: AuthScheme.OAuth2({
	*       access_token: 'your_access_token',
	*       token_type: 'Bearer'
	*     })
	*   }
	* );
	*
	* // For API Key authentication
	* const connectionRequest = await composio.connectedAccounts.initiate(
	*   'user_123',
	*   'auth_config_123',
	*   {
	*     config: AuthScheme.ApiKey({
	*       api_key: 'your_api_key'
	*     })
	*   }
	* );
	*
	* // For Basic authentication
	* const connectionRequest = await composio.connectedAccounts.initiate(
	*   'user_123',
	*   'auth_config_123',
	*   {
	*     config: AuthScheme.Basic({
	*       username: 'your_username',
	*       password: 'your_password'
	*     })
	*   }
	* );
	* ```
	*
	* @link https://docs.composio.dev/reference/connected-accounts/create-connected-account
	*/
	async initiate(userId, authConfigId, options) {
		const connectedAccount = await this.list({
			userIds: [userId],
			authConfigIds: [authConfigId],
			statuses: [ConnectedAccountStatuses.ACTIVE]
		});
		if (connectedAccount.items.length > 0 && !options?.allowMultiple) throw new ComposioMultipleConnectedAccountsError(`Multiple connected accounts found for user ${userId} in auth config ${authConfigId}. Please use the allowMultiple option to allow multiple connected accounts.`);
		else if (connectedAccount.items.length > 0) logger_default.warn(`[Warn:AllowMultiple] Multiple connected accounts found for user ${userId} in auth config ${authConfigId}`);
		const state = options?.config ?? void 0;
		const response = await this.client.connectedAccounts.create({
			auth_config: { id: authConfigId },
			connection: {
				callback_url: options?.callbackUrl,
				user_id: userId,
				state
			}
		});
		const redirectUrl = typeof response.connectionData?.val?.redirectUrl === "string" ? response.connectionData.val.redirectUrl : null;
		return createConnectionRequest(this.client, response.id, response.connectionData.val.status, redirectUrl);
	}
	/**
	* @description Create a Composio Connect Link for a user to connect their account to a given auth config. This method will return an external link which you can use the user to connect their account.
	*
	* @docs https://docs.composio.dev/reference/connected-accounts/create-connected-account#create-a-composio-connect-link
	*
	* @param userId {string} - The external user ID to create the connected account for.
	* @param authConfigId {string} - The auth config ID to create the connected account for.
	* @param options {CreateConnectedAccountOptions} - Options for creating a new connected account.
	* @param options.callbackUrl {string} - The url to redirect the user to post connecting their account.
	* @returns {ConnectionRequest} Connection request object
	*
	* @example
	* ```typescript
	* // create a connection request and redirect the user to the redirect url
	* const connectionRequest = await composio.connectedAccounts.link('user_123', 'auth_config_123');
	* const redirectUrl = connectionRequest.redirectUrl;
	* console.log(`Visit: ${redirectUrl} to authenticate your account`);
	*
	* // Wait for the connection to be established
	* const connectedAccount = await connectionRequest.waitForConnection()
	* ```
	*
	* @example
	* ```typescript
	* // create a connection request and redirect the user to the redirect url
	* const connectionRequest = await composio.connectedAccounts.link('user_123', 'auth_config_123', {
	*   callbackUrl: 'https://your-app.com/callback'
	* });
	* const redirectUrl = connectionRequest.redirectUrl;
	* console.log(`Visit: ${redirectUrl} to authenticate your account`);
	*
	* // Wait for the connection to be established
	* const connectedAccount = await composio.connectedAccounts.waitForConnection(connectionRequest.id);
	* ```
	*/
	async link(userId, authConfigId, options) {
		const requestOptions = await CreateConnectedAccountLinkOptionsSchema.safeParse(options || {});
		if (!requestOptions.success) throw new ValidationError("Failed to parse create connected account link options", { cause: requestOptions.error });
		try {
			const response = await this.client.link.create({
				auth_config_id: authConfigId,
				user_id: userId,
				...requestOptions?.data.callbackUrl && { callback_url: requestOptions.data.callbackUrl }
			});
			return createConnectionRequest(this.client, response.connected_account_id, ConnectedAccountStatuses.INITIATED, response.redirect_url);
		} catch (error) {
			throw new ComposioFailedToCreateConnectedAccountLink("Failed to create connected account link", { cause: error });
		}
	}
	/**
	* Waits for a connection request to complete and become active.
	*
	* This method continuously polls the Composio API to check the status of a connection
	* until it either becomes active, enters a terminal error state, or times out.
	*
	* @param {string} connectedAccountId - The ID of the connected account to wait for
	* @param {number} [timeout=60000] - Maximum time to wait in milliseconds (default: 60 seconds)
	* @returns {Promise<ConnectedAccountRetrieveResponse>} The finalized connected account data
	* @throws {ComposioConnectedAccountNotFoundError} If the connected account cannot be found
	* @throws {ConnectionRequestFailedError} If the connection enters a failed, expired, or deleted state
	* @throws {ConnectionRequestTimeoutError} If the connection does not complete within the timeout period
	*
	* @example
	* ```typescript
	* // Wait for a connection to complete with default timeout
	* const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc');
	*
	* // Wait with a custom timeout of 2 minutes
	* const connectedAccount = await composio.connectedAccounts.waitForConnection('conn_123abc', 120000);
	* ```
	*/
	async waitForConnection(connectedAccountId, timeout = 6e4) {
		return createConnectionRequest(this.client, connectedAccountId).waitForConnection(timeout);
	}
	/**
	* Retrieves a specific connected account by its ID.
	*
	* This method fetches detailed information about a single connected account
	* and transforms the response to the SDK's standardized format.
	*
	* @param {string} nanoid - The unique identifier of the connected account
	* @returns {Promise<ConnectedAccountRetrieveResponse>} The connected account details
	* @throws {Error} If the connected account cannot be found or an API error occurs
	*
	* @example
	* ```typescript
	* // Get a connected account by ID
	* const account = await composio.connectedAccounts.get('conn_abc123');
	* console.log(account.status); // e.g., 'ACTIVE'
	* console.log(account.toolkit.slug); // e.g., 'github'
	* ```
	*/
	async get(nanoid) {
		return transformConnectedAccountResponse(await this.client.connectedAccounts.retrieve(nanoid));
	}
	/**
	* Deletes a connected account.
	*
	* This method permanently removes a connected account from the Composio platform.
	* This action cannot be undone and will revoke any access tokens associated with the account.
	*
	* @param {string} nanoid - The unique identifier of the connected account to delete
	* @returns {Promise<ConnectedAccountDeleteResponse>} The deletion response
	* @throws {Error} If the account doesn't exist or cannot be deleted
	*
	* @example
	* ```typescript
	* // Delete a connected account
	* await composio.connectedAccounts.delete('conn_abc123');
	* ```
	*/
	async delete(nanoid) {
		return this.client.connectedAccounts.delete(nanoid);
	}
	/**
	* Refreshes a connected account's authentication credentials.
	*
	* This method attempts to refresh OAuth tokens or other credentials associated with
	* the connected account. This is useful when a token has expired or is about to expire.
	*
	* @param {string} nanoid - The unique identifier of the connected account to refresh
	* @returns {Promise<ConnectedAccountRefreshResponse>} The response containing the refreshed account details
	* @throws {Error} If the account doesn't exist or credentials cannot be refreshed
	*
	* @example
	* ```typescript
	* // Refresh a connected account's credentials
	* const refreshedAccount = await composio.connectedAccounts.refresh('conn_abc123');
	* ```
	*/
	async refresh(nanoid, options) {
		let params = void 0;
		if (options) {
			const parsedOptions = ConnectedAccountRefreshOptionsSchema.safeParse(options);
			if (!parsedOptions.success) throw new ValidationError("Failed to parse connected account refresh options", { cause: parsedOptions.error });
			params = {
				body_redirect_url: parsedOptions.data.redirectUrl,
				validate_credentials: parsedOptions.data.validateCredentials
			};
		}
		return this.client.connectedAccounts.refresh(nanoid, params);
	}
	/**
	* Update the status of a connected account
	* @param {string} nanoid - Unique identifier of the connected account
	* @param {ConnectedAccountUpdateStatusParams} params - Parameters for updating the status
	* @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
	*
	* @example
	* ```typescript
	* // Enable a connected account
	* const updatedAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
	*   enabled: true
	* });
	*
	* // Disable a connected account with a reason
	* const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
	*   enabled: false,
	*   reason: 'Token expired'
	* });
	* ```
	*/
	async updateStatus(nanoid, params) {
		return this.client.connectedAccounts.updateStatus(nanoid, params);
	}
	/**
	* Enable a connected account
	* @param {string} nanoid - Unique identifier of the connected account
	* @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
	*
	* @example
	* ```typescript
	* // Enable a previously disabled connected account
	* const enabledAccount = await composio.connectedAccounts.enable('conn_abc123');
	* console.log(enabledAccount.isDisabled); // false
	* ```
	*/
	async enable(nanoid) {
		return this.client.connectedAccounts.updateStatus(nanoid, { enabled: true });
	}
	/**
	* Disable a connected account
	* @param {string} nanoid - Unique identifier of the connected account
	* @returns {Promise<ConnectedAccountUpdateStatusResponse>} Updated connected account details
	*
	* @example
	* ```typescript
	* // Disable a connected account
	* const disabledAccount = await composio.connectedAccounts.disable('conn_abc123');
	* console.log(disabledAccount.isDisabled); // true
	*
	* // You can also use updateStatus with a reason
	* // const disabledAccount = await composio.connectedAccounts.updateStatus('conn_abc123', {
	* //   enabled: false,
	* //   reason: 'No longer needed'
	* // });
	* ```
	*/
	async disable(nanoid) {
		return this.client.connectedAccounts.updateStatus(nanoid, { enabled: false });
	}
};

//#endregion
//#region src/utils/transformers/toolkits.ts
const transformToolkitListResponse = (response) => {
	return transform(response).with(ToolKitListResponseSchema).using((response$1) => response$1.items.map((item) => ({
		name: item.name,
		slug: item.slug,
		meta: {
			...item.meta,
			categories: item.meta.categories?.map((category) => ({
				slug: category.id,
				name: category.name
			})),
			createdAt: item.meta.created_at,
			description: item.meta.description,
			logo: item.meta.logo,
			toolsCount: item.meta.tools_count,
			triggersCount: item.meta.triggers_count,
			updatedAt: item.meta.updated_at,
			appUrl: item.meta.app_url ?? void 0
		},
		isLocalToolkit: item.is_local_toolkit,
		authSchemes: item.auth_schemes,
		composioManagedAuthSchemes: item.composio_managed_auth_schemes,
		noAuth: item.no_auth
	})));
};
const transformToolkitRetrieveResponse = (response) => {
	return transform(response).with(ToolkitRetrieveResponseSchema).using((response$1) => ({
		name: response$1.name,
		slug: response$1.slug,
		meta: {
			...response$1.meta,
			createdAt: response$1.meta.created_at,
			updatedAt: response$1.meta.updated_at,
			toolsCount: response$1.meta.tools_count,
			triggersCount: response$1.meta.triggers_count,
			categories: response$1.meta.categories?.map((category) => ({
				slug: category.slug,
				name: category.name
			})),
			availableVersions: response$1.meta.available_versions
		},
		isLocalToolkit: response$1.is_local_toolkit,
		composioManagedAuthSchemes: response$1.composio_managed_auth_schemes,
		authConfigDetails: response$1.auth_config_details?.map((authConfig) => ({
			name: authConfig.name,
			mode: authConfig.mode,
			fields: {
				authConfigCreation: authConfig.fields.auth_config_creation,
				connectedAccountInitiation: authConfig.fields.connected_account_initiation
			},
			proxy: { baseUrl: authConfig.proxy?.base_url }
		})),
		baseUrl: response$1.base_url,
		getCurrentUserEndpoint: response$1.get_current_user_endpoint,
		getCurrentUserEndpointMethod: response$1.get_current_user_endpoint_method
	}));
};
const transformToolkitRetrieveCategoriesResponse = (response) => {
	return transform(response).with(ToolkitRetrieveCategoriesResponseSchema).using((response$1) => ({
		items: response$1.items.map((item) => ({
			id: item.id,
			name: item.name
		})),
		nextCursor: response$1.next_cursor ?? null,
		totalPages: response$1.total_pages
	}));
};

//#endregion
//#region src/models/Toolkits.ts
/**
* Toolkits class
*
* Toolkits are a collection of tools that can be used to perform various tasks.
* This is similar/replacement of `apps` in the Composio API.
*/
var Toolkits = class {
	client;
	constructor(client) {
		this.client = client;
		this.authorize = this.authorize.bind(this);
		telemetry.instrument(this, "Toolkits");
	}
	/**
	* Retrieves a list of toolkits based on the provided query parameters.
	*
	* This method fetches toolkits from the Composio API and transforms the response
	* from snake_case to camelCase format for consistency with JavaScript/TypeScript conventions.
	*
	* @param {ToolkitListParams} query - The query parameters to filter toolkits
	* @returns {Promise<ToolKitListResponse>} The transformed list of toolkits
	*
	* @private
	*/
	async getToolkits(query) {
		try {
			const parsedQuery = ToolkitsListParamsSchema.safeParse(query);
			if (!parsedQuery.success) throw new ValidationError("Failed to parse toolkit list query", { cause: parsedQuery.error });
			return transformToolkitListResponse(await this.client.toolkits.list({
				category: parsedQuery.data.category,
				managed_by: parsedQuery.data.managedBy,
				sort_by: parsedQuery.data.sortBy,
				cursor: parsedQuery.data.cursor,
				limit: parsedQuery.data.limit
			}));
		} catch (error) {
			throw new ComposioToolkitFetchError("Failed to fetch toolkits", { cause: error });
		}
	}
	/**
	* Retrieves a specific toolkit by its slug identifier.
	*
	* This method fetches a single toolkit from the Composio API and transforms
	* the response to use camelCase property naming consistent with JavaScript/TypeScript conventions.
	*
	* @param {string} slug - The unique slug identifier of the toolkit to retrieve
	* @returns {Promise<ToolkitRetrieveResponse>} The transformed toolkit object
	* @throws {ValidationError} If the response cannot be properly parsed
	* @throws {ComposioToolNotFoundError} If no toolkit with the given slug exists
	*
	* @private
	*/
	async getToolkitBySlug(slug) {
		try {
			return transformToolkitRetrieveResponse(await this.client.toolkits.retrieve(slug));
		} catch (error) {
			if (error instanceof APIError$1 && (error.status === 404 || error.status === 400)) throw new ComposioToolkitNotFoundError(`Toolkit with slug ${slug} not found`, {
				meta: { slug },
				cause: error
			});
			throw new ComposioToolkitFetchError(`Couldn't fetch Toolkit with slug: ${slug}`, {
				meta: { slug },
				cause: error
			});
		}
	}
	/**
	* Implementation method that handles both overloads for retrieving toolkits.
	*
	* @param {string | ToolkitListParams} arg - Either a toolkit slug or query parameters
	* @returns {Promise<ToolkitRetrieveResponse | ToolKitListResponse>} The toolkit or list of toolkits
	*/
	async get(arg) {
		if (typeof arg === "string") return this.getToolkitBySlug(arg);
		return this.getToolkits(arg ?? {});
	}
	async getAuthConfigFields(toolkitSlug, authScheme, authConfigType, requiredOnly) {
		const toolkit = await this.getToolkitBySlug(toolkitSlug);
		if (!toolkit.authConfigDetails) throw new ComposioAuthConfigNotFoundError("No auth config found for toolkit", { meta: { toolkitSlug } });
		if (toolkit.authConfigDetails.length > 1 && !authScheme) logger_default.warn(`Multiple auth configs found for ${toolkitSlug}, please specify the auth scheme to get details of specific auth scheme. Selecting the first scheme by default.`, { meta: { toolkitSlug } });
		const authConfig = authScheme ? toolkit.authConfigDetails.find((authConfig$1) => authConfig$1.mode === authScheme) : toolkit.authConfigDetails[0];
		if (!authConfig) throw new ComposioAuthConfigNotFoundError(`Auth schema ${authScheme} not found for toolkit ${toolkitSlug} with auth scheme ${authScheme}`, { meta: {
			toolkitSlug,
			authScheme
		} });
		const requiredFields = authConfig.fields[authConfigType].required.map((field) => ({
			...field,
			required: true
		}));
		if (requiredOnly) return requiredFields;
		const optionalFields = authConfig.fields[authConfigType].optional.map((field) => ({
			...field,
			required: false
		}));
		return [...requiredFields, ...optionalFields];
	}
	/**
	* Retrieves the fields required for creating an auth config for a toolkit.
	* @param toolkitSlug - The slug of the toolkit to retrieve the fields for
	* @param authScheme - The auth scheme to retrieve the fields for
	* @param options.requiredOnly - Whether to only return the required fields
	* @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for creating an auth config
	*/
	async getAuthConfigCreationFields(toolkitSlug, authScheme, { requiredOnly = false } = {}) {
		return this.getAuthConfigFields(toolkitSlug, authScheme ?? null, "authConfigCreation", requiredOnly);
	}
	/**
	* Retrieves the fields required for initiating a connected account for a toolkit.
	* @param toolkitSlug - The slug of the toolkit to retrieve the fields for
	* @param authScheme - The auth scheme to retrieve the fields for
	* @param options.requiredOnly - Whether to only return the required fields
	* @returns {Promise<ToolkitAuthFieldsResponse>} The fields required for initiating a connected account
	*/
	async getConnectedAccountInitiationFields(toolkitSlug, authScheme, { requiredOnly = false } = {}) {
		return this.getAuthConfigFields(toolkitSlug, authScheme ?? null, "connectedAccountInitiation", requiredOnly);
	}
	/**
	* Retrieves all toolkit categories available in the Composio SDK.
	*
	* This method fetches the complete list of categories from the Composio API
	* and transforms the response to use camelCase property naming.
	*
	* @returns {Promise<ToolkitRetrieveCategoriesResponse>} The list of toolkit categories
	*
	* @example
	* ```typescript
	* // Get all toolkit categories
	* const categories = await composio.toolkits.listCategories();
	* console.log(categories.items); // Array of category objects
	* ```
	*/
	async listCategories() {
		return transformToolkitRetrieveCategoriesResponse(await this.client.toolkits.retrieveCategories());
	}
	/**
	* Authorizes a user to use a toolkit.
	* This method will create an auth config if one doesn't exist and initiate a connection request.
	* @param {string} userId - The user id of the user to authorize
	* @param {string} toolkitSlug - The slug of the toolkit to authorize
	* @returns {Promise<ConnectionRequest>} The connection request object
	*
	* @example
	* ```typescript
	* const connectionRequest = await composio.toolkits.authorize(userId, 'github');
	* ```
	*
	*/
	async authorize(userId, toolkitSlug, authConfigId) {
		const toolkit = await this.getToolkitBySlug(toolkitSlug);
		const composioAuthConfig = new AuthConfigs(this.client);
		let authConfigIdToUse = authConfigId;
		if (!authConfigIdToUse) authConfigIdToUse = (await composioAuthConfig.list({ toolkit: toolkitSlug })).items[0]?.id;
		if (!authConfigIdToUse) if (toolkit.authConfigDetails && toolkit.authConfigDetails.length > 0) try {
			authConfigIdToUse = (await composioAuthConfig.create(toolkitSlug, {
				type: "use_composio_managed_auth",
				name: `${toolkit.name} Auth Config`
			})).id;
		} catch (error) {
			if (error instanceof ComposioClient.APIError && error.status === 400) throw new ComposioAuthConfigNotFoundError(`No Default auth config found for toolkit ${toolkitSlug}`, {
				meta: { toolkitSlug },
				cause: error,
				possibleFixes: [`Please Create an auth config for the toolkit ${toolkitSlug} via the dashboard`]
			});
			throw error;
		}
		else throw new ComposioAuthConfigNotFoundError(`No auth configs found for toolkit ${toolkitSlug}`, { meta: { toolkitSlug } });
		return await new ConnectedAccounts(this.client).initiate(userId, authConfigIdToUse, { allowMultiple: true });
	}
};

//#endregion
//#region src/types/triggers.types.ts
const TriggerStatuses = {
	ENABLE: "enable",
	DISABLE: "disable"
};
const TriggerStatusEnum = z$1.enum(["enable", "disable"]);
const TriggerSubscribeParamSchema = z$1.object({
	toolkits: z$1.array(z$1.string()).optional(),
	triggerId: z$1.string().optional(),
	connectedAccountId: z$1.string().optional(),
	authConfigId: z$1.string().optional(),
	triggerSlug: z$1.array(z$1.string()).optional(),
	triggerData: z$1.string().optional(),
	userId: z$1.string().optional()
});
const TriggerInstanceListActiveParamsSchema = z$1.object({
	authConfigIds: z$1.array(z$1.string()).nullable().optional(),
	connectedAccountIds: z$1.array(z$1.string()).nullable().optional(),
	limit: z$1.number().optional(),
	cursor: z$1.string().optional(),
	showDisabled: z$1.boolean().nullable().optional(),
	triggerIds: z$1.array(z$1.string()).nullable().optional(),
	triggerNames: z$1.array(z$1.string()).nullable().optional()
});
const TriggerInstanceListActiveResponseItemSchema = z$1.object({
	id: z$1.string(),
	connectedAccountId: z$1.string(),
	disabledAt: z$1.string().nullable(),
	state: z$1.record(z$1.unknown()),
	triggerConfig: z$1.record(z$1.unknown()),
	triggerName: z$1.string(),
	updatedAt: z$1.string(),
	triggerData: z$1.string().optional(),
	uuid: z$1.string().optional()
});
const TriggerInstanceListActiveResponseSchema = z$1.object({
	items: z$1.array(TriggerInstanceListActiveResponseItemSchema),
	nextCursor: z$1.string().nullable(),
	totalPages: z$1.number()
});
const TriggerInstanceUpsertParamsSchema = z$1.object({
	connectedAccountId: z$1.string().optional(),
	triggerConfig: z$1.record(z$1.unknown()).optional()
});
const TriggerInstanceUpsertResponseSchema = z$1.object({ triggerId: z$1.string() });
const TriggerInstanceManageUpdateParamsSchema = z$1.object({ status: z$1.enum(["enable", "disable"]) });
const TriggerInstanceManageUpdateResponseSchema = z$1.object({ status: z$1.enum(["success"]) });
const TriggerInstanceManageDeleteResponseSchema = z$1.object({ triggerId: z$1.string() });
const IncomingTriggerPayloadSchema = z$1.object({
	id: z$1.string().describe("The ID of the trigger"),
	uuid: z$1.string().describe("The UUID of the trigger"),
	triggerSlug: z$1.string().describe("The slug of the trigger that triggered the event"),
	toolkitSlug: z$1.string().describe("The slug of the toolkit that triggered the event"),
	userId: z$1.string().describe("The ID of the user that triggered the event"),
	payload: z$1.record(z$1.unknown()).describe("The payload of the trigger").optional(),
	originalPayload: z$1.record(z$1.unknown()).describe("The original payload of the trigger").optional(),
	metadata: z$1.object({
		id: z$1.string(),
		uuid: z$1.string(),
		toolkitSlug: z$1.string(),
		triggerSlug: z$1.string(),
		triggerData: z$1.string().optional(),
		triggerConfig: z$1.record(z$1.unknown()),
		connectedAccount: z$1.object({
			id: z$1.string(),
			uuid: z$1.string(),
			authConfigId: z$1.string(),
			authConfigUUID: z$1.string(),
			userId: z$1.string(),
			status: z$1.enum(["ACTIVE", "INACTIVE"])
		})
	})
});
const TriggersTypeListParamsSchema = z$1.object({
	cursor: z$1.string().optional(),
	limit: z$1.number().nullish(),
	toolkits: z$1.array(z$1.string()).nullish()
});
const TriggerTypeSchema = z$1.object({
	slug: z$1.string(),
	name: z$1.string(),
	description: z$1.string(),
	instructions: z$1.string().optional(),
	toolkit: z$1.object({
		logo: z$1.string(),
		slug: z$1.string(),
		name: z$1.string()
	}),
	payload: z$1.record(z$1.unknown()),
	config: z$1.record(z$1.unknown()),
	version: z$1.string().optional()
});
const TriggersTypeListResponseSchema = z$1.object({
	items: z$1.array(TriggerTypeSchema),
	nextCursor: z$1.string().nullish(),
	totalPages: z$1.number()
});
/**
* Webhook payload schemas for V1, V2, V3 versions
* These schemas represent the raw payload structure sent by Composio's webhook system
*/
/** V1 webhook payload - legacy format */
const WebhookPayloadV1Schema = z$1.object({
	trigger_name: z$1.string(),
	connection_id: z$1.string(),
	trigger_id: z$1.string(),
	payload: z$1.record(z$1.unknown()),
	log_id: z$1.string()
});
/** V2 webhook payload - includes timestamp and nested data */
const WebhookPayloadV2Schema = z$1.object({
	type: z$1.string(),
	timestamp: z$1.string(),
	log_id: z$1.string(),
	data: z$1.object({
		connection_id: z$1.string(),
		connection_nano_id: z$1.string(),
		trigger_nano_id: z$1.string(),
		trigger_id: z$1.string(),
		user_id: z$1.string()
	}).passthrough()
});
/** V3 webhook payload - current format with metadata */
const WebhookPayloadV3Schema = z$1.object({
	id: z$1.string(),
	timestamp: z$1.string(),
	type: z$1.literal("composio.trigger.message"),
	metadata: z$1.object({
		log_id: z$1.string(),
		trigger_slug: z$1.string(),
		trigger_id: z$1.string(),
		connected_account_id: z$1.string(),
		auth_config_id: z$1.string(),
		user_id: z$1.string()
	}),
	data: z$1.record(z$1.unknown())
});
/** Union of all webhook payload versions */
const WebhookPayloadSchema = z$1.union([
	WebhookPayloadV3Schema,
	WebhookPayloadV2Schema,
	WebhookPayloadV1Schema
]);
/** Webhook version enum */
const WebhookVersions = {
	V1: "V1",
	V2: "V2",
	V3: "V3"
};
/**
* Parameters for verifying a webhook signature
*/
const VerifyWebhookParamsSchema = z$1.object({
	id: z$1.string({
		required_error: "Missing 'id' parameter. Pass the value of the 'webhook-id' HTTP header.",
		invalid_type_error: "Invalid 'id' parameter. Expected string from 'webhook-id' HTTP header."
	}),
	payload: z$1.string({
		required_error: "Missing 'payload' parameter. Pass the raw request body as a string (do not parse it).",
		invalid_type_error: "Invalid 'payload' parameter. Expected string (raw request body)."
	}),
	secret: z$1.string({
		required_error: "Missing 'secret' parameter. Get your webhook secret from the Composio dashboard.",
		invalid_type_error: "Invalid 'secret' parameter. Expected string."
	}),
	signature: z$1.string({
		required_error: "Missing 'signature' parameter. Pass the value of the 'webhook-signature' HTTP header.",
		invalid_type_error: "Invalid 'signature' parameter. Expected string from 'webhook-signature' HTTP header."
	}),
	timestamp: z$1.string({
		required_error: "Missing 'timestamp' parameter. Pass the value of the 'webhook-timestamp' HTTP header.",
		invalid_type_error: "Invalid 'timestamp' parameter. Expected string from 'webhook-timestamp' HTTP header."
	}),
	tolerance: z$1.number().optional().default(300)
});

//#endregion
//#region src/services/internal/InternalService.types.ts
const SDKRealtimeCredentialsResponseSchema = z$1.object({
	projectId: z$1.string().describe("The project ID"),
	pusherKey: z$1.string().describe("The Pusher key"),
	pusherCluster: z$1.string().describe("The Pusher cluster")
});

//#endregion
//#region src/services/internal/InternalService.ts
const SDK_REALTIME_CREDENTIALS_ENDPOINT = "/api/v3/internal/sdk/realtime/credentials";
var InternalService = class {
	constructor(client) {
		this.client = client;
		this.client = client;
	}
	/**
	* Get the SDK realtime credentials
	* @returns {SDKRealtimeCredentialsResponse} The SDK realtime credentials
	*/
	async getSDKRealtimeCredentials() {
		const response = await this.client.request({
			method: "get",
			path: SDK_REALTIME_CREDENTIALS_ENDPOINT
		});
		const parsedResponse = SDKRealtimeCredentialsResponseSchema.safeParse({
			pusherKey: response.pusher_key,
			projectId: response.project_id,
			pusherCluster: response.pusher_cluster
		});
		logger_default.debug(`[InternalService] SDK realtime credentials: ${JSON.stringify(parsedResponse, null, 2)}`);
		if (!parsedResponse.success) throw new ValidationError(`Failed to parse SDK realtime credentials`, { cause: parsedResponse.error });
		return parsedResponse.data;
	}
};

//#endregion
//#region src/services/pusher/Pusher.ts
var PusherService = class {
	clientId;
	pusherKey;
	pusherCluster;
	pusherChannel;
	pusherBaseURL;
	apiKey;
	pusherClient;
	composioClient;
	constructor(client) {
		this.composioClient = client;
		this.pusherBaseURL = client.baseURL;
		this.apiKey = client.apiKey ?? process.env.COMPOSIO_API_KEY ?? "";
		telemetry.instrument(this, "PusherService");
	}
	/**
	* Creates a Pusher client
	*
	* This method is called when the Pusher client is first used.
	* It will fetch the SDK realtime credentials from the Apollo API and create a Pusher client.
	*/
	async getPusherClient() {
		if (!this.pusherClient) {
			const internalService = new InternalService(this.composioClient);
			let sdkRealtimeCredentials;
			try {
				sdkRealtimeCredentials = await internalService.getSDKRealtimeCredentials();
			} catch (error) {
				throw new ComposioFailedToGetSDKRealtimeCredentialsError("Failed to get SDK realtime credentials", { cause: error });
			}
			this.clientId = sdkRealtimeCredentials.projectId;
			this.pusherKey = sdkRealtimeCredentials.pusherKey;
			this.pusherCluster = sdkRealtimeCredentials.pusherCluster;
			this.pusherChannel = `private-${this.clientId}_triggers`;
			logger_default.debug(`[PusherService] Creating Pusher client for client ID: ${this.clientId} in cluster ${this.pusherCluster}`);
			try {
				const { default: Pusher } = await import("pusher-js");
				this.pusherClient = new Pusher(this.pusherKey, {
					cluster: this.pusherCluster,
					channelAuthorization: {
						endpoint: `${this.pusherBaseURL}/api/v3/internal/sdk/realtime/auth`,
						headers: { "x-api-key": this.apiKey },
						transport: "ajax"
					}
				});
			} catch (error) {
				throw new ComposioFailedToCreatePusherClientError("Failed to create Pusher client", { cause: error });
			}
		}
		return this.pusherClient;
	}
	/**
	* Binds a chunked event to a Pusher client
	*
	*
	* @param channel - The Pusher client to bind the event to
	* @param event - The event to bind to
	* @param callback - The function to call when the event is received
	*/
	bindWithChunking(channel, event, callback) {
		try {
			channel.bind(event, callback);
			const events = {};
			channel.bind("chunked-" + event, (data) => {
				try {
					const typedData = data;
					if (!typedData || typeof typedData.id !== "string" || typeof typedData.index !== "number") throw new Error("Invalid chunked trigger data format");
					if (!events.hasOwnProperty(typedData.id)) events[typedData.id] = {
						chunks: [],
						receivedFinal: false
					};
					const ev = events[typedData.id];
					ev.chunks[typedData.index] = typedData.chunk;
					if (typedData.final) ev.receivedFinal = true;
					if (ev.receivedFinal && ev.chunks.length === Object.keys(ev.chunks).length) try {
						callback(JSON.parse(ev.chunks.join("")));
					} catch (parseError) {
						const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
						logger_default.error("Failed to parse chunked data:", errorMessage);
					} finally {
						delete events[typedData.id];
					}
				} catch (error) {
					const errorMessage = error instanceof Error ? error.message : String(error);
					logger_default.error("Error processing chunked trigger data:", errorMessage);
					if (data && typeof data === "object" && "id" in data) delete events[data.id];
				}
			});
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			logger_default.error("Failed to bind chunked events:", error);
			throw new Error(`Failed to bind chunked events: ${errorMessage}`);
		}
	}
	/**
	* Subscribes to pusher to receive events from the server
	*
	* This method is used to subscribe to a Pusher channel.
	* It will create a Pusher client if it doesn't exist.
	*
	* @param channelName - The name of the Pusher channel to subscribe to
	* @param event - The event to subscribe to
	* @param fn - The function to call when the event is received
	*/
	async subscribe(fn) {
		try {
			logger_default.debug(`[PusherService] Subscribing to channel: ${this.pusherChannel}`);
			const channel = await (await this.getPusherClient()).subscribe(this.pusherChannel);
			channel.bind("pusher:subscription_error", (data) => {
				const error = data.error ? String(data.error) : "Unknown subscription error";
				throw new ComposioFailedToSubscribeToPusherChannelError(`Trigger subscription error: ${error}`, { cause: error });
			});
			const safeCallback = (data) => {
				try {
					fn(data);
				} catch (error) {
					const errorMessage = error instanceof Error ? error.message : String(error);
					logger_default.error("❌ Error in trigger callback:", errorMessage);
				}
			};
			this.bindWithChunking(channel, "trigger_to_client", safeCallback);
			logger_default.info(`✅ Subscribed to triggers. You should start receiving events now.`);
		} catch (error) {
			throw new ComposioFailedToSubscribeToPusherChannelError("Failed to subscribe to Pusher channel", { cause: error });
		}
	}
	/**
	* Unsubscribes from a Pusher channel
	*
	* This method is used to unsubscribe from a Pusher channel.
	* It will create a Pusher client if it doesn't exist.
	*
	* @param channelName - The name of the Pusher channel to unsubscribe from
	*/
	async unsubscribe() {
		try {
			logger_default.debug(`[PusherService] Unsubscribing from channel: ${this.pusherChannel}`);
			await (await this.getPusherClient()).unsubscribe(this.pusherChannel);
			logger_default.info(`✅ Unsubscribed from triggers.`);
		} catch (error) {
			throw new ComposioFailedToSubscribeToPusherChannelError("Failed to unsubscribe from Pusher channel", { cause: error });
		}
	}
};

//#endregion
//#region src/utils/transformers/triggers.ts
function transformIncomingTriggerPayload(response) {
	return transform(response).with(IncomingTriggerPayloadSchema).using((response$1) => ({
		id: response$1.metadata.nanoId,
		uuid: response$1.metadata.id,
		triggerSlug: response$1.metadata.triggerName,
		toolkitSlug: response$1.appName,
		userId: response$1.metadata.connection?.clientUniqueUserId,
		payload: response$1.payload,
		originalPayload: response$1.originalPayload,
		metadata: {
			id: response$1.metadata.nanoId,
			uuid: response$1.metadata.id,
			triggerConfig: response$1.metadata.triggerConfig,
			triggerSlug: response$1.metadata.triggerName,
			toolkitSlug: response$1.appName,
			triggerData: response$1.metadata.triggerData,
			connectedAccount: {
				id: response$1.metadata.connection?.connectedAccountNanoId,
				uuid: response$1.metadata.connection?.id,
				authConfigId: response$1.metadata.connection?.authConfigNanoId,
				authConfigUUID: response$1.metadata.connection?.integrationId,
				userId: response$1.metadata.connection?.clientUniqueUserId,
				status: response$1.metadata.connection?.status
			}
		}
	}));
}
function transformTriggerTypeRetrieveResponse(response) {
	return transform(response).with(TriggerTypeSchema).using((response$1) => ({
		slug: response$1.slug,
		name: response$1.name,
		description: response$1.description,
		instructions: response$1.instructions,
		toolkit: {
			logo: response$1.toolkit.logo,
			slug: response$1.toolkit.slug,
			name: response$1.toolkit.name
		},
		version: response$1.version,
		payload: response$1.payload,
		config: response$1.config
	}));
}
function transformTriggerTypeListResponse(response) {
	return transform(response).with(TriggersTypeListResponseSchema).using((response$1) => ({
		items: response$1.items,
		nextCursor: response$1.next_cursor ?? null,
		totalPages: response$1.total_pages
	}));
}
/**
* Parse the trigger instance list active item
*
* @param response - The response from the composio client
* @returns The parsed trigger instance list active item
*/
function transformTriggerInstanceListActiveItem(response) {
	return transform(response).with(TriggerInstanceListActiveResponseItemSchema).using((response$1) => ({
		id: response$1.id,
		connectedAccountId: response$1.connected_account_id,
		disabledAt: response$1.disabled_at,
		state: response$1.state,
		triggerConfig: response$1.trigger_config,
		triggerName: response$1.trigger_name,
		updatedAt: response$1.updated_at,
		triggerData: response$1.trigger_data,
		uuid: response$1.uuid
	}));
}
function transformTriggerInstanceListActiveResponse(response) {
	return transform(response).with(TriggerInstanceListActiveResponseSchema).using((response$1) => ({
		items: response$1.items.map((item) => transformTriggerInstanceListActiveItem(item)),
		nextCursor: response$1.next_cursor ?? null,
		totalPages: response$1.total_pages
	}));
}

//#endregion
//#region src/utils/crypto.ts
/**
* Computes HMAC-SHA256 using Web Crypto API
*/
async function hmacSha256Base64(secret, message) {
	const encoder = new TextEncoder();
	const keyData = encoder.encode(secret);
	const key = await globalThis.crypto.subtle.importKey("raw", keyData, {
		name: "HMAC",
		hash: "SHA-256"
	}, false, ["sign"]);
	const signatureData = encoder.encode(message);
	return arrayBufferToBase64(await globalThis.crypto.subtle.sign("HMAC", key, signatureData));
}
/**
* Constant-time comparison of two strings to prevent timing attacks
*/
function timingSafeEqual(a, b) {
	if (a.length !== b.length) return false;
	let result = 0;
	for (let i = 0; i < a.length; i++) result |= a.charCodeAt(i) ^ b.charCodeAt(i);
	return result === 0;
}

//#endregion
//#region src/models/Triggers.ts
/**
* Safely converts a value to a string, returning the default if the value is null, undefined, or empty.
* This prevents runtime crashes when calling string methods like `.toLowerCase()` on non-string values.
* @private
*/
const toStringOrDefault = (value, defaultValue) => {
	if (value === null || value === void 0) return defaultValue;
	const str = String(value);
	return str.length > 0 ? str : defaultValue;
};
/**
* Trigger (Instance) class
* /api/v3/trigger_instances
*
*/
var Triggers = class {
	client;
	pusherService;
	toolkitVersions;
	constructor(client, config) {
		this.client = client;
		this.pusherService = new PusherService(client);
		this.toolkitVersions = config?.toolkitVersions ?? CONFIG_DEFAULTS.toolkitVersions;
		telemetry.instrument(this, "Triggers");
	}
	/**
	* Fetch list of all the active triggers
	*
	* @param {TriggerInstanceListActiveParams} query - The query parameters to filter the trigger instances
	* @returns {Promise<TriggerInstanceListActiveResponse>} List of trigger instances
	*
	* @throws {ValidationError} If the parameters are invalid
	* @throws {Error} If the client is not authenticated
	*
	* @example
	* ```ts
	* const triggers = await triggers.listActive({
	*   authConfigIds: ['123'],
	*   connectedAccountIds: ['456'],
	* });
	* ```
	*/
	async listActive(query) {
		const parsedParams = TriggerInstanceListActiveParamsSchema.safeParse(query ?? {});
		if (!parsedParams.success) throw new ValidationError(`Invalid parameters passed to list triggers`, { cause: parsedParams.error });
		return transformTriggerInstanceListActiveResponse(await this.client.triggerInstances.listActive(query ? {
			auth_config_ids: parsedParams.data.authConfigIds,
			connected_account_ids: parsedParams.data.connectedAccountIds,
			cursor: parsedParams.data.cursor,
			limit: parsedParams.data.limit,
			show_disabled: parsedParams.data.showDisabled,
			trigger_ids: parsedParams.data.triggerIds,
			trigger_names: parsedParams.data.triggerNames
		} : void 0));
	}
	/**
	* Create a new trigger instance for a user
	* If the connected account id is not provided, the first connected account for the user and toolkit will be used
	*
	* @param {string} userId - The user id of the trigger instance
	* @param {string} slug - The slug of the trigger instance
	* @param {TriggerInstanceUpsertParams} body - The parameters to create the trigger instance
	* @returns {Promise<TriggerInstanceUpsertResponse>} The created trigger instance
	*/
	async create(userId, slug, body) {
		const parsedBody = TriggerInstanceUpsertParamsSchema.safeParse(body ?? {});
		if (!parsedBody.success) throw new ValidationError(`Invalid parameters passed to create trigger`, { cause: parsedBody.error });
		let triggerType;
		let toolkitSlug;
		try {
			triggerType = await this.getType(slug);
			toolkitSlug = triggerType.toolkit.slug;
		} catch (error) {
			if (error instanceof APIError && (error.status === 400 || error.status === 404)) throw new ComposioTriggerTypeNotFoundError(`Trigger type ${slug} not found`, {
				cause: error,
				possibleFixes: [
					`Please check the trigger slug`,
					`Please check the provided version of toolkit has the trigger`,
					`Visit the toolkit page to see the available triggers`
				]
			});
			else throw error;
		}
		let connectedAccountId = body?.connectedAccountId;
		try {
			const { items: connectedAccounts } = await this.client.connectedAccounts.list({
				user_ids: [userId],
				toolkit_slugs: [toolkitSlug]
			});
			if (connectedAccounts.length === 0) throw new ComposioConnectedAccountNotFoundError(`No connected account found for user ${userId} for toolkit ${toolkitSlug}`, {
				cause: /* @__PURE__ */ new Error(`No connected account found for user ${userId}`),
				possibleFixes: [`Create a new connected account for user ${userId}`]
			});
			const accountExists = connectedAccounts.some((acc) => acc.id === connectedAccountId);
			if (connectedAccountId && !accountExists) throw new ComposioConnectedAccountNotFoundError(`Connected account ID ${connectedAccountId} not found for user ${userId}`, {
				cause: /* @__PURE__ */ new Error(`Connected account ID ${connectedAccountId} not found for user ${userId}`),
				possibleFixes: [`Create a new connected account for user ${userId}`, `Verify the connected account ID`]
			});
			if (!connectedAccountId) {
				connectedAccountId = connectedAccounts[0].id;
				logger_default.warn(`[Warn] Multiple connected accounts found for user ${userId}, using the first one. Pass connectedAccountId to select a specific account.`);
			}
		} catch (error) {
			if (error instanceof APIError && [400, 404].includes(error.status)) throw new ComposioConnectedAccountNotFoundError(`No connected account found for user ${userId} for toolkit ${toolkitSlug}`, {
				cause: error,
				possibleFixes: [`Create a new connected account for user ${userId}`]
			});
			throw error;
		}
		return { triggerId: (await this.client.triggerInstances.upsert(slug, {
			connected_account_id: connectedAccountId,
			trigger_config: parsedBody.data.triggerConfig,
			toolkit_versions: this.toolkitVersions
		})).trigger_id };
	}
	/**
	* Update an existing trigger instance
	*
	* @param {string} triggerId - The Id of the trigger instance
	* @param {TriggerInstanceManageUpdateParams} body - The parameters to update the trigger instance
	* @returns {Promise<TriggerInstanceManageUpdateResponse>} The updated trigger instance response
	*/
	async update(triggerId, body) {
		return this.client.triggerInstances.manage.update(triggerId, body);
	}
	/**
	* Delete a trigger instance
	*
	* @param {string} triggerId - The slug of the trigger instance
	* @returns
	*/
	async delete(triggerId) {
		return { triggerId: (await this.client.triggerInstances.manage.delete(triggerId)).trigger_id };
	}
	/**
	* Disable a trigger instance
	*
	* @param {string} triggerId - The id of the trigger instance
	* @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
	*/
	async disable(triggerId) {
		return this.client.triggerInstances.manage.update(triggerId, { status: "disable" });
	}
	/**
	* Enable a trigger instance
	*
	* @param {string} triggerId - The id of the trigger instance
	* @returns {Promise<TriggerInstanceUpsertResponse>} The updated trigger instance
	*/
	async enable(triggerId) {
		return this.client.triggerInstances.manage.update(triggerId, { status: "enable" });
	}
	/**
	* @TODO Learn about trigger types
	*/
	/**
	* List all the trigger types
	*
	* @param {TriggersTypeListParams} query - The query parameters to filter the trigger types
	* @param {RequestOptions} options - Request options
	* @returns {Promise<TriggersTypeListResponse>} The list of trigger types
	*/
	async listTypes(query) {
		const parsedQuery = transform(query ?? {}).with(TriggersTypeListParamsSchema).using((raw) => raw);
		return transformTriggerTypeListResponse(await this.client.triggersTypes.list({
			cursor: parsedQuery.cursor,
			limit: parsedQuery.limit,
			toolkit_slugs: parsedQuery.toolkits,
			toolkit_versions: this.toolkitVersions
		}));
	}
	/**
	* Retrieve a trigger type by its slug for the provided version of the app
	* Use the global toolkit versions param when initializing composio to pass a toolkitversion
	*
	* @param {string} slug - The slug of the trigger type
	* @returns {Promise<TriggersTypeRetrieveResponse>} The trigger type object
	*/
	async getType(slug) {
		return transformTriggerTypeRetrieveResponse(await this.client.triggersTypes.retrieve(slug, { toolkit_versions: this.toolkitVersions }));
	}
	/**
	* Fetches the list of all the available trigger enums
	*
	* This method is used by the CLI where filters are not required.
	* @returns
	*/
	async listEnum() {
		return this.client.triggersTypes.retrieveEnum();
	}
	/**
	* Applies compound filters to the trigger data
	* @param data data to apply filters to
	* @returns True if the trigger data matches the filters, false otherwise
	*/
	shouldSendTriggerAfterFilters(filters, data) {
		if (filters.toolkits?.length && !filters.toolkits.map((toolkit) => toolkit.toLowerCase()).includes(data.toolkitSlug.toLowerCase())) {
			logger_default.debug("Trigger does not match toolkits filter", JSON.stringify(filters.toolkits, null, 2));
			return false;
		}
		if (filters.triggerId && filters.triggerId !== data.id) {
			logger_default.debug("Trigger does not match triggerId filter", JSON.stringify(filters.triggerId, null, 2));
			return false;
		}
		if (filters.connectedAccountId && filters.connectedAccountId !== data.metadata.connectedAccount.id) {
			logger_default.debug("Trigger does not match connectedAccountId filter", JSON.stringify(filters.connectedAccountId, null, 2));
			return false;
		}
		if (filters.triggerSlug?.length && !filters.triggerSlug.map((triggerSlug) => triggerSlug.toLowerCase()).includes(data.triggerSlug.toLowerCase())) {
			logger_default.debug("Trigger does not match triggerSlug filter", JSON.stringify(filters.triggerSlug, null, 2));
			return false;
		}
		if (filters.triggerData && filters.triggerData !== data.metadata.triggerData) {
			logger_default.debug("Trigger does not match triggerData filter", JSON.stringify(filters.triggerData, null, 2));
			return false;
		}
		if (filters.userId && filters.userId !== data.metadata.connectedAccount.userId) {
			logger_default.debug("Trigger does not match userId filter", JSON.stringify(filters.userId, null, 2));
			return false;
		}
		logger_default.debug("Trigger matches all filters", JSON.stringify(filters, null, 2));
		return true;
	}
	/**
	* Subscribe to all the triggers
	*
	* @param fn - The function to call when a trigger is received
	* @param filters - The filters to apply to the triggers
	*
	* @example
	* ```ts
	*
	* triggers.subscribe((data) => {
	*   console.log(data);
	* }, );
	* ```
	*/
	async subscribe(fn, filters = {}) {
		if (!fn) throw new Error("Function is required for trigger subscription");
		const parsedFilters = TriggerSubscribeParamSchema.safeParse(filters);
		if (!parsedFilters.success) throw new ValidationError(`Invalid parameters passed to subscribe to triggers`, { cause: parsedFilters.error });
		logger_default.debug("🔄 Subscribing to triggers with filters: ", JSON.stringify(filters, null, 2));
		await this.pusherService.subscribe((_data) => {
			logger_default.debug("Received raw trigger data", JSON.stringify(_data, null, 2));
			const parsedData = this.parsePusherPayload(_data);
			if (this.shouldSendTriggerAfterFilters(parsedFilters.data, parsedData)) try {
				fn(parsedData);
			} catch (error) {
				logger_default.error("❌ Error in trigger callback:", error);
			}
			else logger_default.debug("Trigger does not match filters", JSON.stringify(parsedFilters.data, null, 2));
		});
	}
	/**
	* Tries to parse data as V1, V2, or V3 webhook payload format.
	* Returns the parsed result with version info, or null if no format matches.
	* Also returns any schema validation errors for debugging purposes.
	* @private
	*/
	tryParseVersionedPayload(data) {
		const v3Result = WebhookPayloadV3Schema.safeParse(data);
		if (v3Result.success) return {
			ok: true,
			version: WebhookVersions.V3,
			rawPayload: v3Result.data,
			normalizedPayload: this.normalizeV3Payload(v3Result.data)
		};
		const v2Result = WebhookPayloadV2Schema.safeParse(data);
		if (v2Result.success) return {
			ok: true,
			version: WebhookVersions.V2,
			rawPayload: v2Result.data,
			normalizedPayload: this.normalizeV2Payload(v2Result.data)
		};
		const v1Result = WebhookPayloadV1Schema.safeParse(data);
		if (v1Result.success) return {
			ok: true,
			version: WebhookVersions.V1,
			rawPayload: v1Result.data,
			normalizedPayload: this.normalizeV1Payload(v1Result.data)
		};
		return {
			ok: false,
			v1Error: v1Result.error.message,
			v2Error: v2Result.error.message,
			v3Error: v3Result.error.message
		};
	}
	/**
	* Parses incoming Pusher payload, supporting V1, V2, V3, and legacy TriggerData formats.
	* @private
	*/
	parsePusherPayload(data) {
		const versionedResult = this.tryParseVersionedPayload(data);
		if (versionedResult.ok) {
			logger_default.debug(`Parsed Pusher payload as ${versionedResult.version} format`);
			return versionedResult.normalizedPayload;
		}
		const legacyData = data;
		if (legacyData.metadata?.nanoId && legacyData.appName) {
			logger_default.debug("Parsed Pusher payload as legacy TriggerData format");
			return transformIncomingTriggerPayload(legacyData);
		}
		logger_default.warn("Unknown Pusher payload format. Payload keys: " + Object.keys(data).join(", "));
		const id = toStringOrDefault(data.id, toStringOrDefault(data.trigger_id, "unknown"));
		const uuid = toStringOrDefault(data.uuid, toStringOrDefault(data.id, "unknown"));
		const triggerSlug = toStringOrDefault(data.triggerSlug, toStringOrDefault(data.trigger_name, "UNKNOWN"));
		const toolkitSlug = toStringOrDefault(data.toolkitSlug, toStringOrDefault(data.appName, "UNKNOWN"));
		return {
			id,
			uuid,
			triggerSlug,
			toolkitSlug,
			userId: toStringOrDefault(data.userId, ""),
			payload: data.payload || data,
			originalPayload: data.originalPayload || data,
			metadata: {
				id,
				uuid,
				triggerSlug,
				toolkitSlug,
				triggerConfig: {},
				connectedAccount: {
					id: "",
					uuid: "",
					authConfigId: "",
					authConfigUUID: "",
					userId: "",
					status: "ACTIVE"
				}
			}
		};
	}
	/**
	* Unsubscribe from all the triggers
	*
	* @returns {Promise<void>}
	*
	* @example
	* ```ts
	* composio.trigger.subscribe((data) => {
	*   console.log(data);
	* });
	*
	* await triggers.unsubscribe();
	* ```
	*/
	async unsubscribe() {
		await this.pusherService.unsubscribe();
	}
	/**
	* Verify an incoming webhook payload and signature.
	*
	* This method validates that the webhook request is authentic by:
	* 1. Verifying the HMAC-SHA256 signature matches the payload using the correct signing format
	* 2. Optionally checking that the webhook timestamp is within the tolerance window
	*
	* The signature is computed as: `HMAC-SHA256(${webhookId}.${webhookTimestamp}.${payload}, secret)`
	* and is expected in the format: `v1,base64EncodedSignature`
	*
	* @param {VerifyWebhookParams} params - The verification parameters
	* @param {string} params.payload - The raw webhook payload as a string (request body)
	* @param {string} params.signature - The signature from the 'webhook-signature' header
	* @param {string} params.secret - The webhook secret used to sign the payload
	* @param {string} params.webhookId - The webhook ID from the 'webhook-id' header
	* @param {string} params.webhookTimestamp - The timestamp from the 'webhook-timestamp' header (Unix seconds)
	* @param {number} [params.tolerance=300] - Maximum allowed age of the webhook in seconds (default: 5 minutes). Set to 0 to disable timestamp validation.
	* @returns {VerifyWebhookResult} The verified and parsed webhook payload with version information
	*
	* @throws {ValidationError} If the parameters are invalid
	* @throws {ComposioWebhookSignatureVerificationError} If the signature verification fails
	* @throws {ComposioWebhookPayloadError} If the payload cannot be parsed or is invalid
	*
	* @example
	* ```ts
	* // In an Express.js webhook handler
	* app.post('/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
	*   try {
	*     const result = await composio.triggers.verifyWebhook({
	*       payload: req.body.toString(),
	*       signature: req.headers['webhook-signature'] as string,
	*       webhookId: req.headers['webhook-id'] as string,
	*       webhookTimestamp: req.headers['webhook-timestamp'] as string,
	*       secret: process.env.COMPOSIO_WEBHOOK_SECRET!,
	*     });
	*
	*     // Process the verified payload
	*     console.log('Webhook version:', result.version);
	*     console.log('Received trigger:', result.payload.triggerSlug);
	*     res.status(200).send('OK');
	*   } catch (error) {
	*     console.error('Webhook verification failed:', error);
	*     res.status(401).send('Unauthorized');
	*   }
	* });
	* ```
	*/
	async verifyWebhook(params) {
		const parsedParams = VerifyWebhookParamsSchema.safeParse(params);
		if (!parsedParams.success) {
			const missingParams = parsedParams.error.issues.filter((issue) => issue.code === "invalid_type" && issue.received === "undefined").map((issue) => {
				const paramName = issue.path[0];
				const headerName = {
					id: "webhook-id",
					timestamp: "webhook-timestamp",
					signature: "webhook-signature"
				}[paramName];
				return headerName ? `'${paramName}' (from '${headerName}' header)` : `'${paramName}'`;
			});
			if (missingParams.length > 0) throw new ValidationError(`Missing required parameters: ${missingParams.join(", ")}. Extract these values from the HTTP request headers and body.`, { cause: parsedParams.error });
			throw new ValidationError("Invalid parameters passed to verifyWebhook", { cause: parsedParams.error });
		}
		const { payload, signature, secret, id: webhookId, timestamp: webhookTimestamp, tolerance } = parsedParams.data;
		if (tolerance > 0) this.validateWebhookTimestamp(webhookTimestamp, tolerance);
		await this.verifyWebhookSignature(webhookId, webhookTimestamp, payload, signature, secret);
		const { version: version$1, rawPayload, normalizedPayload } = this.parseWebhookPayload(payload);
		return {
			version: version$1,
			payload: normalizedPayload,
			rawPayload
		};
	}
	/**
	* Parses the webhook payload and detects its version (V1, V2, or V3)
	* @private
	*/
	parseWebhookPayload(payload) {
		let jsonPayload;
		try {
			jsonPayload = JSON.parse(payload);
		} catch (error) {
			throw new ComposioWebhookPayloadError("Failed to parse webhook payload as JSON", { cause: error });
		}
		const result = this.tryParseVersionedPayload(jsonPayload);
		if (result.ok) {
			const { ok, ...rest } = result;
			return rest;
		}
		const { v1Error, v2Error, v3Error } = result;
		throw new ComposioWebhookPayloadError("Webhook payload does not match any known version (V1, V2, or V3). Please ensure you are using a supported webhook payload format.", { cause: {
			v1Error,
			v2Error,
			v3Error
		} });
	}
	/**
	* Normalizes a V1 webhook payload to IncomingTriggerPayload format
	* @private
	*/
	normalizeV1Payload(payload) {
		const triggerName = payload.trigger_name;
		const toolkitSlug = triggerName.split("_")[0]?.toUpperCase() || "UNKNOWN";
		return {
			id: payload.trigger_id,
			uuid: payload.trigger_id,
			triggerSlug: triggerName,
			toolkitSlug,
			userId: "",
			payload: payload.payload,
			originalPayload: payload.payload,
			metadata: {
				id: payload.trigger_id,
				uuid: payload.trigger_id,
				toolkitSlug,
				triggerSlug: triggerName,
				triggerConfig: {},
				connectedAccount: {
					id: payload.connection_id,
					uuid: payload.connection_id,
					authConfigId: "",
					authConfigUUID: "",
					userId: "",
					status: "ACTIVE"
				}
			}
		};
	}
	/**
	* Normalizes a V2 webhook payload to IncomingTriggerPayload format
	* @private
	*/
	normalizeV2Payload(payload) {
		const triggerSlug = payload.type.toUpperCase();
		const toolkitSlug = triggerSlug.split("_")[0] || "UNKNOWN";
		const { connection_id, connection_nano_id, trigger_nano_id, trigger_id, user_id, ...restData } = payload.data;
		return {
			id: trigger_nano_id,
			uuid: trigger_id,
			triggerSlug,
			toolkitSlug,
			userId: user_id,
			payload: restData,
			originalPayload: restData,
			metadata: {
				id: trigger_nano_id,
				uuid: trigger_id,
				toolkitSlug,
				triggerSlug,
				triggerConfig: {},
				connectedAccount: {
					id: connection_nano_id,
					uuid: connection_id,
					authConfigId: "",
					authConfigUUID: "",
					userId: user_id,
					status: "ACTIVE"
				}
			}
		};
	}
	/**
	* Normalizes a V3 webhook payload to IncomingTriggerPayload format
	* @private
	*/
	normalizeV3Payload(payload) {
		const triggerSlug = payload.metadata.trigger_slug;
		const toolkitSlug = triggerSlug.split("_")[0]?.toUpperCase() || "UNKNOWN";
		return {
			id: payload.metadata.trigger_id,
			uuid: payload.metadata.trigger_id,
			triggerSlug,
			toolkitSlug,
			userId: payload.metadata.user_id,
			payload: payload.data,
			originalPayload: payload.data,
			metadata: {
				id: payload.metadata.trigger_id,
				uuid: payload.metadata.trigger_id,
				toolkitSlug,
				triggerSlug,
				triggerConfig: {},
				connectedAccount: {
					id: payload.metadata.connected_account_id,
					uuid: payload.metadata.connected_account_id,
					authConfigId: payload.metadata.auth_config_id,
					authConfigUUID: payload.metadata.auth_config_id,
					userId: payload.metadata.user_id,
					status: "ACTIVE"
				}
			}
		};
	}
	/**
	* Verifies the HMAC-SHA256 signature of a webhook payload.
	* The signature format used by Composio is: `v1,base64EncodedSignature`
	* The signing input is: `${msgId}.${timestamp}.${payload}`
	* @private
	*/
	async verifyWebhookSignature(webhookId, webhookTimestamp, payload, signature, secret) {
		if (payload.length === 0) throw new ComposioWebhookSignatureVerificationError("No webhook payload was provided.");
		if (signature.length === 0) throw new ComposioWebhookSignatureVerificationError("No signature header value was provided. Please pass the value of the 'webhook-signature' header.");
		if (secret.length === 0) throw new ComposioWebhookSignatureVerificationError("No webhook secret was provided. You can find your webhook secret in your Composio dashboard.");
		if (webhookId.length === 0) throw new ComposioWebhookSignatureVerificationError("No webhook ID was provided. Please pass the value of the 'webhook-id' header.");
		if (webhookTimestamp.length === 0) throw new ComposioWebhookSignatureVerificationError("No webhook timestamp was provided. Please pass the value of the 'webhook-timestamp' header.");
		const signatures = signature.split(" ");
		const v1Signatures = [];
		for (const sig of signatures) {
			const [version$1, value] = sig.split(",");
			if (version$1 === "v1" && value) v1Signatures.push(value);
		}
		if (v1Signatures.length === 0) throw new ComposioWebhookSignatureVerificationError("No valid v1 signature found in the webhook-signature header. Expected format: 'v1,base64EncodedSignature'");
		const expectedSignature = await hmacSha256Base64(secret, `${webhookId}.${webhookTimestamp}.${payload}`);
		let isValid = false;
		for (const providedSignature of v1Signatures) if (timingSafeEqual(providedSignature, expectedSignature)) {
			isValid = true;
			break;
		}
		if (!isValid) throw new ComposioWebhookSignatureVerificationError("The signature provided is invalid. Please ensure you are using the correct webhook secret.");
	}
	/**
	* Validates that the webhook timestamp is within the allowed tolerance
	* @private
	*/
	validateWebhookTimestamp(webhookTimestamp, tolerance) {
		const timestampSeconds = parseInt(webhookTimestamp, 10);
		if (Number.isNaN(timestampSeconds)) throw new ComposioWebhookPayloadError(`Invalid webhook timestamp: ${webhookTimestamp}. Expected Unix timestamp in seconds.`);
		const webhookTimeMs = timestampSeconds * 1e3;
		const currentTime = Date.now();
		const timeDifference = Math.abs(currentTime - webhookTimeMs);
		if (timeDifference > tolerance * 1e3) throw new ComposioWebhookSignatureVerificationError(`The webhook timestamp is outside the allowed tolerance. The webhook was sent ${Math.round(timeDifference / 1e3)} seconds ago, but the maximum allowed age is ${tolerance} seconds.`);
	}
};

//#endregion
//#region src/types/mcp.experimental.types.ts
const MCPServerInstanceSchema = z.object({
	id: z.string(),
	name: z.string(),
	type: z.literal("streamable_http"),
	url: z.string(),
	userId: z.string(),
	allowedTools: z.array(z.string()),
	authConfigs: z.array(z.string())
});
/**
* MCP Create Method Input Types
*/
const MCPConfigToolkitsSchema = z.object({
	toolkit: z.string().describe("Id of the toolkit").optional(),
	authConfigId: z.string().describe("Id of the auth config").optional()
});
const MCPConfigCreationParamsSchema = z.object({
	toolkits: z.array(z.union([MCPConfigToolkitsSchema, z.string()])),
	allowedTools: z.array(z.string()).optional(),
	manuallyManageConnections: z.boolean().default(false).optional().describe(`Whether to manually manage accounts. If true, you need to manage accounts manually connect user accounts. 
If set to false, composio will inject account maangement tools into your mcp server for agents to request and authenticate accounts.
defaults to false`)
});
const MCPConfigResponseSchema = z.object({
	id: z.string(),
	name: z.string(),
	allowedTools: z.array(z.string()),
	authConfigIds: z.array(z.string()),
	commands: z.object({
		claude: z.string(),
		cursor: z.string(),
		windsurf: z.string()
	}),
	MCPUrl: z.string()
});
const MCPGetInstanceParamsSchema = z.object({ manuallyManageConnections: z.boolean().default(false).optional().describe(`Whether to manually manage accounts. If true, you need to manage accounts manually connect user accounts. 
If set to false, composio will inject account maangement tools into your mcp server for agents to request and authenticate accounts.
defaults to false`) });
const MCPListParamsSchema = z.object({
	page: z.number().optional().default(1),
	limit: z.number().optional().default(10),
	toolkits: z.array(z.string()).optional().default([]),
	authConfigs: z.array(z.string()).optional().default([]),
	name: z.string().optional()
});
const MCPItemSchema = MCPConfigResponseSchema.extend({ ...z.object({
	toolkitIcons: z.record(z.string(), z.string()),
	serverInstanceCount: z.number(),
	toolkits: z.array(z.string())
}).shape });
const MCPListResponseSchema = z.object({
	items: z.array(MCPItemSchema),
	currentPage: z.number(),
	totalPages: z.number()
});
const MCPUpdateParamsSchema = z.object({
	name: z.string().optional(),
	toolkits: z.array(z.union([MCPConfigToolkitsSchema, z.string()])).optional(),
	allowedTools: z.array(z.string()).optional(),
	manuallyManageConnections: z.boolean().optional().describe(`Whether to manually manage accounts. If true, you need to manage accounts manually connect user accounts. 
If set to false, composio will inject account maangement tools into your mcp server for agents to request and authenticate accounts.
defaults to false`)
});
const MCPServerConnectionStatus = z.object({
	connected: z.boolean(),
	toolkit: z.string(),
	connectedAccountId: z.string()
});
const MCPServerConnectedAccountsSchema = z.record(z.string(), z.array(z.object({
	toolkit: z.string(),
	authConfigId: z.string(),
	connectedAccountId: z.string()
})));

//#endregion
//#region src/models/MCP.ts
function transformMCPItemResponse(response) {
	return transform(response).with(MCPItemSchema).using((raw) => ({
		name: raw.name,
		allowedTools: raw.allowed_tools,
		id: raw.id,
		authConfigIds: raw.auth_config_ids,
		commands: raw.commands,
		MCPUrl: raw.mcp_url,
		toolkitIcons: raw.toolkit_icons,
		serverInstanceCount: raw.server_instance_count,
		toolkits: raw.toolkits
	}));
}
/**
* MCP (Model Control Protocol) class
* Handles MCP server operations.
* When `config.experimental.mcp` is enabled, this class augments the features of `composio.mcp`.
*/
var MCP = class {
	client;
	constructor(client) {
		this.client = client;
		telemetry.instrument(this, "MCP");
	}
	/**
	* Create a new MCP configuration.
	* @param {Object} params - Parameters for creating the MCP configuration
	* @param {Array} params.authConfig - Array of auth configurations with id and allowed tools
	* @param {Object} params.options - Configuration options
	* @param {string} params.options.name - Unique name for the MCP configuration
	* @param {boolean} [params.options.manuallyManageConnections] - Whether to use chat-based authentication or manually connect accounts
	* @returns {Promise<McpServerCreateResponse<T>>} Created server details with instance getter
	*
	* @example
	* ```typescript
	* const server = await composio.mcpConfig.create("personal-mcp-server", {
	*   toolkits: ["github", "slack"],
	*   allowedTools: ["GMAIL_FETCH_EMAILS", "SLACK_SEND_MESSAGE"],
	*   manuallyManageConnections: false
	*  }
	* });
	*
	* const server = await composio.mcpConfig.create("personal-mcp-server", {
	*   toolkits: [{ toolkit: "gmail", authConfigId: "ac_243434343" }],
	*   allowedTools: ["GMAIL_FETCH_EMAILS"],
	*   manuallyManageConnections: false
	*  }
	* });
	* ```
	*/
	async create(name, mcpConfig) {
		const config = MCPConfigCreationParamsSchema.safeParse(mcpConfig);
		if (config.error) throw new ValidationError("Invalid parameters passed to create mcp config", { cause: config.error });
		const toolkits = [];
		const auth_config_ids = [];
		const custom_tools = config.data.allowedTools ?? [];
		config.data.toolkits.forEach((toolkit) => {
			if (typeof toolkit === "string") toolkits.push(toolkit);
			else if (toolkit.toolkit) toolkits.push(toolkit.toolkit);
			else if (toolkit.authConfigId) auth_config_ids.push(toolkit.authConfigId);
		});
		const server = await this.client.mcp.custom.create({
			name,
			toolkits,
			auth_config_ids,
			custom_tools,
			managed_auth_via_composio: config.data.manuallyManageConnections ? false : true
		});
		return {
			...transform(server).with(MCPConfigResponseSchema).using((raw) => ({
				name: raw.name,
				allowedTools: raw.allowed_tools,
				id: raw.id,
				authConfigIds: raw.auth_config_ids,
				commands: raw.commands,
				MCPUrl: raw.mcp_url
			})),
			generate: async (userId) => {
				return await this.generate(userId, server.id, { manuallyManageConnections: config.data.manuallyManageConnections });
			}
		};
	}
	/**
	* List the MCP servers with optional filtering and pagination
	* @param {Object} options - Filtering and pagination options
	* @param {number} [options.page=1] - Page number for pagination (1-based)
	* @param {number} [options.limit=10] - Maximum number of items to return per page
	* @param {string[]} [options.toolkits=[]] - Array of toolkit names to filter by
	* @param {string[]} [options.authConfigs=[]] - Array of auth configuration IDs to filter by
	* @param {string} [options.name] - Filter by MCP server name (partial match)
	* @returns {Promise<MCPListResponse>} Paginated list of MCP servers with metadata
	*
	* @example
	* ```typescript
	* // List all MCP servers
	* const allServers = await composio.experimental.mcp.list({});
	*
	* // List with pagination
	* const pagedServers = await composio.experimental.mcp.list({
	*   page: 2,
	*   limit: 5
	* });
	*
	* // Filter by toolkit
	* const githubServers = await composio.experimental.mcp.list({
	*   toolkits: ['github', 'slack']
	* });
	*
	* // Filter by name
	* const namedServers = await composio.experimental.mcp.list({
	*   name: 'personal'
	* });
	* ```
	*/
	async list(options) {
		const { data: params, error } = MCPListParamsSchema.safeParse(options);
		if (error) throw new ValidationError("Failed to validate list options", { cause: error });
		return transform(await this.client.mcp.list({
			page_no: params.page,
			limit: params.limit,
			toolkits: params.toolkits?.length > 0 ? params.toolkits.join(",") : void 0,
			auth_config_ids: params.authConfigs?.length > 0 ? params.authConfigs.join(",") : void 0,
			name: params.name
		})).with(MCPListResponseSchema).using((raw) => ({
			currentPage: raw.current_page,
			totalPages: raw.total_pages,
			items: raw.items.map((item) => ({
				name: item.name,
				allowedTools: item.allowed_tools,
				id: item.id,
				authConfigIds: item.auth_config_ids,
				commands: item.commands,
				MCPUrl: item.mcp_url,
				toolkitIcons: item.toolkit_icons,
				serverInstanceCount: item.server_instance_count,
				toolkits: item.toolkits
			}))
		}));
	}
	/**
	* Retrieve detailed information about a specific MCP server by its ID
	* @param {string} serverId - The unique identifier of the MCP server to retrieve
	* @returns {Promise<MCPItem>} Complete MCP server details including configuration, tools, and metadata
	*
	* @example
	* ```typescript
	* // Get a specific MCP server by ID
	* const server = await composio.experimental.mcp.get("mcp_12345");
	*
	* console.log(server.name); // "My Personal MCP Server"
	* console.log(server.allowedTools); // ["GITHUB_CREATE_ISSUE", "SLACK_SEND_MESSAGE"]
	* console.log(server.toolkits); // ["github", "slack"]
	* console.log(server.serverInstanceCount); // 3
	*
	* // Access setup commands for different clients
	* console.log(server.commands.claude); // Claude setup command
	* console.log(server.commands.cursor); // Cursor setup command
	* console.log(server.commands.windsurf); // Windsurf setup command
	*
	* // Use the MCP URL for direct connections
	* const mcpUrl = server.MCPUrl;
	* ```
	*
	* @throws {ValidationError} When the server ID is invalid or server not found
	*/
	async get(serverId) {
		return transformMCPItemResponse(await this.client.mcp.retrieve(serverId));
	}
	/**
	* Delete an MCP server configuration permanently
	* @param {string} serverId - The unique identifier of the MCP server to delete
	* @returns {Promise<{id: string; deleted: boolean}>} Confirmation object with server ID and deletion status
	*
	* @example
	* ```typescript
	* // Delete an MCP server by ID
	* const result = await composio.experimental.mcp.delete("mcp_12345");
	*
	* if (result.deleted) {
	*   console.log(`Server ${result.id} has been successfully deleted`);
	* } else {
	*   console.log(`Failed to delete server ${result.id}`);
	* }
	*
	* // Example with error handling
	* try {
	*   const result = await composio.experimental.mcp.delete("mcp_12345");
	*   console.log("Deletion successful:", result);
	* } catch (error) {
	*   console.error("Failed to delete MCP server:", error.message);
	* }
	*
	* // Delete and verify from list
	* await composio.experimental.mcp.delete("mcp_12345");
	* const servers = await composio.experimental.mcp.list({});
	* const serverExists = servers.items.some(server => server.id === "mcp_12345");
	* console.log("Server still exists:", serverExists); // Should be false
	* ```
	*
	* @throws {ValidationError} When the server ID is invalid or server not found
	* @throws {Error} When the server cannot be deleted due to active connections or other constraints
	*
	* @warning This operation is irreversible. Once deleted, the MCP server configuration and all its associated data will be permanently removed.
	*/
	async delete(serverId) {
		return await this.client.mcp.delete(serverId);
	}
	/**
	* Update an existing MCP server configuration with new settings
	* @param {string} serverId - The unique identifier of the MCP server to update
	* @param {Object} config - Update configuration parameters
	* @param {string} [config.name] - New name for the MCP server
	* @param {Array} [config.toolkits] - Updated toolkit configurations
	* @param {string} [config.toolkits[].toolkit] - Toolkit identifier (e.g., "github", "slack")
	* @param {string} [config.toolkits[].authConfigId] - Auth configuration ID for the toolkit
	* @param {string[]} [config.toolkits[].allowedTools] - Specific tools to enable for this toolkit
	* @param {boolean} [config.manuallyManageConnections] - Whether to manually manage account connections
	* @returns {Promise<MCPItem>} Updated MCP server configuration with all details
	*
	* @example
	* ```typescript
	* // Update server name only
	* const updatedServer = await composio.experimental.mcp.update("mcp_12345", {
	*   name: "My Updated MCP Server"
	* });
	*
	* // Update toolkits and tools
	* const serverWithNewTools = await composio.experimental.mcp.update("mcp_12345", {
	*   toolkits: [
	*     {
	*       toolkit: "github",
	*       authConfigId: "auth_abc123",
	*       allowedTools: ["GITHUB_CREATE_ISSUE", "GITHUB_LIST_REPOS"]
	*     },
	*     {
	*       toolkit: "slack",
	*       authConfigId: "auth_xyz789",
	*       allowedTools: ["SLACK_SEND_MESSAGE", "SLACK_LIST_CHANNELS"]
	*     }
	*   ]
	* });
	*
	* // Update connection management setting
	* const serverWithManualAuth = await composio.experimental.mcp.update("mcp_12345", {
	*   name: "Manual Auth Server",
	*   manuallyManageConnections: true
	* });
	*
	* // Complete update example
	* const fullyUpdatedServer = await composio.experimental.mcp.update("mcp_12345", {
	*   name: "Production MCP Server",
	*   toolkits: [
	*     {
	*       toolkit: "gmail",
	*       authConfigId: "auth_gmail_prod",
	*     }
	*   ],
	*   allowedTools: ["GMAIL_SEND_EMAIL", "GMAIL_FETCH_EMAILS"]
	*   manuallyManageConnections: false
	* });
	*
	* console.log("Updated server:", fullyUpdatedServer.name);
	* console.log("New tools:", fullyUpdatedServer.allowedTools);
	* ```
	*
	* @throws {ValidationError} When the update parameters are invalid or malformed
	* @throws {Error} When the server ID doesn't exist or update fails
	*
	* @note Only provided fields will be updated. Omitted fields will retain their current values.
	* @note When updating toolkits, the entire toolkit configuration is replaced, not merged.
	*/
	async update(serverId, config) {
		const { data: params, error } = MCPUpdateParamsSchema.safeParse(config);
		if (error) throw new ValidationError("Failed to validate update params", { cause: error });
		const toolkits = [];
		const auth_config_ids = [];
		const custom_tools = params.allowedTools ?? void 0;
		params.toolkits?.forEach((toolkit) => {
			if (typeof toolkit === "string") toolkits.push(toolkit);
			else if (toolkit.toolkit) toolkits.push(toolkit.toolkit);
			else if (toolkit.authConfigId) auth_config_ids.push(toolkit.authConfigId);
		});
		return transformMCPItemResponse(await this.client.mcp.update(serverId, {
			name: params.name ?? void 0,
			...params.toolkits ? {
				custom_tools,
				toolkits,
				auth_config_ids
			} : {},
			managed_auth_via_composio: params.manuallyManageConnections ?? void 0
		}));
	}
	/**
	* Get server URLs for an existing MCP server.
	* The response is wrapped according to the provider's specifications.
	*
	* @example
	* ```typescript
	* import { Composio } from "@composio/code";
	*
	* const composio = new Composio();
	* const mcp = await composio.experimental.mcp.generate("default", "<mcp_config_id>");
	* ```
	*
	* @param userId {string} external user id from your database for whom you want the server for
	* @param mcpConfigId {string} config id of the MCPConfig for which you want to create a server for
	* @param options {object} additional options
	* @param options.isChatAuth {boolean} Authenticate the users via chat when they use the MCP Server
	*/
	async generate(userId, mcpConfigId, options) {
		const server = await this.client.mcp.retrieve(mcpConfigId);
		const params = MCPGetInstanceParamsSchema.safeParse(options ?? { manuallyManageConnections: false });
		if (params.error) throw new ValidationError("Invalid params passed for Get Instance Params", { cause: params.error });
		const userIdsURL = (await this.client.mcp.generate.url({
			mcp_server_id: mcpConfigId,
			user_ids: [userId],
			managed_auth_by_composio: options?.manuallyManageConnections ? false : true
		})).user_ids_url[0];
		const serverInstance = MCPServerInstanceSchema.safeParse({
			id: server.id,
			name: server.name,
			type: "streamable_http",
			url: userIdsURL,
			userId,
			allowedTools: server.allowed_tools,
			authConfigs: server.auth_config_ids
		});
		if (serverInstance.error) throw new ValidationError("Failed to parse MCP server instance", { cause: serverInstance.error });
		return serverInstance.data;
	}
};

//#endregion
//#region src/utils/sdk.ts
const userDataPath = () => {
	try {
		const homeDir = platform.homedir();
		if (!homeDir) return null;
		return platform.joinPath(homeDir, COMPOSIO_DIR, USER_DATA_FILE_NAME);
	} catch (_error) {
		logger_default.debug("Environment", `Unable to get user data path`);
		return null;
	}
};
/**
* Reads and parses the user data JSON file from the Composio directory.
*
* @returns The parsed user data object containing user configuration (api_key, base_url, etc.), or empty object if file doesn't exist or can't be read
*/
const getUserDataJson = () => {
	try {
		const dataPath = userDataPath();
		if (!dataPath || !platform.supportsFileSystem) return {};
		const data = platform.readFileSync(dataPath, "utf8");
		return JSON.parse(data);
	} catch (_error) {
		logger_default.debug("Environment", "No user data file found");
		return {};
	}
};
function getSDKConfig(baseUrl, apiKey) {
	const { api_key: apiKeyFromUserConfig, base_url: baseURLFromUserConfig } = getUserDataJson();
	const baseURLParsed = baseUrl || getEnvVariable("COMPOSIO_BASE_URL") || baseURLFromUserConfig || DEFAULT_BASE_URL;
	const apiKeyParsed = apiKey || getEnvVariable("COMPOSIO_API_KEY") || apiKeyFromUserConfig || "";
	if (!apiKeyParsed) ComposioError.handleAndThrow(new ComposioNoAPIKeyError());
	logger_default.debug("Environment", `API Key: ${apiKeyParsed}`);
	logger_default.debug("Environment", `Base URL: ${baseURLParsed}`);
	return {
		baseURL: baseURLParsed,
		apiKey: apiKeyParsed
	};
}
/**
* Gets toolkit versions configuration by merging environment variables, user-provided defaults, and fallbacks.
*
* Priority order:
* 1. If defaultVersions is a string, use it as global version for all toolkits
* 2. Environment variables (COMPOSIO_TOOLKIT_VERSION_<TOOLKIT_NAME>)
* 3. User-provided toolkit version mappings (defaultVersions object)
* 4. Fallback to 'latest' if no versions are configured
*
* @param defaultVersions - Optional default versions configuration (string for global version or object mapping toolkit names to versions)
* @returns Toolkit versions configuration - either a global version string, toolkit-specific version mapping, or 'latest'
*/
function getToolkitVersionsFromEnv(defaultVersions) {
	if (defaultVersions && typeof defaultVersions === "string") return defaultVersions;
	const envPrefixedVersions = getEnvsWithPrefix(`COMPOSIO_TOOLKIT_VERSION_`);
	const toolkitVersionsFromEnv = Object.entries(envPrefixedVersions).reduce((acc, [key, value]) => {
		const toolkitName = key.replace("COMPOSIO_TOOLKIT_VERSION_", "");
		acc[toolkitName.toLowerCase()] = value;
		return acc;
	}, {});
	let userProvidedToolkitVersions = {};
	if (defaultVersions && typeof defaultVersions === "object") userProvidedToolkitVersions = Object.fromEntries(Object.entries(defaultVersions).map(([key, value]) => [key.toLowerCase(), value]));
	const toolkitVersions = {
		...toolkitVersionsFromEnv,
		...userProvidedToolkitVersions
	};
	if (Object.keys(toolkitVersions).length === 0) return "latest";
	return toolkitVersions;
}

//#endregion
//#region src/utils/version.ts
/**
* Checks for the latest version of the Composio SDK from NPM.
* If a newer version is available, it logs a warning to the console.
*/
async function checkForLatestVersionFromNPM(currentVersion) {
	try {
		const packageName = "@composio/core";
		const currentVersionFromPackageJson = currentVersion;
		if (!semver.valid(currentVersionFromPackageJson)) return;
		const prerelease = semver.prerelease(currentVersionFromPackageJson);
		if (prerelease && (String(prerelease[0]).includes("alpha") || String(prerelease[0]).includes("beta"))) return;
		const latestVersion = (await (await fetch(`https://registry.npmjs.org/${packageName}/latest`)).json()).version;
		if (semver.gt(latestVersion, currentVersionFromPackageJson) && !IS_DEVELOPMENT_OR_CI) logger_default.info(`🚀 Upgrade available! Your composio-core version (${currentVersionFromPackageJson}) is behind. Latest version: ${latestVersion}.`);
	} catch (_error) {}
}

//#endregion
//#region src/provider/BaseProvider.ts
/**
* @internal
* Base class for all providers.
* This class is not meant to be used directly, but rather to be extended by different provider implementations.
*/
var BaseProvider = class {
	/**
	* @internal
	* The function to execute a tool.
	* This is set automatically injected by the core SDK.
	*/
	_globalExecuteToolFn;
	/**
	* @internal
	* Set the function to execute a tool.
	* This is set automatically and injected by the core SDK.
	*/
	_setExecuteToolFn(executeToolFn) {
		this._globalExecuteToolFn = executeToolFn;
	}
	/**
	* @public
	* Global function to execute a tool.
	* This function is used by providers to implement helper functions to execute tools.
	* This is a 1:1 mapping of the `execute` method in the `Tools` class.
	* @param {string} toolSlug - The slug of the tool to execute.
	* @param {ToolExecuteParams} body - The body of the tool execution.
	* @param {ExecuteToolModifiers} modifers - The modifiers of the tool execution.
	* @returns {Promise<string>} The result of the tool execution.
	*/
	executeTool(toolSlug, body, modifers) {
		if (!this._globalExecuteToolFn) throw new ComposioGlobalExecuteToolFnNotSetError("executeToolFn is not set");
		return this._globalExecuteToolFn(toolSlug, body, modifers);
	}
};
/**
* @public
* Base class for all non-agentic providers.
* This class is not meant to be used directly, but rather to be extended by concrete provider implementations.
*/
var BaseNonAgenticProvider = class extends BaseProvider {
	_isAgentic = false;
};
/**
* @public
* Base class for all agentic providers.
* This class is not meant to be used directly, but rather to be extended by concrete provider implementations.
*/
var BaseAgenticProvider = class extends BaseProvider {
	_isAgentic = true;
};

//#endregion
//#region src/provider/OpenAIProvider.ts
var OpenAIProvider = class extends BaseNonAgenticProvider {
	name = "openai";
	/**
	* Creates a new instance of the OpenAIProvider.
	*
	* This is the default provider for the Composio SDK and is automatically
	* available without additional installation.
	*
	* @example
	* ```typescript
	* // The OpenAIProvider is used by default when initializing Composio
	* const composio = new Composio({
	*   apiKey: 'your-api-key'
	* });
	*
	* // You can also explicitly specify it
	* const composio = new Composio({
	*   apiKey: 'your-api-key',
	*   provider: new OpenAIProvider()
	* });
	* ```
	*/
	constructor() {
		super();
	}
	/**
	* Transform MCP URL response into OpenAI-specific format.
	* OpenAI uses the standard format by default.
	*
	* @param data - The MCP URL response data
	* @returns Standard MCP server response format
	*/
	wrapMcpServerResponse(data) {
		return data.map((item) => ({
			url: new URL(item.url),
			name: item.name
		}));
	}
	/**
	* Wraps a Composio tool in the OpenAI function calling format.
	*
	* This method transforms a Composio tool definition into the format
	* expected by OpenAI's function calling API.
	*
	* @param tool - The Composio tool to wrap
	* @returns The wrapped tool in OpenAI format
	*
	* @example
	* ```typescript
	* // Wrap a single tool for use with OpenAI
	* const composioTool = {
	*   slug: 'SEARCH_TOOL',
	*   description: 'Search for information',
	*   inputParameters: {
	*     type: 'object',
	*     properties: {
	*       query: { type: 'string' }
	*     },
	*     required: ['query']
	*   }
	* };
	*
	* const openAITool = provider.wrapTool(composioTool);
	* ```
	*/
	wrapTool = (tool) => {
		return {
			type: "function",
			function: {
				name: tool.slug,
				description: tool.description,
				parameters: tool.inputParameters
			}
		};
	};
	/**
	* Wraps multiple Composio tools in the OpenAI function calling format.
	*
	* This method transforms a list of Composio tools into the format
	* expected by OpenAI's function calling API.
	*
	* @param tools - Array of Composio tools to wrap
	* @returns Array of wrapped tools in OpenAI format
	*
	* @example
	* ```typescript
	* // Wrap multiple tools for use with OpenAI
	* const composioTools = [
	*   {
	*     slug: 'SEARCH_TOOL',
	*     description: 'Search for information',
	*     inputParameters: {
	*       type: 'object',
	*       properties: {
	*         query: { type: 'string' }
	*       }
	*     }
	*   },
	*   {
	*     slug: 'WEATHER_TOOL',
	*     description: 'Get weather information',
	*     inputParameters: {
	*       type: 'object',
	*       properties: {
	*         location: { type: 'string' }
	*       }
	*     }
	*   }
	* ];
	*
	* const openAITools = provider.wrapTools(composioTools);
	* ```
	*/
	wrapTools = (tools) => {
		return tools.map((tool) => this.wrapTool(tool));
	};
	/**
	* Executes a tool call from OpenAI's chat completion.
	*
	* This method processes a tool call from OpenAI's chat completion API,
	* executes the corresponding Composio tool, and returns the result.
	*
	* @param {string} userId - The user ID for authentication and tracking
	* @param {OpenAI.ChatCompletionMessageToolCall} tool - The tool call from OpenAI
	* @param {ExecuteToolFnOptions} [options] - Optional execution options
	* @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
	* @returns {Promise<string>} The result of the tool call as a JSON string
	*
	* @example
	* ```typescript
	* // Execute a tool call from OpenAI
	* const toolCall = {
	*   id: 'call_abc123',
	*   type: 'function',
	*   function: {
	*     name: 'SEARCH_TOOL',
	*     arguments: '{"query":"composio documentation"}'
	*   }
	* };
	*
	* const result = await provider.executeToolCall(
	*   'user123',
	*   toolCall,
	*   { connectedAccountId: 'conn_xyz456' }
	* );
	* console.log(JSON.parse(result));
	* ```
	*/
	async executeToolCall(userId, tool, options, modifiers) {
		const payload = {
			arguments: JSON.parse(tool.function.arguments),
			connectedAccountId: options?.connectedAccountId,
			customAuthParams: options?.customAuthParams,
			customConnectionData: options?.customConnectionData,
			userId
		};
		const result = await this.executeTool(tool.function.name, payload, modifiers);
		return JSON.stringify(result);
	}
	/**
	* Handles tool calls from OpenAI's chat completion response.
	*
	* This method processes tool calls from an OpenAI chat completion response,
	* executes each tool call, and returns the results.
	*
	* @param {string} userId - The user ID for authentication and tracking
	* @param {OpenAI.ChatCompletion} chatCompletion - The chat completion response from OpenAI
	* @param {ExecuteToolFnOptions} [options] - Optional execution options
	* @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
	* @returns {Promise<string[]>} Array of tool execution results as JSON strings
	*
	* @example
	* ```typescript
	* // Handle tool calls from a chat completion response
	* const chatCompletion = {
	*   choices: [
	*     {
	*       message: {
	*         tool_calls: [
	*           {
	*             id: 'call_abc123',
	*             type: 'function',
	*             function: {
	*               name: 'SEARCH_TOOL',
	*               arguments: '{"query":"composio documentation"}'
	*             }
	*           }
	*         ]
	*       }
	*     }
	*   ]
	* };
	*
	* const results = await provider.handleToolCalls(
	*   'user123',
	*   chatCompletion,
	*   { connectedAccountId: 'conn_xyz456' }
	* );
	* console.log(results); // Array of tool execution results
	* ```
	*/
	async handleToolCalls(userId, chatCompletion, options, modifiers) {
		const outputs = [];
		for (const message of chatCompletion.choices) if (message.message.tool_calls && message.message.tool_calls[0].type === "function") {
			const toolResult = await this.executeToolCall(userId, message.message.tool_calls[0], options, modifiers);
			outputs.push({
				role: "tool",
				tool_call_id: message.message.tool_calls[0].id,
				content: toolResult
			});
		}
		return outputs;
	}
	/**
	* Handles all the tool calls from the OpenAI Assistant API.
	*
	* This method processes tool calls from an OpenAI Assistant run,
	* executes each tool call, and returns the tool outputs for submission.
	*
	* @deprecated Assistant API is deprecated, please use responses or chat completions instead. This method will be removed in the next major version.
	*
	* @param {string} userId - The user ID for authentication and tracking
	* @param {OpenAI.Beta.Threads.Run} run - The Assistant run object containing tool calls
	* @param {ExecuteToolFnOptions} [options] - Optional execution options
	* @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
	* @returns {Promise<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput[]>} Array of tool outputs for submission
	*
	*
	* @example
	* ```typescript
	* // Handle tool calls from an OpenAI Assistant run
	* const run = {
	*   id: 'run_abc123',
	*   required_action: {
	*     submit_tool_outputs: {
	*       tool_calls: [
	*         {
	*           id: 'call_xyz789',
	*           type: 'function',
	*           function: {
	*             name: 'SEARCH_TOOL',
	*             arguments: '{"query":"composio documentation"}'
	*           }
	*         }
	*       ]
	*     }
	*   }
	* };
	*
	* const toolOutputs = await provider.handleAssistantMessage(
	*   'user123',
	*   run,
	*   { connectedAccountId: 'conn_xyz456' }
	* );
	*
	* // Submit tool outputs back to OpenAI
	* await openai.beta.threads.runs.submitToolOutputs(
	*   thread.id,
	*   run.id,
	*   { tool_outputs: toolOutputs }
	* );
	* ```
	*/
	async handleAssistantMessage(userId, run, options, modifiers) {
		const tool_calls = run.required_action?.submit_tool_outputs?.tool_calls || [];
		return await Promise.all(tool_calls.map(async (tool_call) => {
			logger_default.debug(`Executing tool call: ${tool_call.id}`);
			const tool_response = await this.executeToolCall(userId, tool_call, options, modifiers);
			logger_default.debug(`Tool call ${tool_call.id} executed with response: ${tool_response}`);
			return {
				tool_call_id: tool_call.id,
				output: JSON.stringify(tool_response)
			};
		}));
	}
	/**
	* Waits for the assistant stream and handles the tool calls.
	*
	* This method processes an OpenAI Assistant stream, handles any tool calls
	* that require action, and yields each event from the stream. It's designed
	* for streaming Assistant responses while handling tool calls in real-time.
	*
	* @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
	*
	* @param {string} userId - The user ID for authentication and tracking
	* @param {OpenAI} client - The OpenAI client instance
	* @param {Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>} runStream - The Assistant run stream
	* @param {OpenAI.Beta.Threads.Thread} thread - The thread object
	* @param {ExecuteToolFnOptions} [options] - Optional execution options
	* @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
	* @returns {AsyncGenerator<OpenAI.Beta.Assistants.AssistantStreamEvent, void, unknown>} Generator yielding stream events
	*
	*
	*
	* @example
	* ```typescript
	* // Process an OpenAI Assistant stream with tool calls
	* const thread = await openai.beta.threads.create();
	* const runStream = openai.beta.threads.runs.stream(thread.id, {
	*   assistant_id: 'asst_abc123',
	*   tools: provider.wrapTools(composioTools)
	* });
	*
	* // Process the stream and handle tool calls
	* const streamProcessor = provider.waitAndHandleAssistantStreamToolCalls(
	*   'user123',
	*   openai,
	*   runStream,
	*   thread,
	*   { connectedAccountId: 'conn_xyz456' }
	* );
	*
	* // Consume the stream events
	* for await (const event of streamProcessor) {
	*   if (event.event === 'thread.message.delta') {
	*     console.log(event.data.delta.content);
	*   }
	* }
	* ```
	*/
	async *waitAndHandleAssistantStreamToolCalls(userId, client, runStream, thread, options, modifiers) {
		let runId = null;
		for await (const event of runStream) {
			yield event;
			if (event.event === "thread.run.created") {
				const { id } = event.data;
				runId = id;
			}
			if (!runId) continue;
			if (event.event === "thread.run.requires_action") {
				const toolOutputs = await this.handleAssistantMessage(userId, event.data, options, modifiers);
				await client.beta.threads.runs.submitToolOutputs(runId, {
					thread_id: thread.id,
					tool_outputs: toolOutputs
				});
			}
			if ([
				"thread.run.completed",
				"thread.run.failed",
				"thread.run.cancelled",
				"thread.run.expired"
			].includes(event.event)) break;
		}
		if (!runId) throw new Error("No run ID found");
		let finalRun = await client.beta.threads.runs.retrieve(runId, { thread_id: thread.id });
		while ([
			"queued",
			"in_progress",
			"requires_action"
		].includes(finalRun.status)) if (finalRun.status === "requires_action") {
			const toolOutputs = await this.handleAssistantMessage(userId, finalRun, options, modifiers);
			finalRun = await client.beta.threads.runs.submitToolOutputs(runId, {
				thread_id: thread.id,
				tool_outputs: toolOutputs
			});
		} else {
			finalRun = await client.beta.threads.runs.retrieve(runId, { thread_id: thread.id });
			await new Promise((resolve) => setTimeout(resolve, 500));
		}
	}
	/**
	* Waits for the assistant tool calls and handles them.
	*
	* This method polls an OpenAI Assistant run until it completes or requires action,
	* handles any tool calls, and returns the final run object. It's designed for
	* non-streaming Assistant interactions.
	*
	* @deprecated Assistant API is deprecated, please use responses or chat completions instead. It will be removed in the next major version.
	*
	* @param {string} userId - The user ID for authentication and tracking
	* @param {OpenAI} client - The OpenAI client instance
	* @param {OpenAI.Beta.Threads.Run} run - The initial run object
	* @param {OpenAI.Beta.Threads.Thread} thread - The thread object
	* @param {ExecuteToolFnOptions} [options] - Optional execution options
	* @param {ExecuteToolModifiers} [modifiers] - Optional execution modifiers
	* @returns {Promise<OpenAI.Beta.Threads.Run>} The final run object after completion
	*
	* @example
	* ```typescript
	* // Process an OpenAI Assistant run with tool calls
	* const thread = await openai.beta.threads.create();
	* await openai.beta.threads.messages.create(thread.id, {
	*   role: 'user',
	*   content: 'Find information about Composio'
	* });
	*
	* let run = await openai.beta.threads.runs.create(thread.id, {
	*   assistant_id: 'asst_abc123',
	*   tools: provider.wrapTools(composioTools)
	* });
	*
	* // Wait for the run to complete, handling any tool calls
	* run = await provider.waitAndHandleAssistantToolCalls(
	*   'user123',
	*   openai,
	*   run,
	*   thread,
	*   { connectedAccountId: 'conn_xyz456' }
	* );
	*
	* // Get the final messages after run completion
	* const messages = await openai.beta.threads.messages.list(thread.id);
	* console.log(messages.data[0].content);
	* ```
	*/
	async waitAndHandleAssistantToolCalls(userId, client, run, thread, options, modifiers) {
		while ([
			"queued",
			"in_progress",
			"requires_action"
		].includes(run.status)) {
			const tool_outputs = await this.handleAssistantMessage(userId, run, options, modifiers);
			if (run.status === "requires_action") run = await client.beta.threads.runs.submitToolOutputs(run.id, {
				thread_id: thread.id,
				tool_outputs
			});
			else {
				run = await client.beta.threads.runs.retrieve(run.id, { thread_id: thread.id });
				await new Promise((resolve) => setTimeout(resolve, 500));
			}
		}
		return run;
	}
};

//#endregion
//#region package.json
var version = "0.6.3";

//#endregion
//#region src/utils/session.ts
/**
* Detect the JavaScript runtime environment without importing any external modules.
* Uses only built-in globals to avoid breaking in different environments.
*/
function detectRuntime() {
	const global = globalThis;
	if ("Bun" in global && typeof global.Bun !== "undefined") return "BUN";
	if ("Deno" in global && typeof global.Deno !== "undefined") return "DENO";
	if (typeof process !== "undefined" && process.versions && process.versions.node) return "NODEJS";
	if ("caches" in global && typeof global.caches !== "undefined" && "WebSocketPair" in global && typeof global.WebSocketPair !== "undefined") return "CLOUDFLARE_WORKERS";
	if ("EdgeRuntime" in global && typeof global.EdgeRuntime !== "undefined") return "VERCEL_EDGE";
	if ("ServiceWorkerGlobalScope" in global && typeof global.ServiceWorkerGlobalScope !== "undefined") {
		const ServiceWorkerScope = global.ServiceWorkerGlobalScope;
		if (ServiceWorkerScope && global instanceof ServiceWorkerScope) return "SERVICE_WORKER";
	}
	if ("WorkerGlobalScope" in global && typeof global.WorkerGlobalScope !== "undefined" && "importScripts" in global && typeof global.importScripts === "function") return "WEB_WORKER";
	if (typeof navigator !== "undefined" && navigator.product === "ReactNative") return "REACT_NATIVE";
	if (typeof window !== "undefined" && typeof document !== "undefined") return "BROWSER";
	return "UNKNOWN";
}
const RUNTIME_ENV = detectRuntime();
function getSessionHeaders(provider) {
	return {
		"x-framework": provider?.name || "unknown",
		"x-source": "TYPESCRIPT_SDK",
		"x-runtime": RUNTIME_ENV,
		"x-sdk-version": version
	};
}
const getDefaultHeaders = (headers, provider) => {
	const sessionHeaders = getSessionHeaders(provider);
	return {
		...headers || {},
		...sessionHeaders
	};
};

//#endregion
//#region src/types/toolRouter.types.ts
const MCPServerTypeSchema = z.enum(["http", "sse"]);
const ToolRouterConfigManageConnectionsSchema = z.object({
	enable: z.boolean().default(true).optional().describe("Whether to use tools to manage connections in the tool router session. Defaults to true, if set to false, you need to manage connections manually"),
	callbackUrl: z.string().optional().describe("The callback uri to use in the tool router session"),
	waitForConnections: z.boolean().optional().describe("Whether to wait for users to finish authenticating connections before proceeding to the next step. Defaults to false, if set to true, a wait for connections tool call will happen and finish when the connections are ready")
}).strict();
const ToolRouterToolkitsParamSchema = z.array(z.string()).describe("List of toolkits to enable in the tool router session");
const ToolRouterToolkitsDisabledConfigSchema = z.object({ disable: ToolRouterToolkitsParamSchema.describe("List of toolkits to disable in the tool router session") }).strict();
const ToolRouterToolkitsEnabledConfigSchema = z.object({ enable: ToolRouterToolkitsParamSchema.describe("List of toolkits to enable in the tool router session") }).strict();
const ToolRouterManageConnectionsConfigSchema = z.object({
	enable: z.boolean().optional().describe("Whether to use tools to manage connections in the tool router session. Defaults to true, if set to false, you need to manage connections manually").default(true),
	callbackUrl: z.string().optional().describe("The callback url to use in the tool router session")
});
const ToolRouterTagsParamSchema = z.array(z.enum([
	"readOnlyHint",
	"destructiveHint",
	"idempotentHint",
	"openWorldHint"
])).describe("The tags to filter the tools by");
const ToolRouterTagsEnableDisableSchema = z.object({
	enable: ToolRouterTagsParamSchema.optional().describe("The tags to enable in the tool router session"),
	disable: ToolRouterTagsParamSchema.optional().describe("The tags to disable in the tool router session")
}).strict();
const ToolRouterConfigTagsSchema = z.union([ToolRouterTagsParamSchema, ToolRouterTagsEnableDisableSchema]).describe("The tags to use in the tool router session");
/**
*  Tools config - Configure tools per toolkit using toolkit slug as key
* @example
* ```typescript
*  {
*      gmail: {
*          enable: ['gmail_search', 'gmail_send']
*      },
*      slack: {
*          disable: ['slack_delete_message']
*      }
*  }
* ```
*
* @example
* ```typescript
*  {
*      gmail: ['gmail_search', 'gmail_send'],
*      slack: { tags: ['readOnlyHint'] }
*  }
* ```
*/
const ToolRouterToolsParamSchema = z.array(z.string()).describe("The tools to use in the tool router session");
const ToolRouterConfigToolsSchema = z.union([
	ToolRouterToolsParamSchema,
	z.object({ enable: ToolRouterToolsParamSchema.describe("The tools to enable in the tool router session") }).strict(),
	z.object({ disable: ToolRouterToolsParamSchema.describe("The tools to disable in the tool router session") }).strict(),
	z.object({ tags: ToolRouterConfigTagsSchema.describe("The tags to filter the tools by, this will override the global tags") }).strict()
]).superRefine((val, ctx) => {
	if (typeof val === "object" && !Array.isArray(val)) {
		const keys = Object.keys(val);
		if (keys.length > 1) ctx.addIssue({
			code: z.ZodIssueCode.custom,
			message: `Only one of 'enable', 'disable', or 'tags' can be specified, but found: ${keys.join(", ")}`,
			path: keys
		});
	}
});
const ToolRouterCreateSessionConfigSchema = z.object({
	tools: z.record(z.string(), z.union([ToolRouterToolsParamSchema, ToolRouterConfigToolsSchema])).optional().describe("The tools to use in the tool router session"),
	tags: ToolRouterConfigTagsSchema.optional().describe("Global tags to filter the tools by"),
	toolkits: z.union([
		ToolRouterToolkitsParamSchema,
		ToolRouterToolkitsDisabledConfigSchema,
		ToolRouterToolkitsEnabledConfigSchema
	]).optional().describe("The toolkits to use in the tool router session"),
	authConfigs: z.record(z.string(), z.string()).describe("The auth configs to use in the tool router session. The key is the toolkit slug, the value is the auth config id.").default({}),
	connectedAccounts: z.record(z.string(), z.string()).describe("The connected accounts to use in the tool router session. The key is the toolkit slug, the value is the connected account id.").default({}),
	manageConnections: z.union([z.boolean(), ToolRouterConfigManageConnectionsSchema]).optional().default(true).describe("The config for the manage connections in the tool router session. Defaults to true, if set to false, you need to manage connections manually. If set to an object, you can configure the manage connections settings."),
	workbench: z.object({
		enableProxyExecution: z.boolean().optional().describe("Whether to enable proxy execution in the tool router session"),
		autoOffloadThreshold: z.number().optional().describe("The auto offload threshold in characters for the tool execution to be moved into workbench")
	}).optional().describe("The execution config for the tool router session"),
	experimental: z.object({ assistivePrompt: z.object({ userTimezone: z.string().optional().describe("IANA timezone identifier (e.g., \"America/New_York\", \"Europe/London\") for timezone-aware assistive prompts") }).optional().describe("Configuration for assistive prompt generation") }).optional().describe("Experimental features configuration - not stable, may be modified or removed")
}).partial().describe("The config for the tool router session");
const ToolkitConnectionStateSchema = z.object({
	slug: z.string().describe("The slug of a toolkit"),
	name: z.string().describe("The name of a toolkit"),
	logo: z.string().optional().describe("The logo of a toolkit"),
	isNoAuth: z.boolean().default(false).describe("Whether the toolkit is no auth or not"),
	connection: z.object({
		isActive: z.boolean().describe("Whether the connection is active or not"),
		authConfig: z.object({
			id: z.string().describe("The id of the auth config"),
			mode: z.string().describe("The auth scheme used by the auth config"),
			isComposioManaged: z.boolean().describe("Whether the auth config is managed by Composio")
		}).nullish().describe("The auth config of a toolkit"),
		connectedAccount: z.object({
			id: z.string().describe("The id of the connected account"),
			status: z.string().describe("The status of the connected account")
		}).optional().describe("The connected account of a toolkit")
	}).optional().describe("The connection of a toolkit")
}).describe("The connection state of a toolkit");
const ToolkitConnectionsDetailsSchema = z.object({
	items: z.array(ToolkitConnectionStateSchema),
	nextCursor: z.string().optional(),
	totalPages: z.number()
});
const ToolRouterMCPServerConfigSchema = z.object({
	type: MCPServerTypeSchema,
	url: z.string(),
	headers: z.record(z.string(), z.string()).optional()
});
const ToolRouterToolkitsOptionsSchema = z.object({
	toolkits: z.array(z.string()).optional(),
	nextCursor: z.string().optional(),
	limit: z.number().optional(),
	isConnected: z.boolean().optional(),
	search: z.string().optional()
});

//#endregion
//#region src/lib/toolRouterParams.ts
const transformToolRouterToolsParams = (params) => {
	if (!params) return;
	if (typeof params === "object") return Object.keys(params).reduce((acc, key) => {
		if (Array.isArray(params[key])) acc[key] = { enable: params[key] };
		else if (typeof params[key] === "object") {
			const parsedResult = ToolRouterConfigToolsSchema.safeParse(params[key]);
			if (parsedResult.success) {
				const data = parsedResult.data;
				if (Array.isArray(data)) acc[key] = { enable: data };
				else if ("enable" in data) acc[key] = { enable: data.enable };
				else if ("disable" in data) acc[key] = { disable: data.disable };
				else if ("tags" in data) {
					const tags = transformToolRouterTagsParams(data.tags);
					if (tags) acc[key] = { tags };
				}
			} else throw new ValidationError(parsedResult.error.message);
		} else acc[key] = { enable: params[key] };
		return acc;
	}, {});
};
const transformToolRouterTagsParams = (params) => {
	if (!params) return;
	if (Array.isArray(params)) return { enable: params };
	else if (typeof params === "object") return {
		enable: params.enable,
		disable: params.disable
	};
};
const transformToolRouterManageConnectionsParams = (params) => {
	if (params === void 0) return { enable: true };
	if (typeof params === "boolean") return { enable: params };
	const parsedResult = ToolRouterConfigManageConnectionsSchema.safeParse(params);
	if (!parsedResult.success) throw new ValidationError("Failed to parse manage connections config", { cause: parsedResult.error });
	const config = parsedResult.data;
	return {
		enable: config.enable ?? true,
		callback_url: config.callbackUrl,
		enable_wait_for_connections: config.waitForConnections
	};
};
const transformToolRouterWorkbenchParams = (params) => {
	if (!params) return;
	return {
		enable_proxy_execution: params.enableProxyExecution,
		auto_offload_threshold: params.autoOffloadThreshold
	};
};
const transformToolRouterToolkitsParams = (params) => {
	if (!params) return;
	if (Array.isArray(params)) return { enable: params };
	return params;
};

//#endregion
//#region src/models/ToolRouter.ts
var ToolRouter = class {
	constructor(client, config) {
		this.client = client;
		this.config = config;
		telemetry.instrument(this, "ToolRouter");
	}
	/**
	* Creates a function that authorizes a toolkit for a user.
	* @param sessionId {string} The session id to create the authorize function for
	* @returns {ToolRouterAuthorizeFn} The authorize function
	*
	*/
	createAuthorizeFn = (sessionId) => {
		const authorizeFn = async (toolkit, options) => {
			const response = await this.client.toolRouter.session.link(sessionId, {
				...options?.callbackUrl ? { callback_url: options.callbackUrl } : {},
				toolkit
			});
			return createConnectionRequest(this.client, response.connected_account_id, ConnectedAccountStatuses.INITIATED, response.redirect_url);
		};
		return authorizeFn;
	};
	/**
	*
	* @param sessionId {string} The session id to create the toolkits function for
	* @returns {ToolRouterToolkitsFn} The toolkits function
	*
	* @example
	* ```typescript
	* import { Composio } from '@composio/core';
	*
	* const composio = new Composio();
	* const session = await composio.toolRouter.use('session_123');
	*
	* const toolkits = await session.toolkits();
	* console.log(toolkits);
	* ```
	*/
	createToolkitsFn = (sessionId) => {
		const connectionsFn = async (options) => {
			const toolkitOptions = ToolRouterToolkitsOptionsSchema.safeParse(options ?? {});
			if (!toolkitOptions.success) throw new ValidationError("Failed to parse toolkits options", { cause: toolkitOptions.error });
			const result = await this.client.toolRouter.session.toolkits(sessionId, {
				cursor: toolkitOptions.data.nextCursor,
				limit: toolkitOptions.data.limit,
				toolkits: toolkitOptions.data.toolkits,
				is_connected: toolkitOptions.data.isConnected,
				search: toolkitOptions.data.search
			});
			return {
				items: result.items.map((item) => {
					return transform(item).with(ToolkitConnectionStateSchema).using((item$1) => ({
						slug: item$1.slug,
						name: item$1.name,
						logo: item$1.meta?.logo,
						isNoAuth: item$1.is_no_auth,
						connection: item$1.is_no_auth ? void 0 : {
							isActive: item$1.connected_account?.status === "ACTIVE",
							authConfig: item$1.connected_account && {
								id: item$1.connected_account?.auth_config.id,
								mode: item$1.connected_account?.auth_config.auth_scheme,
								isComposioManaged: item$1.connected_account?.auth_config.is_composio_managed
							},
							connectedAccount: item$1.connected_account ? {
								id: item$1.connected_account.id,
								status: item$1.connected_account.status
							} : void 0
						}
					}));
				}),
				nextCursor: result.next_cursor,
				totalPages: result.total_pages
			};
		};
		return connectionsFn;
	};
	/**
	* @internal
	* Creates a function that wraps the tools based on the provider.
	* The returned tools will be of the type the frameworks expects.
	*
	* @param sessionId - The session id to get the tools for
	* @returns A function that wraps the tools based on the provider with session-specific modifiers.
	*/
	createToolsFn = (sessionId) => {
		return async (modifiers) => {
			const ToolsModel = new Tools(this.client, this.config);
			const tools = await ToolsModel.getRawToolRouterMetaTools(sessionId, modifiers?.modifySchema ? { modifySchema: modifiers?.modifySchema } : void 0);
			return ToolsModel.wrapToolsForToolRouter(sessionId, tools, modifiers);
		};
	};
	/**
	* Creates a MCP server config object.
	* @param type {MCPServerType} The type of the MCP server
	* @param url {string} The URL of the MCP server
	* @returns {ToolRouterMCPServerConfig} The MCP server config object
	*/
	createMCPServerConfig = ({ type, url }) => {
		return {
			type,
			url,
			headers: { ...this.config?.apiKey ? { "x-api-key": this.config?.apiKey } : {} }
		};
	};
	/**
	* Creates a new tool router session for a user.
	*
	* @param userId {string} The user id to create the session for
	* @param config {ToolRouterCreateSessionConfig} The config for the tool router session
	* @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
	*
	* @example
	* ```typescript
	* import { Composio } from '@composio/core';
	*
	* const composio = new Composio();
	* const userId = 'user_123';
	*
	* const session = await composio.experimental.create(userId, {
	*   toolkits: ['gmail'],
	*   manageConnections: true,
	*   tools: {
	*     gmail: {
	*       disabled: ['gmail_send_email']
	*     }
	*   },
	*   tags: ['readOnlyHint']
	* });
	*
	* console.log(session.sessionId);
	* console.log(session.mcp.url);
	*
	* // Get tools formatted for your framework (requires provider)
	* const tools = await session.tools();
	*
	* // Check toolkit connection states
	* const toolkits = await session.toolkits();
	* ```
	*/
	async create(userId, config) {
		const routerConfig = ToolRouterCreateSessionConfigSchema.parse(config ?? {});
		const payload = {
			user_id: userId,
			auth_configs: routerConfig.authConfigs,
			connected_accounts: routerConfig.connectedAccounts,
			toolkits: transformToolRouterToolkitsParams(routerConfig.toolkits),
			tools: transformToolRouterToolsParams(routerConfig.tools),
			tags: transformToolRouterTagsParams(routerConfig.tags),
			manage_connections: transformToolRouterManageConnectionsParams(routerConfig.manageConnections),
			workbench: transformToolRouterWorkbenchParams(routerConfig.workbench),
			experimental: routerConfig.experimental?.assistivePrompt?.userTimezone ? { assistive_prompt_config: { user_timezone: routerConfig.experimental.assistivePrompt.userTimezone } } : void 0
		};
		const session = await this.client.toolRouter.session.create(payload);
		const experimental = session.experimental ? { assistivePrompt: session.experimental.assistive_prompt } : void 0;
		return {
			sessionId: session.session_id,
			mcp: this.createMCPServerConfig(session.mcp),
			tools: this.createToolsFn(session.session_id),
			authorize: this.createAuthorizeFn(session.session_id),
			toolkits: this.createToolkitsFn(session.session_id),
			experimental
		};
	}
	/**
	* Use an existing session
	* @param id {string} The id of the session to use
	* @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
	*
	* @example
	* ```typescript
	* import { Composio } from '@composio/core';
	*
	* const composio = new Composio();
	* const id = 'session_123';
	* const session = await composio.toolRouter.use(id);
	*
	* console.log(session.mcp.url);
	* console.log(session.mcp.headers);
	* ```
	*/
	async use(id) {
		const session = await this.client.toolRouter.session.retrieve(id);
		return {
			sessionId: session.session_id,
			mcp: this.createMCPServerConfig(session.mcp),
			tools: this.createToolsFn(session.session_id),
			authorize: this.createAuthorizeFn(session.session_id),
			toolkits: this.createToolkitsFn(session.session_id)
		};
	}
};

//#endregion
//#region src/composio.ts
/**
* This is the core class for Composio.
* It is used to initialize the Composio SDK and provide a global configuration.
*/
var Composio = class Composio {
	/**
	* The Composio API client.
	* @type {ComposioClient}
	*/
	client;
	/**
	* The configuration for the Composio SDK.
	* @type {ComposioConfig<TProvider>}
	*/
	config;
	/**
	* Core models for Composio.
	*/
	/** List, retrieve, and execute tools */
	tools;
	/** Retrieve toolkit metadata and authorize user connections */
	toolkits;
	/** Manage webhook triggers and event subscriptions */
	triggers;
	/** The tool provider instance used for wrapping tools in framework-specific formats */
	provider;
	/** Upload and download files */
	files;
	/** Manage authentication configurations for toolkits */
	authConfigs;
	/** Manage authenticated connections */
	connectedAccounts;
	/** Model Context Protocol server management */
	mcp;
	/**
	* Experimental feature, use with caution
	* @experimental
	*/
	toolRouter;
	/**
	* Creates a new tool router session for a user.
	*
	* @param userId {string} The user id to create the session for
	* @param config {ToolRouterConfig} The config for the tool router session
	* @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
	*
	* @example
	* ```typescript
	* import { Composio } from '@composio/core';
	*
	* const composio = new Composio();
	* const userId = 'user_123';
	*
	* const session = await composio.create(userId, {
	*  manageConnections: true,
	* });
	*
	* console.log(session.sessionId);
	* console.log(session.url);
	* console.log(session.tools());
	* ```
	*/
	create;
	/**
	* Use an existing tool router session
	*
	* @param id {string} The id of the session to use
	* @returns {Promise<ToolRouterSession<TToolCollection, TTool, TProvider>>} The tool router session
	*/
	use;
	/**
	* Creates a new instance of the Composio SDK.
	*
	* The constructor initializes the SDK with the provided configuration options,
	* sets up the API client, and initializes all core models (tools, toolkits, etc.).
	*
	* @param {ComposioConfig<TProvider>} config - Configuration options for the Composio SDK
	* @param {string} [config.apiKey] - The API key for authenticating with the Composio API
	* @param {string} [config.baseURL] - The base URL for the Composio API (defaults to production URL)
	* @param {boolean} [config.allowTracking=true] - Whether to allow anonymous usage analytics
	* @param {TProvider} [config.provider] - The provider to use for this Composio instance (defaults to OpenAIProvider)
	*
	* @example
	* ```typescript
	* // Initialize with default configuration
	* const composio = new Composio();
	*
	* // Initialize with custom API key and base URL
	* const composio = new Composio({
	*   apiKey: 'your-api-key',
	*   baseURL: 'https://api.composio.dev'
	* });
	*
	* // Initialize with custom provider
	* const composio = new Composio({
	*   apiKey: 'your-api-key',
	*   provider: new CustomProvider()
	* });
	* ```
	*/
	constructor(config) {
		const { baseURL: baseURLParsed, apiKey: apiKeyParsed } = getSDKConfig(config?.baseURL, config?.apiKey);
		if (IS_DEVELOPMENT_OR_CI) logger_default.debug(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);
		/**
		* Set the default provider, if not provided by the user.
		*/
		this.provider = config?.provider ?? new OpenAIProvider();
		/**
		* Keep a reference to the config object.
		* This is useful for creating a builder pattern, debugging and logging.
		*/
		this.config = {
			...config,
			baseURL: baseURLParsed,
			apiKey: apiKeyParsed,
			toolkitVersions: getToolkitVersionsFromEnv(config?.toolkitVersions),
			allowTracking: config?.allowTracking ?? CONFIG_DEFAULTS.allowTracking,
			autoUploadDownloadFiles: config?.autoUploadDownloadFiles ?? CONFIG_DEFAULTS.autoUploadDownloadFiles,
			provider: config?.provider ?? this.provider
		};
		/**
		* Initialize the Composio SDK client.
		* The client is used to make API calls to the Composio API.
		*/
		this.client = new ComposioClient({
			apiKey: apiKeyParsed,
			baseURL: baseURLParsed,
			defaultHeaders: getDefaultHeaders(this.config.defaultHeaders, this.provider),
			logLevel: COMPOSIO_LOG_LEVEL
		});
		this.tools = new Tools(this.client, this.config);
		this.mcp = new MCP(this.client);
		this.toolkits = new Toolkits(this.client);
		this.triggers = new Triggers(this.client, this.config);
		this.authConfigs = new AuthConfigs(this.client);
		this.files = new Files(this.client);
		this.connectedAccounts = new ConnectedAccounts(this.client);
		this.toolRouter = new ToolRouter(this.client, this.config);
		/**
		* Initialize tool router methods
		* Properly bind the methods to maintain the correct 'this' context
		*/
		this.create = this.toolRouter.create.bind(this.toolRouter);
		this.use = this.toolRouter.use.bind(this.toolRouter);
		/**
		* Initialize the client telemetry.
		*/
		if (this.config.allowTracking) telemetry.setup({
			apiKey: apiKeyParsed ?? "",
			baseUrl: baseURLParsed ?? "",
			isAgentic: this.provider?._isAgentic || false,
			version,
			isBrowser: typeof window !== "undefined",
			provider: this.provider?.name ?? "openai",
			host: this.config.host
		});
		telemetry.instrument(this, "Composio");
		telemetry.instrument(this.provider, this.provider.name ?? this.provider.constructor.name ?? "unknown");
		if (!this.config.disableVersionCheck) checkForLatestVersionFromNPM(version);
	}
	/**
	* Get the Composio SDK client.
	* @returns {ComposioClient} The Composio API client.
	*/
	getClient() {
		if (!this.client) throw new Error("Composio client is not initialized. Please initialize it first.");
		return this.client;
	}
	/**
	* Get the configuration SDK is initialized with
	* @returns {ComposioConfig<TProvider>} The configuration SDK is initialized with
	*/
	getConfig() {
		return this.config;
	}
	/**
	* Creates a new instance of the Composio SDK with custom request options while preserving the existing configuration.
	* This method is particularly useful when you need to:
	* - Add custom headers for specific requests
	* - Track request contexts with unique identifiers
	* - Override default request behavior for a subset of operations
	*
	* The new instance inherits all configuration from the parent instance (apiKey, baseURL, provider, etc.)
	* but allows you to specify custom request options that will be used for all API calls made through this session.
	*
	* @deprecated DEPRECATED: This method will be removed in a future version of the SDK.
	*
	* @param {MergedRequestInit} fetchOptions - Custom request options to be used for all API calls in this session.
	*                                          This follows the Fetch API RequestInit interface with additional options.
	* @returns {Composio<TProvider>} A new Composio instance with the custom request options applied.
	*
	* @example
	* ```typescript
	* // Create a base Composio instance
	* const composio = new Composio({
	*   apiKey: 'your-api-key'
	* });
	*
	* // Create a session with request tracking headers
	* const composioWithCustomHeaders = composio.createSession({
	*   headers: {
	*     'x-request-id': '1234567890',
	*     'x-correlation-id': 'session-abc-123',
	*     'x-custom-header': 'custom-value'
	*   }
	* });
	*
	* // Use the session for making API calls with the custom headers
	* await composioWithCustomHeaders.tools.list();
	* ```
	*/
	createSession(options) {
		const sessionHeaders = getDefaultHeaders(options?.headers, this.provider);
		return new Composio({
			...this.config,
			defaultHeaders: sessionHeaders
		});
	}
	/**
	* Flush any pending telemetry and wait for it to complete.
	*
	* In Node.js-compatible environments, telemetry is automatically flushed on process exit.
	* However, in environments like Cloudflare Workers that don't support process exit events,
	* you should call this method manually to ensure all telemetry is sent.
	*
	* @returns {Promise<void>} A promise that resolves when all pending telemetry has been sent.
	*
	* @example
	* ```typescript
	* // In a Cloudflare Worker, use ctx.waitUntil to ensure telemetry is flushed
	* export default {
	*   async fetch(request: Request, env: Env, ctx: ExecutionContext) {
	*     const composio = new Composio({ apiKey: env.COMPOSIO_API_KEY });
	*
	*     // Do your work...
	*     const result = await composio.tools.execute(...);
	*
	*     // Ensure telemetry flushes before worker terminates
	*     ctx.waitUntil(composio.flush());
	*
	*     return new Response(JSON.stringify(result));
	*   }
	* };
	* ```
	*/
	async flush() {
		await telemetry.flush();
	}
};

//#endregion
//#region src/provider/ComposioProvider.ts
var ComposioProvider = class extends BaseNonAgenticProvider {
	name = "ComposioProvider";
	constructor() {
		super();
	}
	wrapTool = (tool) => {
		return tool;
	};
	wrapTools(tools) {
		return tools.map((tool) => this.wrapTool(tool));
	}
};

//#endregion
//#region src/utils/jsonSchema.ts
/**
* Removes all non-required properties from the schema
*
* if no items are required, the schema is returned as is
* @param schema - The JSON schema to remove non-required properties from
* @returns The JSON schema with all non-required properties removed
*/
const removeNonRequiredProperties = (schema) => {
	if (schema && schema.type === "object" && schema.required?.length) schema.properties = Object.fromEntries(Object.entries(schema.properties || {}).filter(([key]) => schema.required.includes(key)));
	schema.additionalProperties = false;
	return schema;
};
/**
* Convert a JSON schema to a Zod schema
* @param jsonSchema - The JSON schema to convert
* @param strict - Eliminates all non-required properties from the schema
* @returns The Zod schema
*
* @throws {JsonSchemaToZodError} If the JSON schema is invalid
*
* @example
* ```ts
* const zodSchema = jsonSchemaToZodSchema({
*   type: 'object',
*   properties: {
*     name: { type: 'string' },
*   },
* });
*
* console.log(zodSchema);
* ```
*
* @example
* ```ts
* const zodSchema = jsonSchemaToZodSchema({
*   type: 'object',
*   properties: {
*     name: { type: 'string' },
*     age: { type: 'number' },
*   },
*   required: ['name'],
* }, { strict: true });
*
* console.log(zodSchema);
*
* // Output:
* // z.object({
* //   name: z.string(),
* // })
* ```
*/
function jsonSchemaToZodSchema(jsonSchema, { strict } = { strict: false }) {
	try {
		let schema = jsonSchema;
		if (strict && schema) schema = removeNonRequiredProperties(schema);
		return jsonSchemaToZod(schema);
	} catch (error) {
		throw new JsonSchemaToZodError("Failed to convert JSON Schema to Zod Schema", { cause: error });
	}
}

//#endregion
//#region src/models/AuthScheme.ts
var AuthScheme = class {
	/**
	* Creates a ConnectionData object for OAuth2 authentication
	* @param params The OAuth2 parameters
	* @returns ConnectionData object
	*/
	static OAuth2(params) {
		return {
			authScheme: AuthSchemeTypes.OAUTH2,
			val: {
				status: ConnectionStatuses.INITIALIZING,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for OAuth1 authentication
	* @param params The OAuth1 parameters
	* @returns ConnectionData object
	*/
	static OAuth1(params) {
		return {
			authScheme: AuthSchemeTypes.OAUTH1,
			val: {
				status: ConnectionStatuses.INITIALIZING,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for API Key authentication
	* @param params The API key parameters
	* @returns ConnectionData object
	*/
	static APIKey(params) {
		return {
			authScheme: AuthSchemeTypes.API_KEY,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for Basic authentication
	* @param params The basic auth parameters
	* @returns ConnectionData object
	*/
	static Basic(params) {
		return {
			authScheme: AuthSchemeTypes.BASIC,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for Bearer Token authentication
	* @param params The bearer token parameters
	* @returns ConnectionData object
	*/
	static BearerToken(params) {
		return {
			authScheme: AuthSchemeTypes.BEARER_TOKEN,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for Google Service Account authentication
	* @param params The Google service account parameters
	* @returns ConnectionData object
	*/
	static GoogleServiceAccount(params) {
		return {
			authScheme: AuthSchemeTypes.GOOGLE_SERVICE_ACCOUNT,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for No Auth authentication
	* @returns ConnectionData object
	*/
	static NoAuth(params) {
		return {
			authScheme: AuthSchemeTypes.NO_AUTH,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params ?? {}
			}
		};
	}
	/**
	* Creates a ConnectionData object for Basic with JWT authentication
	* @param params The basic with JWT parameters
	* @returns ConnectionData object
	*/
	static BasicWithJWT(params) {
		return {
			authScheme: AuthSchemeTypes.BASIC_WITH_JWT,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
	/**
	* Creates a ConnectionData object for Cal.com authentication
	* @returns ConnectionData object
	*/
	static CalcomAuth(params) {
		return {
			authScheme: AuthSchemeTypes.CALCOM_AUTH,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params ?? {}
			}
		};
	}
	/**
	* Creates a ConnectionData object for Bill.com authentication
	* @param params The Bill.com auth parameters
	* @returns ConnectionData object
	*/
	static BillcomAuth(params) {
		return {
			authScheme: AuthSchemeTypes.BILLCOM_AUTH,
			val: {
				status: ConnectionStatuses.ACTIVE,
				...params
			}
		};
	}
};

//#endregion
//#region src/types/mcp.types.ts
/**
* @deprecated
*/
const MCPToolkitConfigSchema = z$1.object({
	toolkit: z$1.string().min(1, "Toolkit name cannot be empty"),
	authConfigId: z$1.string().min(1, "Auth config ID cannot be empty"),
	allowedTools: z$1.array(z$1.string().min(1, "Tool name cannot be empty")).min(1, "At least one tool must be specified")
});
/**
* @deprecated
*/
const MCPToolkitConfigsArraySchema = z$1.array(MCPToolkitConfigSchema).min(1, "At least one toolkit configuration is required").refine((configs) => {
	const toolkits = configs.map((config) => config.toolkit);
	return new Set(toolkits).size === toolkits.length;
}, "Duplicate toolkits are not allowed. Each toolkit must be unique.");
/**
* @deprecated
*/
const MCPAuthOptionsSchema = z$1.object({ isChatAuth: z$1.boolean().optional() });
const MCPGetServerParamsSchema = z$1.object({
	userId: z$1.string().min(1, "User ID cannot be empty").optional(),
	connectedAccountIds: z$1.record(z$1.string(), z$1.string().min(1, "Account ID cannot be empty")).optional()
}).refine((data) => {
	return !!data.userId !== (!!data.connectedAccountIds && Object.keys(data.connectedAccountIds).length > 0);
}, { message: "Must provide either userId or connectedAccountIds, but not both" });
const MCPGenerateURLParamsSchema = z$1.object({
	userIds: z$1.array(z$1.string()).optional(),
	connectedAccountIds: z$1.array(z$1.string()).optional(),
	isChatAuth: z$1.boolean().optional()
});
const ComposioGenerateURLParamsSchema = z$1.object({
	user_ids: z$1.array(z$1.string()).optional(),
	connected_account_ids: z$1.array(z$1.string()).optional(),
	mcp_server_id: z$1.string(),
	managed_auth_by_composio: z$1.boolean().optional()
});
const GenerateURLParamsSchema = z$1.object({
	userIds: z$1.array(z$1.string()).optional(),
	connectedAccountIds: z$1.array(z$1.string()).optional(),
	mcpServerId: z$1.string(),
	composioManagedAuth: z$1.boolean().optional()
});
const GenerateURLResponseSchema = z$1.object({
	connectedAccountUrls: z$1.array(z$1.string()).optional(),
	userIdsUrl: z$1.array(z$1.string()).optional(),
	mcpUrl: z$1.string().min(1, "MCP URL cannot be empty")
});
const ComposioGenerateURLResponseSchema = z$1.object({
	connected_account_urls: z$1.array(z$1.string()).optional(),
	user_ids_url: z$1.array(z$1.string()).optional(),
	mcp_url: z$1.string().min(1, "MCP URL cannot be empty")
});
/**
* MCP Server Type (Single App)
*/
const MCPSingleAppServerSchema = z$1.object({
	name: z$1.string().describe("Name of the MCP server"),
	tools: z$1.array(z$1.string()).describe("List of allowed tools"),
	authConfigId: z$1.string().optional().describe("Auth config ID for the server")
});
/**
* MCP Server Type (Multi App)
*/
const MCPMultiAppServerSchema = z$1.object({
	name: z$1.string().describe("Name of the MCP server"),
	tools: z$1.array(z$1.string()).describe("List of allowed tools across toolkits"),
	toolkits: z$1.array(z$1.string()).describe("List of allowed toolkits")
});
/**
* MCP Server Type (Combined)
*/
const MCPServerSchema = z$1.object({
	id: z$1.string().describe("Unique identifier for the MCP server"),
	type: z$1.enum(["single", "multi"]).describe("Type of MCP server"),
	createdAt: z$1.string().describe("Creation timestamp"),
	updatedAt: z$1.string().describe("Last update timestamp"),
	status: z$1.enum([
		"active",
		"inactive",
		"error"
	]).default("active"),
	config: z$1.union([MCPSingleAppServerSchema, MCPMultiAppServerSchema])
});
/**
* MCP Server List Response
*/
const MCPServerListResponseSchema = z$1.object({
	items: z$1.array(MCPServerSchema),
	total: z$1.number(),
	page: z$1.number(),
	pageSize: z$1.number()
});
/**
* MCP Server Update Parameters
*/
const MCPServerUpdateParamsSchema = z$1.object({
	name: z$1.string().optional().describe("New name for the server"),
	toolkits: z$1.array(z$1.string()).optional().describe("Updated list of toolkits"),
	allowedTools: z$1.array(z$1.string()).optional().describe("Updated list of allowed tools")
});
/**
* MCP Server Create Response
*/
const MCPServerCreateResponseSchema = MCPServerSchema;
let ConnectionStatus = /* @__PURE__ */ function(ConnectionStatus$1) {
	ConnectionStatus$1["CONNECTED"] = "CONNECTED";
	ConnectionStatus$1["DISCONNECTED"] = "DISCONNECTED";
	return ConnectionStatus$1;
}({});
const CustomCreateResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	createdAt: z$1.string().nullish(),
	updatedAt: z$1.string().nullish(),
	status: z$1.string().nullish()
});
const ComposioCustomCreateResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	created_at: z$1.string().nullish(),
	updated_at: z$1.string().nullish(),
	status: z$1.string().nullish()
});
const McpListResponseSchema = z$1.object({ items: z$1.array(z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	createdAt: z$1.string().optional(),
	updatedAt: z$1.string().optional(),
	status: z$1.string().optional()
})).optional() });
const ComposioMcpListResponseSchema = z$1.object({ items: z$1.array(z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	created_at: z$1.string().optional(),
	updated_at: z$1.string().optional(),
	status: z$1.string().optional()
})).optional() });
const McpRetrieveResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	createdAt: z$1.string().optional(),
	updatedAt: z$1.string().optional(),
	status: z$1.string().optional(),
	toolkits: z$1.array(z$1.string()).optional(),
	tools: z$1.array(z$1.string()).optional(),
	managedAuthViaComposio: z$1.boolean().optional(),
	authConfigIds: z$1.array(z$1.string()).optional(),
	mcpUrl: z$1.string(),
	commands: z$1.object({
		claude: z$1.string(),
		cursor: z$1.string(),
		windsurf: z$1.string()
	})
});
const ComposioMcpRetrieveResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	created_at: z$1.string().optional(),
	updated_at: z$1.string().optional(),
	status: z$1.string().optional(),
	toolkits: z$1.array(z$1.string()).optional(),
	tools: z$1.array(z$1.string()).optional(),
	managed_auth_via_composio: z$1.boolean().optional()
});
const McpDeleteResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	deleted: z$1.boolean().optional(),
	message: z$1.string().optional()
});
const ComposioMcpDeleteResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	deleted: z$1.boolean().optional(),
	message: z$1.string().optional()
});
const McpUpdateResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	createdAt: z$1.string().optional(),
	updatedAt: z$1.string().optional(),
	status: z$1.string().optional(),
	toolkits: z$1.array(z$1.string()).optional(),
	tools: z$1.array(z$1.string()).optional()
});
const ComposioMcpUpdateResponseSchema = z$1.object({
	id: z$1.string().min(1, "Server ID cannot be empty"),
	name: z$1.string().min(1, "Server name cannot be empty"),
	created_at: z$1.string().optional(),
	updated_at: z$1.string().optional(),
	status: z$1.string().optional(),
	toolkits: z$1.array(z$1.string()).optional(),
	tools: z$1.array(z$1.string()).optional()
});

//#endregion
export { AuthConfigCreationToolAccessConfigSchema, AuthConfigErrorCodes, AuthConfigListParamsSchema, AuthConfigListResponseSchema, AuthConfigRetrieveResponseSchema, AuthConfigToolAccessConfigSchema, AuthConfigTypes, AuthConfigUpdateParamsSchema, AuthCustomConfigUpdateParamsSchema, AuthDefaultConfigUpdateParamsSchema, AuthScheme, AuthSchemeEnum, AuthSchemeTypes, BaseAgenticProvider, BaseNonAgenticProvider, BillcomAuthConnectionDataSchema, Composio, ComposioAuthConfigNotFoundError, ComposioConnectedAccountNotFoundError, ComposioCustomCreateResponseSchema, ComposioCustomToolsNotInitializedError, ComposioError, ComposioFailedToCreateConnectedAccountLink, ComposioFailedToCreatePusherClientError, ComposioFailedToGetSDKRealtimeCredentialsError, ComposioFailedToSubscribeToPusherChannelError, ComposioFailedToUnsubscribeFromPusherChannelError, ComposioGenerateURLParamsSchema, ComposioGenerateURLResponseSchema, ComposioGlobalExecuteToolFnNotSetError, ComposioInvalidExecuteFunctionError, ComposioInvalidModifierError, ComposioMcpDeleteResponseSchema, ComposioMcpListResponseSchema, ComposioMcpRetrieveResponseSchema, ComposioMcpUpdateResponseSchema, ComposioMultipleConnectedAccountsError, ComposioNoAPIKeyError, ComposioProvider, ComposioProviderNotDefinedError, ComposioToolExecutionError, ComposioToolNotFoundError, ComposioToolVersionRequiredError, ComposioToolkitFetchError, ComposioToolkitNotFoundError, ComposioTriggerTypeNotFoundError, ComposioWebhookPayloadError, ComposioWebhookSignatureVerificationError, ConnectedAccountAuthConfigSchema, ConnectedAccountErrorCodes, ConnectedAccountListParamsSchema, ConnectedAccountListResponseSchema, ConnectedAccountRefreshOptionsSchema, ConnectedAccountRetrieveResponseSchema, ConnectedAccountStatusSchema, ConnectedAccountStatuses, ConnectionDataSchema, ConnectionRequestErrorCodes, ConnectionRequestFailedError, ConnectionRequestTimeoutError, ConnectionStatus, ConnectionStatuses, CreateAuthConfigParamsSchema, CreateAuthConfigResponseSchema, CreateComposioManagedAuthConfigParamsSchema, CreateConnectedAccountLinkOptionsSchema, CreateConnectedAccountLinkResponseSchema, CreateConnectedAccountOptionsSchema, CreateConnectedAccountParamsSchema, CreateConnectedAccountResponseSchema, CreateCustomAuthConfigParamsSchema, CustomAuthParamsSchema, CustomConnectionDataSchema, CustomCreateResponseSchema, CustomOauth1ConnectionDataSchema, CustomOauth2ConnectionDataSchema, DefaultCreateConnectedAccountParamsSchema, GenerateURLParamsSchema, GenerateURLResponseSchema, IncomingTriggerPayloadSchema, JSONSchemaPropertySchema, JsonSchemaToZodError, MCP, MCPAuthOptionsSchema, MCPGenerateURLParamsSchema, MCPGetServerParamsSchema, MCPMultiAppServerSchema, MCPServerCreateResponseSchema, MCPServerListResponseSchema, MCPServerSchema, MCPServerTypeSchema, MCPServerUpdateParamsSchema, MCPSingleAppServerSchema, MCPToolkitConfigSchema, MCPToolkitConfigsArraySchema, McpDeleteResponseSchema, McpListResponseSchema, McpRetrieveResponseSchema, McpUpdateResponseSchema, Oauth1ActiveConnectionDataSchema, Oauth1ConnectionDataSchema, Oauth1ExpiredConnectionDataSchema, Oauth1FailedConnectionDataSchema, Oauth1InactiveConnectionDataSchema, Oauth1InitiatedConnectionDataSchema, Oauth1InitiatingConnectionDataSchema, Oauth2ActiveConnectionDataSchema, Oauth2ConnectionDataSchema, Oauth2ExpiredConnectionDataSchema, Oauth2FailedConnectionDataSchema, Oauth2InactiveConnectionDataSchema, Oauth2InitiatedConnectionDataSchema, Oauth2InitiatingConnectionDataSchema, OpenAIProvider, RedirectableAuthSchemeSchema, SDKErrorCodes, ToolErrorCodes, ToolExecuteMetaParamsSchema, ToolExecuteParamsSchema, ToolExecuteResponseSchema, ToolKitItemSchema, ToolKitListResponseSchema, ToolKitMetaSchema, ToolListParamsSchema, ToolListResponseSchema, ToolProxyParamsSchema, ToolRouterConfigManageConnectionsSchema, ToolRouterConfigTagsSchema, ToolRouterConfigToolsSchema, ToolRouterCreateSessionConfigSchema, ToolRouterMCPServerConfigSchema, ToolRouterManageConnectionsConfigSchema, ToolRouterTagsEnableDisableSchema, ToolRouterTagsParamSchema, ToolRouterToolkitsDisabledConfigSchema, ToolRouterToolkitsEnabledConfigSchema, ToolRouterToolkitsOptionsSchema, ToolRouterToolkitsParamSchema, ToolRouterToolsParamSchema, ToolSchema, ToolkitAuthConfigDetailsSchema, ToolkitAuthFieldSchema, ToolkitAuthFieldsResponseSchema, ToolkitCategorySchema, ToolkitConnectionStateSchema, ToolkitConnectionsDetailsSchema, ToolkitErrorCodes, ToolkitLatestVersionSchema, ToolkitMangedByEnumSchema, ToolkitRetrieveCategoriesResponseSchema, ToolkitRetrieveResponseSchema, ToolkitSchema, ToolkitSortByEnumSchema, ToolkitVersionParamSchema, ToolkitVersionSchema, ToolkitVersionsSchema, ToolkitsListParamsSchema, TriggerErrorCodes, TriggerInstanceListActiveParamsSchema, TriggerInstanceListActiveResponseItemSchema, TriggerInstanceListActiveResponseSchema, TriggerInstanceManageDeleteResponseSchema, TriggerInstanceManageUpdateParamsSchema, TriggerInstanceManageUpdateResponseSchema, TriggerInstanceUpsertParamsSchema, TriggerInstanceUpsertResponseSchema, TriggerStatusEnum, TriggerStatuses, TriggerSubscribeParamSchema, TriggerTypeSchema, TriggersTypeListParamsSchema, TriggersTypeListResponseSchema, ValidationError, ValidationErrorCodes, VerifyWebhookParamsSchema, WebhookPayloadSchema, WebhookPayloadV1Schema, WebhookPayloadV2Schema, WebhookPayloadV3Schema, WebhookVersions, constants_exports as constants, createConnectionRequest, handleToolExecutionError, jsonSchemaToZodSchema, logger_default as logger, removeNonRequiredProperties };