//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let zod_v3 = require("zod/v3");
zod_v3 = __toESM(zod_v3);

//#region src/utils/half.ts
const half = (arr) => {
	return [arr.slice(0, arr.length / 2), arr.slice(arr.length / 2)];
};

//#endregion
//#region src/parsers/parse-all-of.ts
const originalIndex = Symbol("Original index");
const ensureOriginalIndex = (arr) => {
	const newArr = [];
	for (let i = 0; i < arr.length; i++) {
		const item = arr[i];
		if (typeof item === "boolean") newArr.push(item ? { [originalIndex]: i } : {
			[originalIndex]: i,
			not: {}
		});
		else if (originalIndex in item) return arr;
		else newArr.push({
			...item,
			[originalIndex]: i
		});
	}
	return newArr;
};
function parseAllOf(jsonSchema, refs) {
	if (jsonSchema.allOf.length === 0) return zod_v3.z.never();
	if (jsonSchema.allOf.length === 1) {
		const item = jsonSchema.allOf[0];
		return parseSchema(item, {
			...refs,
			path: [
				...refs.path,
				"allOf",
				item[originalIndex]
			]
		});
	}
	const [left, right] = half(ensureOriginalIndex(jsonSchema.allOf));
	return zod_v3.z.intersection(parseAllOf({ allOf: left }, refs), parseAllOf({ allOf: right }, refs));
}

//#endregion
//#region src/parsers/parse-any-of.ts
const parseAnyOf = (jsonSchema, refs) => {
	return jsonSchema.anyOf.length ? jsonSchema.anyOf.length === 1 ? parseSchema(jsonSchema.anyOf[0], {
		...refs,
		path: [
			...refs.path,
			"anyOf",
			0
		]
	}) : zod_v3.z.union(jsonSchema.anyOf.map((schema, i) => parseSchema(schema, {
		...refs,
		path: [
			...refs.path,
			"anyOf",
			i
		]
	}))) : zod_v3.z.any();
};

//#endregion
//#region src/utils/extend-schema.ts
function extendSchemaWithMessage(zodSchema, jsonSchema, key, extend) {
	const value = jsonSchema[key];
	if (value !== void 0) {
		const errorMessage = jsonSchema.errorMessage?.[key];
		return extend(zodSchema, value, errorMessage);
	}
	return zodSchema;
}

//#endregion
//#region src/utils/its.ts
const its = {
	an: {
		object: (x) => x.type === "object" || !x.type && (x.properties !== void 0 || x.additionalProperties !== void 0 || x.patternProperties !== void 0),
		array: (x) => x.type === "array",
		anyOf: (x) => x.anyOf !== void 0,
		allOf: (x) => x.allOf !== void 0,
		enum: (x) => x.enum !== void 0
	},
	a: {
		nullable: (x) => x.nullable === true,
		multipleType: (x) => Array.isArray(x.type),
		not: (x) => x.not !== void 0,
		const: (x) => x.const !== void 0,
		primitive: (x, p) => x.type === p,
		conditional: (x) => Boolean("if" in x && x.if && "then" in x && "else" in x && x.then && x.else),
		oneOf: (x) => x.oneOf !== void 0
	}
};

//#endregion
//#region src/parsers/parse-array.ts
const parseArray = (jsonSchema, refs) => {
	if (its.an.anyOf(jsonSchema)) {
		const types = /* @__PURE__ */ new Set();
		const itemsSchemas = [];
		jsonSchema.anyOf.forEach((option) => {
			if (typeof option === "object" && option.type) types.add(typeof option.type === "string" ? option.type : option.type[0]);
			if (typeof option === "object" && option.items) {
				const optionItems = option.items;
				if (!Array.isArray(optionItems) && typeof optionItems === "object") itemsSchemas.push(optionItems);
			}
		});
		let finalItems;
		if (itemsSchemas.length === 1) finalItems = itemsSchemas[0];
		else if (itemsSchemas.length > 1) finalItems = { anyOf: itemsSchemas };
		const newSchema = {
			...types.size > 0 ? { type: Array.from(types) } : { type: "array" },
			...finalItems && { items: finalItems }
		};
		[
			"default",
			"description",
			"examples",
			"title"
		].forEach((field) => {
			const value = jsonSchema[field];
			if (value !== void 0) newSchema[field] = value;
		});
		return parseSchema(newSchema, refs);
	}
	if (Array.isArray(jsonSchema.items)) return zod_v3.z.tuple(jsonSchema.items.map((v, i) => parseSchema(v, {
		...refs,
		path: [
			...refs.path,
			"items",
			i
		]
	})));
	let zodSchema = !jsonSchema.items ? zod_v3.z.array(zod_v3.z.any()) : zod_v3.z.array(parseSchema(jsonSchema.items, {
		...refs,
		path: [...refs.path, "items"]
	}));
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "minItems", (zs, minItems, errorMessage) => zs.min(minItems, errorMessage));
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "maxItems", (zs, maxItems, errorMessage) => zs.max(maxItems, errorMessage));
	if (typeof jsonSchema.min === "number" && typeof jsonSchema.minItems !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		minItems: jsonSchema.min
	}, "minItems", (zs, minItems, errorMessage) => zs.min(minItems, errorMessage));
	if (typeof jsonSchema.max === "number" && typeof jsonSchema.maxItems !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		maxItems: jsonSchema.max
	}, "maxItems", (zs, maxItems, errorMessage) => zs.max(maxItems, errorMessage));
	return zodSchema;
};

//#endregion
//#region src/parsers/parse-boolean.ts
const parseBoolean = (_jsonSchema) => {
	return zod_v3.z.boolean();
};

//#endregion
//#region src/parsers/parse-const.ts
const parseConst = (jsonSchema) => {
	return zod_v3.z.literal(jsonSchema.const);
};

//#endregion
//#region src/parsers/parse-default.ts
const parseDefault = (_jsonSchema) => {
	return zod_v3.z.any();
};

//#endregion
//#region src/parsers/parse-enum.ts
const parseEnum = (jsonSchema) => {
	if (jsonSchema.enum.length === 0) return zod_v3.z.never();
	if (jsonSchema.enum.length === 1) return zod_v3.z.literal(jsonSchema.enum[0]);
	if (jsonSchema.enum.every((x) => typeof x === "string")) return zod_v3.z.enum(jsonSchema.enum);
	return zod_v3.z.union(jsonSchema.enum.map((x) => zod_v3.z.literal(x)));
};

//#endregion
//#region src/parsers/parse-if-then-else.ts
const parseIfThenElse = (jsonSchema, refs) => {
	const $if = parseSchema(jsonSchema.if, {
		...refs,
		path: [...refs.path, "if"]
	});
	const $then = parseSchema(jsonSchema.then, {
		...refs,
		path: [...refs.path, "then"]
	});
	const $else = parseSchema(jsonSchema.else, {
		...refs,
		path: [...refs.path, "else"]
	});
	return zod_v3.z.union([$then, $else]).superRefine((value, ctx) => {
		const result = $if.safeParse(value).success ? $then.safeParse(value) : $else.safeParse(value);
		if (!result.success) result.error.errors.forEach((error) => ctx.addIssue(error));
	});
};

//#endregion
//#region src/parsers/parse-multiple-type.ts
const parseMultipleType = (jsonSchema, refs) => {
	return zod_v3.z.union(jsonSchema.type.map((type) => parseSchema({
		...jsonSchema,
		type
	}, refs)));
};

//#endregion
//#region src/parsers/parse-not.ts
const parseNot = (jsonSchema, refs) => {
	return zod_v3.z.any().refine((value) => !parseSchema(jsonSchema.not, {
		...refs,
		path: [...refs.path, "not"]
	}).safeParse(value).success, "Invalid input: Should NOT be valid against schema");
};

//#endregion
//#region src/parsers/parse-null.ts
const parseNull = (_jsonSchema) => {
	return zod_v3.z.null();
};

//#endregion
//#region src/utils/omit.ts
const omit = (obj, ...keys) => Object.keys(obj).reduce((acc, key) => {
	if (!keys.includes(key)) acc[key] = obj[key];
	return acc;
}, {});

//#endregion
//#region src/parsers/parse-nullable.ts
/**
* For compatibility with open api 3.0 nullable
*/
const parseNullable = (jsonSchema, refs) => {
	const hasNullDefault = jsonSchema.default === null;
	const zodSchema = parseSchema(hasNullDefault ? omit(omit(jsonSchema, "nullable"), "default") : omit(jsonSchema, "nullable"), refs, true).nullable();
	return hasNullDefault ? zodSchema.default(null) : zodSchema;
};

//#endregion
//#region src/parsers/parse-number.ts
const parseNumber = (jsonSchema) => {
	let zodSchema = zod_v3.z.number();
	let isInteger = false;
	if (jsonSchema.type === "integer") {
		isInteger = true;
		zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "type", (zs, _, errorMsg) => zs.int(errorMsg));
	} else if (jsonSchema.format === "int64") {
		isInteger = true;
		zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "format", (zs, _, errorMsg) => zs.int(errorMsg));
	}
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "multipleOf", (zs, multipleOf, errorMsg) => {
		if (multipleOf === 1) {
			if (isInteger) return zs;
			return zs.int(errorMsg);
		}
		return zs.multipleOf(multipleOf, errorMsg);
	});
	if (typeof jsonSchema.minimum === "number") if (jsonSchema.exclusiveMinimum === true) zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "minimum", (zs, minimum, errorMsg) => zs.gt(minimum, errorMsg));
	else zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "minimum", (zs, minimum, errorMsg) => zs.gte(minimum, errorMsg));
	else if (typeof jsonSchema.exclusiveMinimum === "number") zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "exclusiveMinimum", (zs, exclusiveMinimum, errorMsg) => zs.gt(exclusiveMinimum, errorMsg));
	if (typeof jsonSchema.maximum === "number") if (jsonSchema.exclusiveMaximum === true) zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "maximum", (zs, maximum, errorMsg) => zs.lt(maximum, errorMsg));
	else zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "maximum", (zs, maximum, errorMsg) => zs.lte(maximum, errorMsg));
	else if (typeof jsonSchema.exclusiveMaximum === "number") zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "exclusiveMaximum", (zs, exclusiveMaximum, errorMsg) => zs.lt(exclusiveMaximum, errorMsg));
	if (typeof jsonSchema.min === "number" && typeof jsonSchema.minimum !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		minimum: jsonSchema.min
	}, "minimum", (zs, minimum, errorMsg) => zs.gte(minimum, errorMsg));
	if (typeof jsonSchema.max === "number" && typeof jsonSchema.maximum !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		maximum: jsonSchema.max
	}, "maximum", (zs, maximum, errorMsg) => zs.lte(maximum, errorMsg));
	return zodSchema;
};

//#endregion
//#region src/parsers/parse-one-of.ts
const parseOneOf = (jsonSchema, refs) => {
	if (!jsonSchema.oneOf.length) return zod_v3.z.any();
	if (jsonSchema.oneOf.length === 1) return parseSchema(jsonSchema.oneOf[0], {
		...refs,
		path: [
			...refs.path,
			"oneOf",
			0
		]
	});
	return zod_v3.z.any().superRefine((x, ctx) => {
		const schemas = jsonSchema.oneOf.map((schema, i) => parseSchema(schema, {
			...refs,
			path: [
				...refs.path,
				"oneOf",
				i
			]
		}));
		const unionErrors = schemas.reduce((errors, schema) => ((result) => result.error ? [...errors, result.error] : errors)(schema.safeParse(x)), []);
		if (schemas.length - unionErrors.length !== 1) ctx.addIssue({
			path: ctx.path,
			code: "invalid_union",
			unionErrors,
			message: "Invalid input: Should pass single schema"
		});
	});
};

//#endregion
//#region src/parsers/parse-object.ts
function parseObjectProperties(objectSchema, refs) {
	if (!objectSchema.properties) return zod_v3.object({});
	const propertyKeys = Object.keys(objectSchema.properties);
	if (propertyKeys.length === 0) return zod_v3.object({});
	const properties = {};
	for (const key of propertyKeys) {
		const propJsonSchema = objectSchema.properties[key];
		const propZodSchema = parseSchema(propJsonSchema, {
			...refs,
			path: [
				...refs.path,
				"properties",
				key
			]
		});
		const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : false;
		if (!required && propJsonSchema && typeof propJsonSchema === "object" && "default" in propJsonSchema) if (propJsonSchema.default === null) {
			const hasAnyOfWithNull = propJsonSchema.anyOf && Array.isArray(propJsonSchema.anyOf) && propJsonSchema.anyOf.some((schema) => typeof schema === "object" && schema !== null && schema.type === "null");
			const hasOneOfWithNull = propJsonSchema.oneOf && Array.isArray(propJsonSchema.oneOf) && propJsonSchema.oneOf.some((schema) => typeof schema === "object" && schema !== null && schema.type === "null");
			const isNullable = "nullable" in propJsonSchema && propJsonSchema.nullable === true;
			if (hasAnyOfWithNull || hasOneOfWithNull || isNullable) properties[key] = propZodSchema.optional().default(null);
			else properties[key] = propZodSchema.nullable().optional().default(null);
		} else properties[key] = propZodSchema.optional().default(propJsonSchema.default);
		else properties[key] = required ? propZodSchema : propZodSchema.optional();
	}
	return zod_v3.object(properties);
}
function parseObject(objectSchema, refs) {
	const hasPatternProperties = Object.keys(objectSchema.patternProperties ?? {}).length > 0;
	const normalizedSchema = objectSchema.type === "object" ? objectSchema : {
		...objectSchema,
		type: "object"
	};
	const propertiesSchema = parseObjectProperties(normalizedSchema, refs);
	let zodSchema = propertiesSchema;
	const additionalProperties = normalizedSchema.additionalProperties !== void 0 ? parseSchema(normalizedSchema.additionalProperties, {
		...refs,
		path: [...refs.path, "additionalProperties"]
	}) : void 0;
	const isAdditionalPropertiesTrue = normalizedSchema.additionalProperties === true;
	if (normalizedSchema.patternProperties) {
		const parsedPatternProperties = Object.fromEntries(Object.entries(normalizedSchema.patternProperties).map(([key, value]) => {
			return [key, parseSchema(value, {
				...refs,
				path: [
					...refs.path,
					"patternProperties",
					key
				]
			})];
		}));
		const patternPropertyValues = Object.values(parsedPatternProperties);
		if (propertiesSchema) if (additionalProperties) zodSchema = propertiesSchema.catchall(zod_v3.union([...patternPropertyValues, additionalProperties]));
		else if (Object.keys(parsedPatternProperties).length > 1) zodSchema = propertiesSchema.catchall(zod_v3.union(patternPropertyValues));
		else zodSchema = propertiesSchema.catchall(patternPropertyValues[0]);
		else if (additionalProperties) zodSchema = zod_v3.record(zod_v3.union([...patternPropertyValues, additionalProperties]));
		else if (patternPropertyValues.length > 1) zodSchema = zod_v3.record(zod_v3.union(patternPropertyValues));
		else zodSchema = zod_v3.record(patternPropertyValues[0]);
		const objectPropertyKeys = new Set(Object.keys(normalizedSchema.properties ?? {}));
		zodSchema = zodSchema.superRefine((value, ctx) => {
			for (const key in value) {
				let wasMatched = objectPropertyKeys.has(key);
				for (const patternPropertyKey in normalizedSchema.patternProperties) {
					const regex = new RegExp(patternPropertyKey);
					if (key.match(regex)) {
						wasMatched = true;
						const result = parsedPatternProperties[patternPropertyKey].safeParse(value[key]);
						if (!result.success) ctx.addIssue({
							path: [...ctx.path, key],
							code: "custom",
							message: `Invalid input: Key matching regex /${key}/ must match schema`,
							params: { issues: result.error.issues }
						});
					}
				}
				if (!wasMatched && additionalProperties) {
					const result = additionalProperties.safeParse(value[key]);
					if (!result.success) ctx.addIssue({
						path: [...ctx.path, key],
						code: "custom",
						message: "Invalid input: must match catchall schema",
						params: { issues: result.error.issues }
					});
				}
			}
		});
	}
	let output;
	if (propertiesSchema) if (hasPatternProperties) output = zodSchema;
	else if (additionalProperties) if (additionalProperties instanceof zod_v3.ZodNever) output = propertiesSchema.strict();
	else if (isAdditionalPropertiesTrue) output = propertiesSchema.passthrough();
	else output = propertiesSchema.catchall(additionalProperties);
	else output = propertiesSchema.strict();
	else if (hasPatternProperties) output = zodSchema;
	else if (additionalProperties) if (additionalProperties instanceof zod_v3.ZodNever) output = zod_v3.object({}).strict();
	else if (isAdditionalPropertiesTrue) output = zod_v3.object({}).passthrough();
	else output = zod_v3.record(additionalProperties);
	else output = zod_v3.object({}).passthrough();
	if (its.an.anyOf(objectSchema)) output = output.and(parseAnyOf({
		...objectSchema,
		anyOf: objectSchema.anyOf.map((x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? {
			...x,
			type: "object"
		} : x)
	}, refs));
	if (its.a.oneOf(objectSchema)) output = output.and(parseOneOf({
		...objectSchema,
		oneOf: objectSchema.oneOf.map((x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? {
			...x,
			type: "object"
		} : x)
	}, refs));
	if (its.an.allOf(objectSchema)) output = output.and(parseAllOf({
		...objectSchema,
		allOf: objectSchema.allOf.map((x) => typeof x === "object" && !x.type && (x.properties ?? x.additionalProperties ?? x.patternProperties) ? {
			...x,
			type: "object"
		} : x)
	}, refs));
	return output;
}

//#endregion
//#region src/parsers/parse-string.ts
const parseString = (jsonSchema) => {
	let zodSchema = zod_v3.z.string();
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "format", (zs, format, errorMsg) => {
		switch (format) {
			case "email": return zs.email(errorMsg);
			case "ip": return zs.ip(errorMsg);
			case "ipv4": return zs.ip({
				version: "v4",
				message: errorMsg
			});
			case "ipv6": return zs.ip({
				version: "v6",
				message: errorMsg
			});
			case "uri": return zs.url(errorMsg);
			case "uuid": return zs.uuid(errorMsg);
			case "date-time": return zs.datetime({
				offset: true,
				message: errorMsg
			});
			case "time": return zs.time(errorMsg);
			case "date": return zs.date(errorMsg);
			case "binary": return zs.base64(errorMsg);
			case "duration": return zs.duration(errorMsg);
			default: return zs;
		}
	});
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "contentEncoding", (zs, _, errorMsg) => zs.base64(errorMsg));
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "pattern", (zs, pattern, errorMsg) => zs.regex(new RegExp(pattern), errorMsg));
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "minLength", (zs, minLength, errorMsg) => zs.min(minLength, errorMsg));
	zodSchema = extendSchemaWithMessage(zodSchema, jsonSchema, "maxLength", (zs, maxLength, errorMsg) => zs.max(maxLength, errorMsg));
	if (typeof jsonSchema.min === "number" && typeof jsonSchema.minLength !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		minLength: jsonSchema.min
	}, "minLength", (zs, minLength, errorMsg) => zs.min(minLength, errorMsg));
	if (typeof jsonSchema.max === "number" && typeof jsonSchema.maxLength !== "number") zodSchema = extendSchemaWithMessage(zodSchema, {
		...jsonSchema,
		maxLength: jsonSchema.max
	}, "maxLength", (zs, maxLength, errorMsg) => zs.max(maxLength, errorMsg));
	return zodSchema;
};

//#endregion
//#region src/parsers/parse-schema.ts
const addDescribes = (jsonSchema, zodSchema) => {
	let description = "";
	if (jsonSchema.description) description = jsonSchema.description;
	else if (jsonSchema.title) description = jsonSchema.title;
	if (jsonSchema.example !== void 0) {
		const exampleText = `Example: ${JSON.stringify(jsonSchema.example)}`;
		description = description ? `${description}\n${exampleText}` : exampleText;
	} else if (jsonSchema.examples !== void 0 && Array.isArray(jsonSchema.examples)) {
		const examples = jsonSchema.examples;
		if (examples && examples.length && examples.length > 0) {
			const exampleText = examples.length === 1 ? `Example: ${JSON.stringify(examples[0])}` : `Examples:\n${examples.map((ex) => `  ${JSON.stringify(ex)}`).join("\n")}`;
			description = description ? `${description}\n${exampleText}` : exampleText;
		}
	}
	if (description) zodSchema = zodSchema.describe(description);
	return zodSchema;
};
const addDefaults = (jsonSchema, zodSchema, refs) => {
	if (jsonSchema.default !== void 0) {
		if (jsonSchema.default === null) {
			if (refs?.path.some((segment) => segment === "anyOf" || segment === "oneOf") && jsonSchema.type && jsonSchema.type !== "null" && !jsonSchema.nullable) return zodSchema;
		}
		zodSchema = zodSchema.default(jsonSchema.default);
	}
	return zodSchema;
};
const addAnnotations = (jsonSchema, zodSchema) => {
	if (jsonSchema.readOnly) zodSchema = zodSchema.readonly();
	return zodSchema;
};
const selectParser = (schema, refs) => {
	if (its.a.nullable(schema)) return parseNullable(schema, refs);
	else if (its.an.object(schema)) return parseObject(schema, refs);
	else if (its.an.array(schema)) return parseArray(schema, refs);
	else if (its.an.anyOf(schema)) return parseAnyOf(schema, refs);
	else if (its.an.allOf(schema)) return parseAllOf(schema, refs);
	else if (its.a.oneOf(schema)) return parseOneOf(schema, refs);
	else if (its.a.not(schema)) return parseNot(schema, refs);
	else if (its.an.enum(schema)) return parseEnum(schema);
	else if (its.a.const(schema)) return parseConst(schema);
	else if (its.a.multipleType(schema)) return parseMultipleType(schema, refs);
	else if (its.a.primitive(schema, "string")) return parseString(schema);
	else if (its.a.primitive(schema, "number") || its.a.primitive(schema, "integer")) return parseNumber(schema);
	else if (its.a.primitive(schema, "boolean")) return parseBoolean(schema);
	else if (its.a.primitive(schema, "null")) return parseNull(schema);
	else if (its.a.conditional(schema)) return parseIfThenElse(schema, refs);
	else return parseDefault(schema);
};
const parseSchema = (jsonSchema, refs = {
	seen: /* @__PURE__ */ new Map(),
	path: []
}, blockMeta) => {
	if (typeof jsonSchema !== "object") return jsonSchema ? zod_v3.any() : zod_v3.never();
	if (refs.parserOverride) {
		const custom = refs.parserOverride(jsonSchema, refs);
		if (custom instanceof zod_v3.ZodType) return custom;
	}
	let seen = refs.seen.get(jsonSchema);
	if (seen) {
		if (seen.r !== void 0) return seen.r;
		if (refs.depth === void 0 || seen.n >= refs.depth) return zod_v3.any();
		seen.n += 1;
	} else {
		seen = {
			r: void 0,
			n: 0
		};
		refs.seen.set(jsonSchema, seen);
	}
	let parsedZodSchema = selectParser(jsonSchema, refs);
	if (!blockMeta) {
		if (!refs.withoutDescribes) parsedZodSchema = addDescribes(jsonSchema, parsedZodSchema);
		if (!refs.withoutDefaults) parsedZodSchema = addDefaults(jsonSchema, parsedZodSchema, refs);
		parsedZodSchema = addAnnotations(jsonSchema, parsedZodSchema);
	}
	seen.r = parsedZodSchema;
	return parsedZodSchema;
};

//#endregion
//#region src/parsers/parse-object-shape.ts
/**
* Parses a JSON Schema object and returns the raw shape (property keys mapped to Zod types).
* This is useful when you need ZodRawShape instead of a complete ZodObject.
*
* @param objectSchema - The JSON Schema object to parse
* @param refs - Parser references for handling nested schemas
* @returns A Zod raw shape object
*/
function parseObjectShape(objectSchema, refs) {
	if (!objectSchema.properties) return {};
	const propertyKeys = Object.keys(objectSchema.properties);
	if (propertyKeys.length === 0) return {};
	const properties = {};
	for (const key of propertyKeys) {
		const propJsonSchema = objectSchema.properties[key];
		const propZodSchema = parseSchema(propJsonSchema, {
			...refs,
			path: [
				...refs.path,
				"properties",
				key
			]
		});
		const required = Array.isArray(objectSchema.required) ? objectSchema.required.includes(key) : false;
		if (!required && propJsonSchema && typeof propJsonSchema === "object" && "default" in propJsonSchema) if (propJsonSchema.default === null) {
			const hasAnyOfWithNull = propJsonSchema.anyOf && Array.isArray(propJsonSchema.anyOf) && propJsonSchema.anyOf.some((schema) => typeof schema === "object" && schema !== null && schema.type === "null");
			const hasOneOfWithNull = propJsonSchema.oneOf && Array.isArray(propJsonSchema.oneOf) && propJsonSchema.oneOf.some((schema) => typeof schema === "object" && schema !== null && schema.type === "null");
			const isNullable = "nullable" in propJsonSchema && propJsonSchema.nullable === true;
			if (hasAnyOfWithNull || hasOneOfWithNull || isNullable) properties[key] = propZodSchema.optional().default(null);
			else properties[key] = propZodSchema.nullable().optional().default(null);
		} else properties[key] = propZodSchema.optional().default(propJsonSchema.default);
		else properties[key] = required ? propZodSchema : propZodSchema.optional();
	}
	return properties;
}

//#endregion
//#region src/json-schema-to-zod.ts
const jsonSchemaToZod = (schema, options = {}) => {
	return parseSchema(schema, {
		path: [],
		seen: /* @__PURE__ */ new Map(),
		...options
	});
};
/**
* Converts a JSON Schema object to a Zod raw shape.
* This is useful when you need the shape object (e.g., `{ name: z.string(), age: z.number() }`)
* rather than a complete ZodObject schema.
*
* This is particularly useful for APIs that expect ZodRawShape instead of ZodType,
* such as the Claude Agent SDK's `tool()` function.
*
* @param schema - The JSON Schema to convert (must be an object schema)
* @param options - Optional configuration for the conversion
* @returns A Zod raw shape object with property keys mapped to Zod types
*/
const jsonSchemaToZodShape = (schema, options = {}) => {
	if (typeof schema !== "object" || schema === null) return {};
	return parseObjectShape(schema, {
		path: [],
		seen: /* @__PURE__ */ new Map(),
		...options
	});
};

//#endregion
exports.jsonSchemaToZod = jsonSchemaToZod;
exports.jsonSchemaToZodShape = jsonSchemaToZodShape;